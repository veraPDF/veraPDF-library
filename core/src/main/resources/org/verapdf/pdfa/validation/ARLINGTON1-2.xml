<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<profile xmlns="http://www.verapdf.org/ValidationProfile" flavour="ARLINGTON1_2">
	<details creator="veraPDF Consortium" created="2022-05-23T21:45:28.872+03:00">
		<name>Arlington PDF 1.2 profile</name>
		<description>Rules against PDF 1.2 Specification</description>
	</details>
	<hash></hash>
	<rules>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST" testNumber="1"/>
			<description>AAPL_ST shall not contain entries except Radius, Type, ColorSpace, Color, Subtype, Offset</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Radius' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Offset' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AAPL_ST contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Radius' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Offset' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Color" testNumber="8"/>
			<description>Entry Color in AAPL_ST shall have type Array</description>
			<test>containsColor == false || ColorHasTypeArray == true</test>
			<error>
				<message>Entry Color in AAPL_ST has type %1 instead of type Array</message>
				<arguments>
					<argument>ColorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Color" testNumber="23"/>
			<description>Entry Color in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsColor == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Color in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in AAPL_ST shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in AAPL_ST is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in AAPL_ST shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in AAPL_ST has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-ColorSpace" testNumber="23"/>
			<description>Entry ColorSpace in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsColorSpace == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry ColorSpace in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in AAPL_ST shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in AAPL_ST has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Offset" testNumber="8"/>
			<description>Entry Offset in AAPL_ST shall have type Array</description>
			<test>containsOffset == false || OffsetHasTypeArray == true</test>
			<error>
				<message>Entry Offset in AAPL_ST has type %1 instead of type Array</message>
				<arguments>
					<argument>OffsetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Offset" testNumber="23"/>
			<description>Entry Offset in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsOffset == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Offset in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Radius" testNumber="8"/>
			<description>Entry Radius in AAPL_ST shall have type Number</description>
			<test>containsRadius == false || RadiusHasTypeNumber == true</test>
			<error>
				<message>Entry Radius in AAPL_ST has type %1 instead of type Number</message>
				<arguments>
					<argument>RadiusType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Radius" testNumber="23"/>
			<description>Entry Radius in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsRadius == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Radius in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Radius-Number" testNumber="9"/>
			<description>Entry Radius with type Number in AAPL_ST shall satisfy special case: fn:Eval(@Radius &gt; 0)</description>
			<test>RadiusHasTypeNumber != true || (RadiusNumberValue &gt; 0)</test>
			<error>
				<message>Entry Radius with type Number in AAPL_ST does not satisfy special case: fn:Eval(@Radius &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Subtype" testNumber="8"/>
			<description>Entry Subtype in AAPL_ST shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AAPL_ST has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Subtype" testNumber="23"/>
			<description>Entry Subtype in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsSubtype == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Subtype in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AAPL_ST shall have value Shadow</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Shadow"</test>
			<error>
				<message>Entry Subtype with type Name in AAPL_ST has incorrect value %1 instead of Shadow</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Type" testNumber="8"/>
			<description>Entry Type in AAPL_ST shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AAPL_ST has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Type" testNumber="23"/>
			<description>Entry Type in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsType == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Type in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_2" clause="AAPL_ST-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AAPL_ST shall have value Style</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Style"</test>
			<error>
				<message>Entry Type with type Name in AAPL_ST has incorrect value %1 instead of Style</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo" testNumber="1"/>
			<description>ActionGoTo shall not contain entries except Type, S, D, Next</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionGoTo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo" testNumber="22"/>
			<description>ActionGoTo shall not contain entry SD in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'SD').length == 0</test>
			<error>
				<message>ActionGoTo contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'SD').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-D-Array" testNumber="17"/>
			<description>Entry D with type Array in ActionGoTo shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in ActionGoTo is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-D" testNumber="8"/>
			<description>Entry D in ActionGoTo shall have one of types: Array, Name, StringByte</description>
			<test>containsD == false || DHasTypeArray == true || DHasTypeName == true || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in ActionGoTo has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-D" testNumber="7"/>
			<description>Entry D in ActionGoTo is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionGoTo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionGoTo shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionGoTo is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-Next" testNumber="8"/>
			<description>Entry Next in ActionGoTo shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionGoTo has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-S" testNumber="8"/>
			<description>Entry S in ActionGoTo shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionGoTo has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-S" testNumber="7"/>
			<description>Entry S in ActionGoTo is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionGoTo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionGoTo shall have value GoTo</description>
			<test>SHasTypeName != true || SNameValue == "GoTo"</test>
			<error>
				<message>Entry S with type Name in ActionGoTo has incorrect value %1 instead of GoTo</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-Type" testNumber="8"/>
			<description>Entry Type in ActionGoTo shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionGoTo has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_2" clause="ActionGoTo-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionGoTo shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionGoTo has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR" testNumber="1"/>
			<description>ActionGoToR shall not contain entries except Type, S, D, F, NewWindow, Next</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionGoToR contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR" testNumber="22"/>
			<description>ActionGoToR shall not contain entry SD in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'SD').length == 0</test>
			<error>
				<message>ActionGoToR contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'SD').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-D-Array" testNumber="17"/>
			<description>Entry D with type Array in ActionGoToR shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in ActionGoToR is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-D" testNumber="8"/>
			<description>Entry D in ActionGoToR shall have one of types: Array, Name, StringByte</description>
			<test>containsD == false || DHasTypeArray == true || DHasTypeName == true || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in ActionGoToR has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-D" testNumber="7"/>
			<description>Entry D in ActionGoToR is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-F" testNumber="8"/>
			<description>Entry F in ActionGoToR shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionGoToR has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-F" testNumber="7"/>
			<description>Entry F in ActionGoToR is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-NewWindow" testNumber="8"/>
			<description>Entry NewWindow in ActionGoToR shall have type Boolean</description>
			<test>containsNewWindow == false || NewWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry NewWindow in ActionGoToR has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NewWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionGoToR shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionGoToR is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-Next" testNumber="8"/>
			<description>Entry Next in ActionGoToR shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionGoToR has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-S" testNumber="8"/>
			<description>Entry S in ActionGoToR shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionGoToR has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-S" testNumber="7"/>
			<description>Entry S in ActionGoToR is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionGoToR shall have value GoToR</description>
			<test>SHasTypeName != true || SNameValue == "GoToR"</test>
			<error>
				<message>Entry S with type Name in ActionGoToR has incorrect value %1 instead of GoToR</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-Type" testNumber="8"/>
			<description>Entry Type in ActionGoToR shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionGoToR has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_2" clause="ActionGoToR-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionGoToR shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionGoToR has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide" testNumber="1"/>
			<description>ActionHide shall not contain entries except Type, S, T, Next, H</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'H' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionHide contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'H' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-H" testNumber="8"/>
			<description>Entry H in ActionHide shall have type Boolean</description>
			<test>containsH == false || HHasTypeBoolean == true</test>
			<error>
				<message>Entry H in ActionHide has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionHide shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionHide is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-Next" testNumber="8"/>
			<description>Entry Next in ActionHide shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionHide has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-S" testNumber="8"/>
			<description>Entry S in ActionHide shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionHide has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-S" testNumber="7"/>
			<description>Entry S in ActionHide is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionHide is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionHide shall have value Hide</description>
			<test>SHasTypeName != true || SNameValue == "Hide"</test>
			<error>
				<message>Entry S with type Name in ActionHide has incorrect value %1 instead of Hide</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-T-Dictionary" testNumber="17"/>
			<description>Entry T with type Dictionary in ActionHide shall be one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>THasTypeDictionary != true || T_size == 1</test>
			<error>
				<message>Entry T with type Dictionary in ActionHide is not one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-T" testNumber="8"/>
			<description>Entry T in ActionHide shall have one of types: Array, Dictionary, StringText</description>
			<test>containsT == false || THasTypeArray == true || THasTypeDictionary == true || THasTypeStringText == true</test>
			<error>
				<message>Entry T in ActionHide has type %1 instead of one of types: Array, Dictionary, StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-T" testNumber="7"/>
			<description>Entry T in ActionHide is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in ActionHide is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in ActionHide shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in ActionHide is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-T-StringText" testNumber="9"/>
			<description>Entry T with type StringText in ActionHide shall satisfy special case: fn:Eval(fn:IsFieldName(@T))</description>
			<test>THasTypeStringText != true || (TIsFieldName == true)</test>
			<error>
				<message>Entry T with type StringText in ActionHide does not satisfy special case: fn:Eval(fn:IsFieldName(@T))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-Type" testNumber="8"/>
			<description>Entry Type in ActionHide shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionHide has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_2" clause="ActionHide-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionHide shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionHide has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData" testNumber="1"/>
			<description>ActionImportData shall not contain entries except Type, S, F, Next</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionImportData contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-F" testNumber="8"/>
			<description>Entry F in ActionImportData shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionImportData has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-F" testNumber="7"/>
			<description>Entry F in ActionImportData is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionImportData is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionImportData shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionImportData is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-Next" testNumber="8"/>
			<description>Entry Next in ActionImportData shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionImportData has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-S" testNumber="8"/>
			<description>Entry S in ActionImportData shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionImportData has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-S" testNumber="7"/>
			<description>Entry S in ActionImportData is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionImportData is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionImportData shall have value ImportData</description>
			<test>SHasTypeName != true || SNameValue == "ImportData"</test>
			<error>
				<message>Entry S with type Name in ActionImportData has incorrect value %1 instead of ImportData</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-Type" testNumber="8"/>
			<description>Entry Type in ActionImportData shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionImportData has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_2" clause="ActionImportData-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionImportData shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionImportData has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch" testNumber="1"/>
			<description>ActionLaunch shall not contain entries except Unix, Type, S, F, NewWindow, Next, Win, Mac</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Unix' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Win' &amp;&amp; elem != 'Mac' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionLaunch contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Unix' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Win' &amp;&amp; elem != 'Mac' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-F" testNumber="8"/>
			<description>Entry F in ActionLaunch shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionLaunch has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-F" testNumber="11"/>
			<description>Entry F in ActionLaunch is required, when fn:Not(fn:IsPresent(Win) || fn:IsPresent(Mac) || fn:IsPresent(Unix))</description>
			<test>containsF == true || ((containsWin == true) || (containsMac == true) || (containsUnix == true))</test>
			<error>
				<message>Entry F in ActionLaunch is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Mac" testNumber="8"/>
			<description>Entry Mac in ActionLaunch shall have type Null</description>
			<test>containsMac == false || MacHasTypeNull == true</test>
			<error>
				<message>Entry Mac in ActionLaunch has type %1 instead of type Null</message>
				<arguments>
					<argument>MacType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-NewWindow" testNumber="8"/>
			<description>Entry NewWindow in ActionLaunch shall have type Boolean</description>
			<test>containsNewWindow == false || NewWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry NewWindow in ActionLaunch has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NewWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionLaunch shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionLaunch is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Next" testNumber="8"/>
			<description>Entry Next in ActionLaunch shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionLaunch has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-S" testNumber="8"/>
			<description>Entry S in ActionLaunch shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionLaunch has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-S" testNumber="7"/>
			<description>Entry S in ActionLaunch is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionLaunch is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionLaunch shall have value Launch</description>
			<test>SHasTypeName != true || SNameValue == "Launch"</test>
			<error>
				<message>Entry S with type Name in ActionLaunch has incorrect value %1 instead of Launch</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Type" testNumber="8"/>
			<description>Entry Type in ActionLaunch shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionLaunch has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionLaunch shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionLaunch has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Unix" testNumber="8"/>
			<description>Entry Unix in ActionLaunch shall have type Null</description>
			<test>containsUnix == false || UnixHasTypeNull == true</test>
			<error>
				<message>Entry Unix in ActionLaunch has type %1 instead of type Null</message>
				<arguments>
					<argument>UnixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_2" clause="ActionLaunch-Win" testNumber="8"/>
			<description>Entry Win in ActionLaunch shall have type Dictionary</description>
			<test>containsWin == false || WinHasTypeDictionary == true</test>
			<error>
				<message>Entry Win in ActionLaunch has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>WinType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie" testNumber="1"/>
			<description>ActionMovie shall not contain entries except Type, S, T, Next, Operation, Annotation</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Operation' &amp;&amp; elem != 'Annotation' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Operation' &amp;&amp; elem != 'Annotation' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Annotation" testNumber="8"/>
			<description>Entry Annotation in ActionMovie shall have type Dictionary</description>
			<test>containsAnnotation == false || AnnotationHasTypeDictionary == true</test>
			<error>
				<message>Entry Annotation in ActionMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AnnotationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionMovie shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionMovie is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Next" testNumber="8"/>
			<description>Entry Next in ActionMovie shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionMovie has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Operation" testNumber="8"/>
			<description>Entry Operation in ActionMovie shall have type Name</description>
			<test>containsOperation == false || OperationHasTypeName == true</test>
			<error>
				<message>Entry Operation in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>OperationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Operation-Name" testNumber="6"/>
			<description>Entry Operation with type Name in ActionMovie shall have one of values: Play, Pause, Stop, Resume</description>
			<test>OperationHasTypeName != true || OperationNameValue == "Play" || OperationNameValue == "Stop" || OperationNameValue == "Pause" || OperationNameValue == "Resume"</test>
			<error>
				<message>Entry Operation with type Name in ActionMovie has incorrect value %1 instead of Play, Pause, Stop, Resume</message>
				<arguments>
					<argument>OperationNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-S" testNumber="8"/>
			<description>Entry S in ActionMovie shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-S" testNumber="7"/>
			<description>Entry S in ActionMovie is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionMovie shall have value Movie</description>
			<test>SHasTypeName != true || SNameValue == "Movie"</test>
			<error>
				<message>Entry S with type Name in ActionMovie has incorrect value %1 instead of Movie</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-T" testNumber="8"/>
			<description>Entry T in ActionMovie shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in ActionMovie has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Type" testNumber="8"/>
			<description>Entry Type in ActionMovie shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_2" clause="ActionMovie-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionMovie shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionMovie has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP" testNumber="1"/>
			<description>ActionNOP shall not contain entries except Type, S</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionNOP contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-S" testNumber="8"/>
			<description>Entry S in ActionNOP shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionNOP has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-S" testNumber="7"/>
			<description>Entry S in ActionNOP is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionNOP is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-S" testNumber="5"/>
			<description>Entry S in ActionNOP is deprecated since PDF 1.2</description>
			<test>containsS == false</test>
			<error>
				<message>Entry S in ActionNOP is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionNOP shall have value NOP</description>
			<test>SHasTypeName != true || SNameValue == "NOP"</test>
			<error>
				<message>Entry S with type Name in ActionNOP has incorrect value %1 instead of NOP</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-Type" testNumber="8"/>
			<description>Entry Type in ActionNOP shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionNOP has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-Type" testNumber="5"/>
			<description>Entry Type in ActionNOP is deprecated since PDF 1.2</description>
			<test>containsType == false</test>
			<error>
				<message>Entry Type in ActionNOP is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNOP">
			<id specification="PDF_1_2" clause="ActionNOP-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionNOP shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionNOP has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed" testNumber="1"/>
			<description>ActionNamed shall not contain entries except Type, S, Next, N</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionNamed contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-N" testNumber="8"/>
			<description>Entry N in ActionNamed shall have type Name</description>
			<test>containsN == false || NHasTypeName == true</test>
			<error>
				<message>Entry N in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-N" testNumber="7"/>
			<description>Entry N in ActionNamed is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in ActionNamed is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionNamed shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionNamed is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-Next" testNumber="8"/>
			<description>Entry Next in ActionNamed shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionNamed has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-S" testNumber="8"/>
			<description>Entry S in ActionNamed shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-S" testNumber="7"/>
			<description>Entry S in ActionNamed is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionNamed is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionNamed shall have value Named</description>
			<test>SHasTypeName != true || SNameValue == "Named"</test>
			<error>
				<message>Entry S with type Name in ActionNamed has incorrect value %1 instead of Named</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-Type" testNumber="8"/>
			<description>Entry Type in ActionNamed shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_2" clause="ActionNamed-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionNamed shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionNamed has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm" testNumber="1"/>
			<description>ActionResetForm shall not contain entries except Type, Fields, S, Next, Flags</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Flags' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionResetForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Flags' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Fields" testNumber="8"/>
			<description>Entry Fields in ActionResetForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in ActionResetForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Flags" testNumber="8"/>
			<description>Entry Flags in ActionResetForm shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in ActionResetForm has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Flags-Bitmask" testNumber="6"/>
			<description>Entry Flags with type Bitmask in ActionResetForm shall have one of values: 0, 1</description>
			<test>FlagsHasTypeBitmask != true || FlagsBitmaskValue == 0 || FlagsBitmaskValue == 1</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionResetForm has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>FlagsBitmaskValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in ActionResetForm shall satisfy special case: fn:Eval(fn:BitsClear(2, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 1 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 2 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionResetForm does not satisfy special case: fn:Eval(fn:BitsClear(2, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionResetForm shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionResetForm is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Next" testNumber="8"/>
			<description>Entry Next in ActionResetForm shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionResetForm has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-S" testNumber="8"/>
			<description>Entry S in ActionResetForm shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionResetForm has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-S" testNumber="7"/>
			<description>Entry S in ActionResetForm is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionResetForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionResetForm shall have value ResetForm</description>
			<test>SHasTypeName != true || SNameValue == "ResetForm"</test>
			<error>
				<message>Entry S with type Name in ActionResetForm has incorrect value %1 instead of ResetForm</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Type" testNumber="8"/>
			<description>Entry Type in ActionResetForm shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionResetForm has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_2" clause="ActionResetForm-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionResetForm shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionResetForm has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState" testNumber="1"/>
			<description>ActionSetState shall not contain entries except AS, Type, S, T</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionSetState contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-AS" testNumber="8"/>
			<description>Entry AS in ActionSetState shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in ActionSetState has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-AS" testNumber="5"/>
			<description>Entry AS in ActionSetState is deprecated since PDF 1.2</description>
			<test>containsAS == false</test>
			<error>
				<message>Entry AS in ActionSetState is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-S" testNumber="8"/>
			<description>Entry S in ActionSetState shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionSetState has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-S" testNumber="7"/>
			<description>Entry S in ActionSetState is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionSetState is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-S" testNumber="5"/>
			<description>Entry S in ActionSetState is deprecated since PDF 1.2</description>
			<test>containsS == false</test>
			<error>
				<message>Entry S in ActionSetState is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionSetState shall have value SetState</description>
			<test>SHasTypeName != true || SNameValue == "SetState"</test>
			<error>
				<message>Entry S with type Name in ActionSetState has incorrect value %1 instead of SetState</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-T-Dictionary" testNumber="17"/>
			<description>Entry T with type Dictionary in ActionSetState shall be one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>THasTypeDictionary != true || T_size == 1</test>
			<error>
				<message>Entry T with type Dictionary in ActionSetState is not one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-T" testNumber="8"/>
			<description>Entry T in ActionSetState shall have one of types: Array, Dictionary</description>
			<test>containsT == false || THasTypeArray == true || THasTypeDictionary == true</test>
			<error>
				<message>Entry T in ActionSetState has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-T" testNumber="7"/>
			<description>Entry T in ActionSetState is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in ActionSetState is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-T" testNumber="5"/>
			<description>Entry T in ActionSetState is deprecated since PDF 1.2</description>
			<test>containsT == false</test>
			<error>
				<message>Entry T in ActionSetState is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in ActionSetState shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in ActionSetState is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-Type" testNumber="8"/>
			<description>Entry Type in ActionSetState shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionSetState has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-Type" testNumber="5"/>
			<description>Entry Type in ActionSetState is deprecated since PDF 1.2</description>
			<test>containsType == false</test>
			<error>
				<message>Entry Type in ActionSetState is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSetState">
			<id specification="PDF_1_2" clause="ActionSetState-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionSetState shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionSetState has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound" testNumber="1"/>
			<description>ActionSound shall not contain entries except Synchronous, Type, S, Volume, Next, Repeat, Sound, Mix</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Synchronous' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Volume' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Repeat' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'Mix' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Synchronous' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Volume' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Repeat' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'Mix' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Mix" testNumber="8"/>
			<description>Entry Mix in ActionSound shall have type Boolean</description>
			<test>containsMix == false || MixHasTypeBoolean == true</test>
			<error>
				<message>Entry Mix in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>MixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionSound shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionSound is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Next" testNumber="8"/>
			<description>Entry Next in ActionSound shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionSound has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Repeat" testNumber="8"/>
			<description>Entry Repeat in ActionSound shall have type Boolean</description>
			<test>containsRepeat == false || RepeatHasTypeBoolean == true</test>
			<error>
				<message>Entry Repeat in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>RepeatType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-S" testNumber="8"/>
			<description>Entry S in ActionSound shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionSound has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-S" testNumber="7"/>
			<description>Entry S in ActionSound is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionSound shall have value Sound</description>
			<test>SHasTypeName != true || SNameValue == "Sound"</test>
			<error>
				<message>Entry S with type Name in ActionSound has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Sound" testNumber="8"/>
			<description>Entry Sound in ActionSound shall have type Stream</description>
			<test>containsSound == false || SoundHasTypeStream == true</test>
			<error>
				<message>Entry Sound in ActionSound has type %1 instead of type Stream</message>
				<arguments>
					<argument>SoundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Sound" testNumber="7"/>
			<description>Entry Sound in ActionSound is required</description>
			<test>containsSound == true</test>
			<error>
				<message>Entry Sound in ActionSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Sound-Stream" testNumber="10"/>
			<description>Entry Sound with type Stream in ActionSound shall be indirect</description>
			<test>SoundHasTypeStream != true || isSoundIndirect == true</test>
			<error>
				<message>Entry Sound with type Stream in ActionSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Synchronous" testNumber="8"/>
			<description>Entry Synchronous in ActionSound shall have type Boolean</description>
			<test>containsSynchronous == false || SynchronousHasTypeBoolean == true</test>
			<error>
				<message>Entry Synchronous in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SynchronousType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Type" testNumber="8"/>
			<description>Entry Type in ActionSound shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionSound has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionSound shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionSound has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Volume" testNumber="8"/>
			<description>Entry Volume in ActionSound shall have type Number</description>
			<test>containsVolume == false || VolumeHasTypeNumber == true</test>
			<error>
				<message>Entry Volume in ActionSound has type %1 instead of type Number</message>
				<arguments>
					<argument>VolumeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_2" clause="ActionSound-Volume-Number" testNumber="14"/>
			<description>Entry Volume with type Number in ActionSound shall satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</description>
			<test>VolumeHasTypeNumber != true || (VolumeNumberValue &gt;= -1) &amp;&amp; (VolumeNumberValue &lt;= 1)</test>
			<error>
				<message>Entry Volume with type Number in ActionSound does not satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm" testNumber="1"/>
			<description>ActionSubmitForm shall not contain entries except Fields, S, F, CharSet, Flags</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Fields' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Flags' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionSubmitForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Fields' &amp;&amp; elem != 'S' &amp;&amp; elem != 'F' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Flags' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-CharSet" testNumber="8"/>
			<description>Entry CharSet in ActionSubmitForm shall have type String</description>
			<test>containsCharSet == false || CharSetHasTypeString == true</test>
			<error>
				<message>Entry CharSet in ActionSubmitForm has type %1 instead of type String</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-CharSet-String" testNumber="6"/>
			<description>Entry CharSet with type String in ActionSubmitForm shall have one of values: GBK, UHC, utf-16, utf-8, Shift-JIS, BigFive</description>
			<test>CharSetHasTypeString != true || CharSetStringValue == "utf-8" || CharSetStringValue == "utf-16" || CharSetStringValue == "Shift-JIS" || CharSetStringValue == "BigFive" || CharSetStringValue == "GBK" || CharSetStringValue == "UHC"</test>
			<error>
				<message>Entry CharSet with type String in ActionSubmitForm has incorrect value %1 instead of GBK, UHC, utf-16, utf-8, Shift-JIS, BigFive</message>
				<arguments>
					<argument>CharSetStringValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-F" testNumber="8"/>
			<description>Entry F in ActionSubmitForm shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionSubmitForm has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-F" testNumber="7"/>
			<description>Entry F in ActionSubmitForm is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionSubmitForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-Fields" testNumber="8"/>
			<description>Entry Fields in ActionSubmitForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in ActionSubmitForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-Flags" testNumber="8"/>
			<description>Entry Flags in ActionSubmitForm shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in ActionSubmitForm has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in ActionSubmitForm shall satisfy special case: fn:Eval(fn:BitClear(13) &amp;&amp; fn:BitsClear(15, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionSubmitForm does not satisfy special case: fn:Eval(fn:BitClear(13) &amp;&amp; fn:BitsClear(15, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-S" testNumber="8"/>
			<description>Entry S in ActionSubmitForm shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionSubmitForm has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-S" testNumber="7"/>
			<description>Entry S in ActionSubmitForm is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionSubmitForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_2" clause="ActionSubmitForm-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionSubmitForm shall have value SubmitForm</description>
			<test>SHasTypeName != true || SNameValue == "SubmitForm"</test>
			<error>
				<message>Entry S with type Name in ActionSubmitForm has incorrect value %1 instead of SubmitForm</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread" testNumber="1"/>
			<description>ActionThread shall not contain entries except B, Type, S, D, F, Next</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionThread contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-B" testNumber="8"/>
			<description>Entry B in ActionThread shall have one of types: Dictionary, Integer</description>
			<test>containsB == false || BHasTypeDictionary == true || BHasTypeInteger == true</test>
			<error>
				<message>Entry B in ActionThread has type %1 instead of one of types: Dictionary, Integer</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-B-Dictionary" testNumber="10"/>
			<description>Entry B with type Dictionary in ActionThread shall be indirect</description>
			<test>BHasTypeDictionary != true || isBIndirect == true</test>
			<error>
				<message>Entry B with type Dictionary in ActionThread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-B-Integer" testNumber="14"/>
			<description>Entry B with type Integer in ActionThread shall satisfy possible value predicate: fn:Eval(@B &gt;= 0)</description>
			<test>BHasTypeInteger != true || BIntegerValue &gt;= 0</test>
			<error>
				<message>Entry B with type Integer in ActionThread does not satisfy possible value predicate: fn:Eval(@B &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-D" testNumber="8"/>
			<description>Entry D in ActionThread shall have one of types: Dictionary, Integer, StringText</description>
			<test>containsD == false || DHasTypeDictionary == true || DHasTypeInteger == true || DHasTypeStringText == true</test>
			<error>
				<message>Entry D in ActionThread has type %1 instead of one of types: Dictionary, Integer, StringText</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-D" testNumber="7"/>
			<description>Entry D in ActionThread is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionThread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-D-Dictionary" testNumber="10"/>
			<description>Entry D with type Dictionary in ActionThread shall be indirect</description>
			<test>DHasTypeDictionary != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Dictionary in ActionThread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-D-Integer" testNumber="14"/>
			<description>Entry D with type Integer in ActionThread shall satisfy possible value predicate: fn:Eval((@D &gt;= 0) &amp;&amp; (@D &lt; fn:ArrayLength(trailer::Catalog::Threads)))</description>
			<test>DHasTypeInteger != true || (DIntegerValue &gt;= 0) &amp;&amp; (trailerCatalogThreadsHasTypeArray == false || (DIntegerValue &lt; trailerCatalogThreadsArraySize))</test>
			<error>
				<message>Entry D with type Integer in ActionThread does not satisfy possible value predicate: fn:Eval((@D &gt;= 0) &amp;&amp; (@D &lt; fn:ArrayLength(trailer::Catalog::Threads)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-F" testNumber="8"/>
			<description>Entry F in ActionThread shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionThread has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionThread shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionThread is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-Next" testNumber="8"/>
			<description>Entry Next in ActionThread shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionThread has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-S" testNumber="8"/>
			<description>Entry S in ActionThread shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionThread has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-S" testNumber="7"/>
			<description>Entry S in ActionThread is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionThread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionThread shall have value Thread</description>
			<test>SHasTypeName != true || SNameValue == "Thread"</test>
			<error>
				<message>Entry S with type Name in ActionThread has incorrect value %1 instead of Thread</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-Type" testNumber="8"/>
			<description>Entry Type in ActionThread shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionThread has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_2" clause="ActionThread-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionThread shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionThread has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI" testNumber="1"/>
			<description>ActionURI shall not contain entries except Type, S, Next, IsMap, URI</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'IsMap' &amp;&amp; elem != 'URI' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionURI contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'IsMap' &amp;&amp; elem != 'URI' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-IsMap" testNumber="8"/>
			<description>Entry IsMap in ActionURI shall have type Boolean</description>
			<test>containsIsMap == false || IsMapHasTypeBoolean == true</test>
			<error>
				<message>Entry IsMap in ActionURI has type %1 instead of type Boolean</message>
				<arguments>
					<argument>IsMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionURI shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionNOP, ActionSetState, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionURI is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionNOP, ActionSetState, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-Next" testNumber="8"/>
			<description>Entry Next in ActionURI shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionURI has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-S" testNumber="8"/>
			<description>Entry S in ActionURI shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionURI has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-S" testNumber="7"/>
			<description>Entry S in ActionURI is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionURI is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionURI shall have value URI</description>
			<test>SHasTypeName != true || SNameValue == "URI"</test>
			<error>
				<message>Entry S with type Name in ActionURI has incorrect value %1 instead of URI</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-Type" testNumber="8"/>
			<description>Entry Type in ActionURI shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionURI has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionURI shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionURI has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-URI" testNumber="8"/>
			<description>Entry URI in ActionURI shall have type StringAscii</description>
			<test>containsURI == false || URIHasTypeStringAscii == true</test>
			<error>
				<message>Entry URI in ActionURI has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>URIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_2" clause="ActionURI-URI" testNumber="7"/>
			<description>Entry URI in ActionURI is required</description>
			<test>containsURI == true</test>
			<error>
				<message>Entry URI in ActionURI is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_2" clause="AddActionPageObject" testNumber="1"/>
			<description>AddActionPageObject shall not contain entries except C, O</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionPageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_2" clause="AddActionPageObject-C-Dictionary" testNumber="17"/>
			<description>Entry C with type Dictionary in AddActionPageObject shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>CHasTypeDictionary != true || C_size == 1</test>
			<error>
				<message>Entry C with type Dictionary in AddActionPageObject is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_2" clause="AddActionPageObject-C" testNumber="8"/>
			<description>Entry C in AddActionPageObject shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in AddActionPageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_2" clause="AddActionPageObject-O-Dictionary" testNumber="17"/>
			<description>Entry O with type Dictionary in AddActionPageObject shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>OHasTypeDictionary != true || O_size == 1</test>
			<error>
				<message>Entry O with type Dictionary in AddActionPageObject is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_2" clause="AddActionPageObject-O" testNumber="8"/>
			<description>Entry O in AddActionPageObject shall have type Dictionary</description>
			<test>containsO == false || OHasTypeDictionary == true</test>
			<error>
				<message>Entry O in AddActionPageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation" testNumber="1"/>
			<description>AddActionWidgetAnnotation shall not contain entries except D, E, U, X, Fo, Bl</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'PC' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'U' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'X' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'Bl' &amp;&amp; elem != 'PO' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionWidgetAnnotation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'PC' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'U' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'X' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'Bl' &amp;&amp; elem != 'PO' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation" testNumber="22"/>
			<description>AddActionWidgetAnnotation shall not contain entries PC, PV, PI, PO in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PV' || elem == 'PI' || elem == 'PO').length == 0</test>
			<error>
				<message>AddActionWidgetAnnotation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PV' || elem == 'PI' || elem == 'PO').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-Bl-Dictionary" testNumber="17"/>
			<description>Entry Bl with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>BlHasTypeDictionary != true || Bl_size == 1</test>
			<error>
				<message>Entry Bl with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-Bl" testNumber="8"/>
			<description>Entry Bl in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsBl == false || BlHasTypeDictionary == true</test>
			<error>
				<message>Entry Bl in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BlType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-D-Dictionary" testNumber="17"/>
			<description>Entry D with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>DHasTypeDictionary != true || D_size == 1</test>
			<error>
				<message>Entry D with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-D" testNumber="8"/>
			<description>Entry D in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsD == false || DHasTypeDictionary == true</test>
			<error>
				<message>Entry D in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-E-Dictionary" testNumber="17"/>
			<description>Entry E with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>EHasTypeDictionary != true || E_size == 1</test>
			<error>
				<message>Entry E with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-E" testNumber="8"/>
			<description>Entry E in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsE == false || EHasTypeDictionary == true</test>
			<error>
				<message>Entry E in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-Fo-Dictionary" testNumber="17"/>
			<description>Entry Fo with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>FoHasTypeDictionary != true || Fo_size == 1</test>
			<error>
				<message>Entry Fo with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-Fo" testNumber="8"/>
			<description>Entry Fo in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsFo == false || FoHasTypeDictionary == true</test>
			<error>
				<message>Entry Fo in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-U-Dictionary" testNumber="17"/>
			<description>Entry U with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>UHasTypeDictionary != true || U_size == 1</test>
			<error>
				<message>Entry U with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-U" testNumber="8"/>
			<description>Entry U in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsU == false || UHasTypeDictionary == true</test>
			<error>
				<message>Entry U in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-X-Dictionary" testNumber="17"/>
			<description>Entry X with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>XHasTypeDictionary != true || X_size == 1</test>
			<error>
				<message>Entry X with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_2" clause="AddActionWidgetAnnotation-X" testNumber="8"/>
			<description>Entry X in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsX == false || XHasTypeDictionary == true</test>
			<error>
				<message>Entry X in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>XType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink" testNumber="1"/>
			<description>AnnotLink shall not contain entries except A, C, F, H, M, BS, Dest, Rect, AP, AS, Type, Contents, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'PA' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'QuadPoints' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotLink contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'PA' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'QuadPoints' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink" testNumber="22"/>
			<description>AnnotLink shall not contain entries BM, P, OC, StructParent, CA, ca, Path, AF, Lang, PA, NM, QuadPoints in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'Path' || elem == 'AF' || elem == 'Lang' || elem == 'PA' || elem == 'NM' || elem == 'QuadPoints').length == 0</test>
			<error>
				<message>AnnotLink contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'Path' || elem == 'AF' || elem == 'Lang' || elem == 'PA' || elem == 'NM' || elem == 'QuadPoints').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotLink shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotLink is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-A" testNumber="8"/>
			<description>Entry A in AnnotLink shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-AP" testNumber="8"/>
			<description>Entry AP in AnnotLink shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-AS" testNumber="8"/>
			<description>Entry AS in AnnotLink shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-AS" testNumber="11"/>
			<description>Entry AS in AnnotLink is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-BS" testNumber="8"/>
			<description>Entry BS in AnnotLink shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Border" testNumber="8"/>
			<description>Entry Border in AnnotLink shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotLink has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-C" testNumber="8"/>
			<description>Entry C in AnnotLink shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotLink has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotLink shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotLink has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Dest-Array" testNumber="17"/>
			<description>Entry Dest with type Array in AnnotLink shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DestHasTypeArray != true || Dest_size == 1</test>
			<error>
				<message>Entry Dest with type Array in AnnotLink is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Dest" testNumber="8"/>
			<description>Entry Dest in AnnotLink shall have one of types: Array, Name, StringByte</description>
			<test>containsDest == false || DestHasTypeArray == true || DestHasTypeName == true || DestHasTypeStringByte == true</test>
			<error>
				<message>Entry Dest in AnnotLink has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DestType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-F" testNumber="8"/>
			<description>Entry F in AnnotLink shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotLink has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotLink shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotLink does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-H" testNumber="8"/>
			<description>Entry H in AnnotLink shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotLink shall have one of values: P, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P"</test>
			<error>
				<message>Entry H with type Name in AnnotLink has incorrect value %1 instead of P, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-M" testNumber="8"/>
			<description>Entry M in AnnotLink shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotLink has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotLink shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotLink has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotLink is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotLink shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotLink is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotLink shall have value Link</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Link"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotLink has incorrect value %1 instead of Link</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Type" testNumber="8"/>
			<description>Entry Type in AnnotLink shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_2" clause="AnnotLink-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotLink shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotLink has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie" testNumber="1"/>
			<description>AnnotMovie shall not contain entries except A, Movie, Rect, C, F, M, AP, AS, Type, Contents, T, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'Movie' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'C' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'P' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'Movie' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'C' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'P' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie" testNumber="22"/>
			<description>AnnotMovie shall not contain entries AF, Lang, BM, P, OC, StructParent, CA, ca, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Lang' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Lang' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-A" testNumber="8"/>
			<description>Entry A in AnnotMovie shall have one of types: Boolean, Dictionary</description>
			<test>containsA == false || AHasTypeBoolean == true || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotMovie has type %1 instead of one of types: Boolean, Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-AP" testNumber="8"/>
			<description>Entry AP in AnnotMovie shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-AS" testNumber="8"/>
			<description>Entry AS in AnnotMovie shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-AS" testNumber="11"/>
			<description>Entry AS in AnnotMovie is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Border" testNumber="8"/>
			<description>Entry Border in AnnotMovie shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotMovie has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-C" testNumber="8"/>
			<description>Entry C in AnnotMovie shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotMovie has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotMovie shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotMovie has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-F" testNumber="8"/>
			<description>Entry F in AnnotMovie shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotMovie has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotMovie shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotMovie does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-M" testNumber="8"/>
			<description>Entry M in AnnotMovie shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotMovie has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Movie" testNumber="8"/>
			<description>Entry Movie in AnnotMovie shall have type Dictionary</description>
			<test>containsMovie == false || MovieHasTypeDictionary == true</test>
			<error>
				<message>Entry Movie in AnnotMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MovieType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Movie" testNumber="7"/>
			<description>Entry Movie in AnnotMovie is required</description>
			<test>containsMovie == true</test>
			<error>
				<message>Entry Movie in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotMovie shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotMovie has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotMovie is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotMovie shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotMovie is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotMovie shall have value Movie</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Movie"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotMovie has incorrect value %1 instead of Movie</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-T" testNumber="8"/>
			<description>Entry T in AnnotMovie shall have type String</description>
			<test>containsT == false || THasTypeString == true</test>
			<error>
				<message>Entry T in AnnotMovie has type %1 instead of type String</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Type" testNumber="8"/>
			<description>Entry Type in AnnotMovie shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_2" clause="AnnotMovie-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotMovie shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotMovie has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound" testNumber="1"/>
			<description>AnnotSound shall not contain entries except C, F, M, Name, T, Rect, Sound, AP, AS, Type, Contents, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CreationDate' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'P' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CreationDate' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'P' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound" testNumber="22"/>
			<description>AnnotSound shall not contain entries CreationDate, RT, IRT, BM, P, OC, StructParent, Popup, CA, ca, ExData, AF, Lang, IT, Subj, RC, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'CreationDate' || elem == 'RT' || elem == 'IRT' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'Popup' || elem == 'CA' || elem == 'ca' || elem == 'ExData' || elem == 'AF' || elem == 'Lang' || elem == 'IT' || elem == 'Subj' || elem == 'RC' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'CreationDate' || elem == 'RT' || elem == 'IRT' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'Popup' || elem == 'CA' || elem == 'ca' || elem == 'ExData' || elem == 'AF' || elem == 'Lang' || elem == 'IT' || elem == 'Subj' || elem == 'RC' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-AP" testNumber="8"/>
			<description>Entry AP in AnnotSound shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotSound has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-AS" testNumber="8"/>
			<description>Entry AS in AnnotSound shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-AS" testNumber="11"/>
			<description>Entry AS in AnnotSound is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Border" testNumber="8"/>
			<description>Entry Border in AnnotSound shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotSound has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-C" testNumber="8"/>
			<description>Entry C in AnnotSound shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotSound has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotSound shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotSound has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-F" testNumber="8"/>
			<description>Entry F in AnnotSound shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotSound has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotSound shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotSound does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-M" testNumber="8"/>
			<description>Entry M in AnnotSound shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotSound has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Name" testNumber="8"/>
			<description>Entry Name in AnnotSound shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotSound shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotSound has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotSound is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Sound" testNumber="8"/>
			<description>Entry Sound in AnnotSound shall have type Stream</description>
			<test>containsSound == false || SoundHasTypeStream == true</test>
			<error>
				<message>Entry Sound in AnnotSound has type %1 instead of type Stream</message>
				<arguments>
					<argument>SoundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Sound" testNumber="7"/>
			<description>Entry Sound in AnnotSound is required</description>
			<test>containsSound == true</test>
			<error>
				<message>Entry Sound in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Sound-Stream" testNumber="10"/>
			<description>Entry Sound with type Stream in AnnotSound shall be indirect</description>
			<test>SoundHasTypeStream != true || isSoundIndirect == true</test>
			<error>
				<message>Entry Sound with type Stream in AnnotSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotSound shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotSound is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotSound shall have value Sound</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Sound"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotSound has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-T" testNumber="8"/>
			<description>Entry T in AnnotSound shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotSound has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Type" testNumber="8"/>
			<description>Entry Type in AnnotSound shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_2" clause="AnnotSound-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotSound shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotSound has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText" testNumber="1"/>
			<description>AnnotText shall not contain entries except C, F, M, Name, Open, T, Rect, AP, AS, Type, Contents, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CreationDate' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'State' &amp;&amp; elem != 'StateModel' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CreationDate' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'State' &amp;&amp; elem != 'StateModel' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText" testNumber="22"/>
			<description>AnnotText shall not contain entries CreationDate, RT, IRT, BM, P, OC, StructParent, Popup, CA, ca, ExData, AF, Lang, IT, Subj, RC, State, StateModel, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'CreationDate' || elem == 'RT' || elem == 'IRT' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'Popup' || elem == 'CA' || elem == 'ca' || elem == 'ExData' || elem == 'AF' || elem == 'Lang' || elem == 'IT' || elem == 'Subj' || elem == 'RC' || elem == 'State' || elem == 'StateModel' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'CreationDate' || elem == 'RT' || elem == 'IRT' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'Popup' || elem == 'CA' || elem == 'ca' || elem == 'ExData' || elem == 'AF' || elem == 'Lang' || elem == 'IT' || elem == 'Subj' || elem == 'RC' || elem == 'State' || elem == 'StateModel' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-AP" testNumber="8"/>
			<description>Entry AP in AnnotText shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-AS" testNumber="8"/>
			<description>Entry AS in AnnotText shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-AS" testNumber="11"/>
			<description>Entry AS in AnnotText is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Border" testNumber="8"/>
			<description>Entry Border in AnnotText shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotText has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-C" testNumber="8"/>
			<description>Entry C in AnnotText shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotText has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotText shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotText has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-F" testNumber="8"/>
			<description>Entry F in AnnotText shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotText has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotText shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotText does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-M" testNumber="8"/>
			<description>Entry M in AnnotText shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotText has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Name" testNumber="8"/>
			<description>Entry Name in AnnotText shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Name-Name" testNumber="6"/>
			<description>Entry Name with type Name in AnnotText shall have one of values: Comment, Help, Note, Insert, Key, NewParagraph, Paragraph</description>
			<test>NameHasTypeName != true || NameNameValue == "Comment" || NameNameValue == "Key" || NameNameValue == "Note" || NameNameValue == "Help" || NameNameValue == "NewParagraph" || NameNameValue == "Paragraph" || NameNameValue == "Insert"</test>
			<error>
				<message>Entry Name with type Name in AnnotText has incorrect value %1 instead of Comment, Help, Note, Insert, Key, NewParagraph, Paragraph</message>
				<arguments>
					<argument>NameNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Open" testNumber="8"/>
			<description>Entry Open in AnnotText shall have type Boolean</description>
			<test>containsOpen == false || OpenHasTypeBoolean == true</test>
			<error>
				<message>Entry Open in AnnotText has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OpenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotText shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotText has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotText is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotText shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotText is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotText shall have value Text</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Text"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotText has incorrect value %1 instead of Text</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-T" testNumber="8"/>
			<description>Entry T in AnnotText shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotText has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Type" testNumber="8"/>
			<description>Entry Type in AnnotText shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_2" clause="AnnotText-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotText shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotText has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget" testNumber="1"/>
			<description>AnnotWidget shall not contain entries except A, C, Parent, F, H, M, BS, T, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidget contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget" testNumber="22"/>
			<description>AnnotWidget shall not contain entries TU, BM, P, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidget contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidget shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidget is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-A" testNumber="8"/>
			<description>Entry A in AnnotWidget shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidget shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidget shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidget shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidget is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidget shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidget shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-C" testNumber="8"/>
			<description>Entry C in AnnotWidget shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidget shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-F" testNumber="8"/>
			<description>Entry F in AnnotWidget shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidget has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidget shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidget does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidget shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidget has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-H" testNumber="8"/>
			<description>Entry H in AnnotWidget shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidget shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidget has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidget shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-M" testNumber="8"/>
			<description>Entry M in AnnotWidget shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidget has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidget shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidget shall be one of objects Field, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidget is not one of objects Field, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidget shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidget shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidget has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidget is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidget shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidget is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidget shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidget has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-T" testNumber="8"/>
			<description>Entry T in AnnotWidget shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidget shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_2" clause="AnnotWidget-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidget shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidget has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField" testNumber="1"/>
			<description>AnnotWidgetField shall not contain entries except A, C, Parent, F, H, M, BS, T, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField" testNumber="22"/>
			<description>AnnotWidgetField shall not contain entries TU, BM, P, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'BM' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetField shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetField shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetField shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetField shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetField is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetField shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetField shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetField has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetField shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetField has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetField shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetField shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetField has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetField shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetField does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetField shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetField has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetField shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetField does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetField shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetField shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetField has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetField shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetField has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetField shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetField has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetField shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetField shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetField is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetField shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetField shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetField has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetField is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetField shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetField is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetField shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetField has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetField shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetField shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_2" clause="AnnotWidgetField-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetField shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetField has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox" testNumber="1"/>
			<description>AnnotWidgetFieldBtnCheckbox shall not contain entries except A, C, Parent, F, H, M, FT, BS, Q, DV, T, V, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, DA, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox" testNumber="22"/>
			<description>AnnotWidgetFieldBtnCheckbox shall not contain entries TU, RV, BM, DS, P, Opt, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'Opt' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'Opt' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnCheckbox shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnCheckbox is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnCheckbox is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnCheckbox shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnCheckbox shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnCheckbox shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnCheckbox shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnCheckbox shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnCheckbox shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnCheckbox has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnCheckbox shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnCheckbox is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnCheckbox shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnCheckbox shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnCheckbox shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnCheckbox shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnCheckbox shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnCheckbox-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush" testNumber="1"/>
			<description>AnnotWidgetFieldBtnPush shall not contain entries except A, C, Parent, F, H, M, FT, BS, Q, DV, T, V, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, DA, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush" testNumber="22"/>
			<description>AnnotWidgetFieldBtnPush shall not contain entries TU, RV, BM, DS, P, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnPush shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnPush is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnPush is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnPush shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnPush shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnPush shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnPush has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnPush is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnPush shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnPush is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnPush shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnPush shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnPush shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetFieldBtnPush shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetFieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnPush shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnPush has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnPush shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnPush is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnPush shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnPush has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnPush shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnPush has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnPush shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnPush has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnPush is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnPush is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnPush shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnPush shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnPush-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio" testNumber="1"/>
			<description>AnnotWidgetFieldBtnRadio shall not contain entries except A, C, Parent, F, H, M, FT, BS, Q, DV, T, V, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, DA, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio" testNumber="22"/>
			<description>AnnotWidgetFieldBtnRadio shall not contain entries TU, RV, BM, DS, P, Opt, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'Opt' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'Opt' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnRadio shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnRadio is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnRadio is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnRadio shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnRadio has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnRadio shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnRadio shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnRadio shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnRadio shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnRadio shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnRadio has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnRadio shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnRadio is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnRadio shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnRadio has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnRadio shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnRadio shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnRadio has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnRadio shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnRadio shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldBtnRadio-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice" testNumber="1"/>
			<description>AnnotWidgetFieldChoice shall not contain entries except A, C, Parent, F, H, M, FT, BS, Q, DV, Opt, T, V, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, TI, Border, DA, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'I' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'I' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice" testNumber="22"/>
			<description>AnnotWidgetFieldChoice shall not contain entries TU, RV, I, BM, DS, P, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'I' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetFieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'I' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldChoice shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldChoice is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldChoice is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldChoice shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldChoice has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldChoice is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldChoice shall have one of types: Array, StringText</description>
			<test>containsDV == false || DVHasTypeArray == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldChoice shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldChoice is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldChoice shall have value Ch</description>
			<test>FTHasTypeName != true || FTNameValue == "Ch"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Ch</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldChoice shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(22, 23) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(22, 23) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldChoice shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldChoice shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldChoice has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Opt" testNumber="8"/>
			<description>Entry Opt in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldChoice shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldChoice is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldChoice shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldChoice shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldChoice has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldChoice shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldChoice has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldChoice is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldChoice is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldChoice shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-TI" testNumber="8"/>
			<description>Entry TI in AnnotWidgetFieldChoice shall have type Integer</description>
			<test>containsTI == false || TIHasTypeInteger == true</test>
			<error>
				<message>Entry TI in AnnotWidgetFieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>TIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-TI-Integer" testNumber="14"/>
			<description>Entry TI with type Integer in AnnotWidgetFieldChoice shall satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</description>
			<test>TIHasTypeInteger != true || (TIIntegerValue &gt;= 0) &amp;&amp; (OptHasTypeArray == false || (TIIntegerValue &lt; OptArraySize))</test>
			<error>
				<message>Entry TI with type Integer in AnnotWidgetFieldChoice does not satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldChoice shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldChoice-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldChoice shall have one of types: Array, StringText</description>
			<test>containsV == false || VHasTypeArray == true || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx" testNumber="1"/>
			<description>AnnotWidgetFieldTx shall not contain entries except A, MaxLen, C, Parent, F, H, M, FT, BS, Q, DV, T, V, MK, AA, Ff, Rect, Kids, AP, AS, Type, Contents, Border, DA, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'C' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'M' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'NM' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx" testNumber="22"/>
			<description>AnnotWidgetFieldTx shall not contain entries TU, RV, BM, DS, P, OC, StructParent, CA, ca, AF, PMD, Lang, TM, NM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').length == 0</test>
			<error>
				<message>AnnotWidgetFieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'TU' || elem == 'RV' || elem == 'BM' || elem == 'DS' || elem == 'P' || elem == 'OC' || elem == 'StructParent' || elem == 'CA' || elem == 'ca' || elem == 'AF' || elem == 'PMD' || elem == 'Lang' || elem == 'TM' || elem == 'NM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldTx shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldTx is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldTx is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldTx shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldTx shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldTx shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldTx has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldTx is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldTx shall have one of types: Stream, StringText</description>
			<test>containsDV == false || DVHasTypeStream == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldTx has type %1 instead of one of types: Stream, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-DV-Stream" testNumber="10"/>
			<description>Entry DV with type Stream in AnnotWidgetFieldTx shall be indirect</description>
			<test>DVHasTypeStream != true || isDVIndirect == true</test>
			<error>
				<message>Entry DV with type Stream in AnnotWidgetFieldTx is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldTx shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldTx is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldTx shall have value Tx</description>
			<test>FTHasTypeName != true || FTNameValue == "Tx"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Tx</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldTx shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(23, 24) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(23, 24) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldTx shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidgetFieldTx shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidgetFieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldTx shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldTx has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-MaxLen" testNumber="8"/>
			<description>Entry MaxLen in AnnotWidgetFieldTx shall have type Integer</description>
			<test>containsMaxLen == false || MaxLenHasTypeInteger == true</test>
			<error>
				<message>Entry MaxLen in AnnotWidgetFieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>MaxLenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-MaxLen-Integer" testNumber="9"/>
			<description>Entry MaxLen with type Integer in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(@MaxLen &gt;= 0)</description>
			<test>MaxLenHasTypeInteger != true || (MaxLenIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry MaxLen with type Integer in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(@MaxLen &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldTx shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldTx is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldTx shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldTx shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldTx has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldTx shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldTx has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldTx is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldTx is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldTx shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldTx shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_2" clause="AnnotWidgetFieldTx-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsV == false || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance" testNumber="1"/>
			<description>Appearance shall not contain entries except R, D, N</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'R' &amp;&amp; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Appearance contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'R' &amp;&amp; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-D-Stream" testNumber="17"/>
			<description>Entry D with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>DHasTypeStream != true || D_size == 1</test>
			<error>
				<message>Entry D with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-D" testNumber="8"/>
			<description>Entry D in Appearance shall have type Stream</description>
			<test>containsD == false || DHasTypeStream == true</test>
			<error>
				<message>Entry D in Appearance has type %1 instead of type Stream</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-D-Stream" testNumber="10"/>
			<description>Entry D with type Stream in Appearance shall be indirect</description>
			<test>DHasTypeStream != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-N-Stream" testNumber="17"/>
			<description>Entry N with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>NHasTypeStream != true || N_size == 1</test>
			<error>
				<message>Entry N with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-N" testNumber="8"/>
			<description>Entry N in Appearance shall have type Stream</description>
			<test>containsN == false || NHasTypeStream == true</test>
			<error>
				<message>Entry N in Appearance has type %1 instead of type Stream</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-N" testNumber="7"/>
			<description>Entry N in Appearance is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in Appearance is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-N-Stream" testNumber="10"/>
			<description>Entry N with type Stream in Appearance shall be indirect</description>
			<test>NHasTypeStream != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-R-Stream" testNumber="17"/>
			<description>Entry R with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>RHasTypeStream != true || R_size == 1</test>
			<error>
				<message>Entry R with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-R" testNumber="8"/>
			<description>Entry R in Appearance shall have type Stream</description>
			<test>containsR == false || RHasTypeStream == true</test>
			<error>
				<message>Entry R in Appearance has type %1 instead of type Stream</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_2" clause="Appearance-R-Stream" testNumber="10"/>
			<description>Entry R with type Stream in Appearance shall be indirect</description>
			<test>RHasTypeStream != true || isRIndirect == true</test>
			<error>
				<message>Entry R with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics" testNumber="1"/>
			<description>AppearanceCharacteristics shall not contain entries except BC, RC, AC, R, BG, RI, I, TP, CA, IX</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AC' &amp;&amp; elem != 'R' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'I' &amp;&amp; elem != 'TP' &amp;&amp; elem != 'IF' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'IX' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AppearanceCharacteristics contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'AC' &amp;&amp; elem != 'R' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'I' &amp;&amp; elem != 'TP' &amp;&amp; elem != 'IF' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'IX' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics" testNumber="22"/>
			<description>AppearanceCharacteristics shall not contain entry IF in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'IF').length == 0</test>
			<error>
				<message>AppearanceCharacteristics contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'IF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-AC" testNumber="8"/>
			<description>Entry AC in AppearanceCharacteristics shall have type StringText</description>
			<test>containsAC == false || ACHasTypeStringText == true</test>
			<error>
				<message>Entry AC in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>ACType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-BC" testNumber="8"/>
			<description>Entry BC in AppearanceCharacteristics shall have type Array</description>
			<test>containsBC == false || BCHasTypeArray == true</test>
			<error>
				<message>Entry BC in AppearanceCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>BCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-BG" testNumber="8"/>
			<description>Entry BG in AppearanceCharacteristics shall have type Array</description>
			<test>containsBG == false || BGHasTypeArray == true</test>
			<error>
				<message>Entry BG in AppearanceCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>BGType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-CA" testNumber="8"/>
			<description>Entry CA in AppearanceCharacteristics shall have type StringText</description>
			<test>containsCA == false || CAHasTypeStringText == true</test>
			<error>
				<message>Entry CA in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-I-Stream" testNumber="17"/>
			<description>Entry I with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>IHasTypeStream != true || I_size == 1</test>
			<error>
				<message>Entry I with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-I" testNumber="8"/>
			<description>Entry I in AppearanceCharacteristics shall have type Stream</description>
			<test>containsI == false || IHasTypeStream == true</test>
			<error>
				<message>Entry I in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-I-Stream" testNumber="10"/>
			<description>Entry I with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>IHasTypeStream != true || isIIndirect == true</test>
			<error>
				<message>Entry I with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-IX-Stream" testNumber="17"/>
			<description>Entry IX with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>IXHasTypeStream != true || IX_size == 1</test>
			<error>
				<message>Entry IX with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-IX" testNumber="8"/>
			<description>Entry IX in AppearanceCharacteristics shall have type Stream</description>
			<test>containsIX == false || IXHasTypeStream == true</test>
			<error>
				<message>Entry IX in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>IXType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-IX-Stream" testNumber="10"/>
			<description>Entry IX with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>IXHasTypeStream != true || isIXIndirect == true</test>
			<error>
				<message>Entry IX with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-R" testNumber="8"/>
			<description>Entry R in AppearanceCharacteristics shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in AppearanceCharacteristics has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-RC" testNumber="8"/>
			<description>Entry RC in AppearanceCharacteristics shall have type StringText</description>
			<test>containsRC == false || RCHasTypeStringText == true</test>
			<error>
				<message>Entry RC in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>RCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-RI-Stream" testNumber="17"/>
			<description>Entry RI with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>RIHasTypeStream != true || RI_size == 1</test>
			<error>
				<message>Entry RI with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-RI" testNumber="8"/>
			<description>Entry RI in AppearanceCharacteristics shall have type Stream</description>
			<test>containsRI == false || RIHasTypeStream == true</test>
			<error>
				<message>Entry RI in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>RIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-RI-Stream" testNumber="10"/>
			<description>Entry RI with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>RIHasTypeStream != true || isRIIndirect == true</test>
			<error>
				<message>Entry RI with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-TP" testNumber="8"/>
			<description>Entry TP in AppearanceCharacteristics shall have type Integer</description>
			<test>containsTP == false || TPHasTypeInteger == true</test>
			<error>
				<message>Entry TP in AppearanceCharacteristics has type %1 instead of type Integer</message>
				<arguments>
					<argument>TPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_2" clause="AppearanceCharacteristics-TP-Integer" testNumber="6"/>
			<description>Entry TP with type Integer in AppearanceCharacteristics shall have one of values: 0, 1, 2, 3, 4, 5, 6</description>
			<test>TPHasTypeInteger != true || TPIntegerValue == 0 || TPIntegerValue == 1 || TPIntegerValue == 2 || TPIntegerValue == 3 || TPIntegerValue == 4 || TPIntegerValue == 5 || TPIntegerValue == 6</test>
			<error>
				<message>Entry TP with type Integer in AppearanceCharacteristics has incorrect value %1 instead of 0, 1, 2, 3, 4, 5, 6</message>
				<arguments>
					<argument>TPIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions" testNumber="2"/>
			<description>ArrayOf4Functions shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf4Functions contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf4Functions shall have type Stream</description>
			<test>size &lt;= 0 || entry0HasTypeStream == true</test>
			<error>
				<message>Entry 0 in ArrayOf4Functions has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-0-Stream" testNumber="10"/>
			<description>Entry 0 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry0HasTypeStream != true || isentry0Indirect == true</test>
			<error>
				<message>Entry 0 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf4Functions shall have type Stream</description>
			<test>size &lt;= 1 || entry1HasTypeStream == true</test>
			<error>
				<message>Entry 1 in ArrayOf4Functions has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-1-Stream" testNumber="10"/>
			<description>Entry 1 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry1HasTypeStream != true || isentry1Indirect == true</test>
			<error>
				<message>Entry 1 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf4Functions shall have type Stream</description>
			<test>size &lt;= 2 || entry2HasTypeStream == true</test>
			<error>
				<message>Entry 2 in ArrayOf4Functions has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-2-Stream" testNumber="10"/>
			<description>Entry 2 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry2HasTypeStream != true || isentry2Indirect == true</test>
			<error>
				<message>Entry 2 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf4Functions shall have type Stream</description>
			<test>size &lt;= 3 || entry3HasTypeStream == true</test>
			<error>
				<message>Entry 3 in ArrayOf4Functions has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_2" clause="ArrayOf4Functions-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionHideAnnotsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfActionHideAnnots shall be one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActionHideAnnots is not one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionHideAnnotsEntry" testNumber="8"/>
			<description>Entry in ArrayOfActionHideAnnots shall have one of types: Dictionary, StringText</description>
			<test>HasTypeDictionary == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfActionHideAnnots has type %1 instead of one of types: Dictionary, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionHideAnnotsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfActionHideAnnots shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActionHideAnnots is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionHideAnnotsEntry-StringText" testNumber="9"/>
			<description>Entry with type StringText in ArrayOfActionHideAnnots shall satisfy special case: fn:Eval(fn:IsFieldName(@*))</description>
			<test>HasTypeStringText != true || (IsFieldName == true)</test>
			<error>
				<message>Entry %keyName% with type StringText in ArrayOfActionHideAnnots does not satisfy special case: fn:Eval(fn:IsFieldName(@*))</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfActions shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActions is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionsEntry">
			<id specification="PDF_1_2" clause="ArrayOfActionsEntry" testNumber="8"/>
			<description>Entry in ArrayOfActions shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfActions has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfAnnotsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfAnnots shall be one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfAnnots is not one of objects AnnotText, AnnotLink, AnnotSound, AnnotMovie, AnnotWidget, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAnnotsEntry">
			<id specification="PDF_1_2" clause="ArrayOfAnnotsEntry" testNumber="8"/>
			<description>Entry in ArrayOfAnnots shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfAnnots has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_2" clause="ArrayOfBeadsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfBeads shall be one of objects BeadFirst, Bead</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfBeads is not one of objects BeadFirst, Bead</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_2" clause="ArrayOfBeadsEntry" testNumber="8"/>
			<description>Entry in ArrayOfBeads shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfBeads has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_2" clause="ArrayOfBeadsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfBeads shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfBeads is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsW2Entry">
			<id specification="PDF_1_2" clause="ArrayOfCIDGlyphMetricsW2Entry" testNumber="8"/>
			<description>Entry in ArrayOfCIDGlyphMetricsW2 shall have one of types: Array, Integer, Number</description>
			<test>HasTypeArray == true || HasTypeInteger == true || HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCIDGlyphMetricsW2 has type %1 instead of one of types: Array, Integer, Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsW2Entry">
			<id specification="PDF_1_2" clause="ArrayOfCIDGlyphMetricsW2Entry-Array" testNumber="9"/>
			<description>Entry with type Array in ArrayOfCIDGlyphMetricsW2 shall satisfy special case: fn:Eval((fn:ArrayLength(*) mod 3) == 0)</description>
			<test>HasTypeArray != true || ((ArraySize % 3) == 0)</test>
			<error>
				<message>Entry %keyName% with type Array in ArrayOfCIDGlyphMetricsW2 does not satisfy special case: fn:Eval((fn:ArrayLength(*) mod 3) == 0)</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsWEntry">
			<id specification="PDF_1_2" clause="ArrayOfCIDGlyphMetricsWEntry" testNumber="8"/>
			<description>Entry in ArrayOfCIDGlyphMetricsW shall have one of types: Array, Integer, Number</description>
			<test>HasTypeArray == true || HasTypeInteger == true || HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCIDGlyphMetricsW has type %1 instead of one of types: Array, Integer, Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCompressionFilterNamesEntry">
			<id specification="PDF_1_2" clause="ArrayOfCompressionFilterNamesEntry" testNumber="8"/>
			<description>Entry in ArrayOfCompressionFilterNames shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCompressionFilterNames has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCompressionFilterNamesEntry">
			<id specification="PDF_1_2" clause="ArrayOfCompressionFilterNamesEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfCompressionFilterNames shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>HasTypeName != true || NameValue == "ASCIIHexDecode" || NameValue == "ASCII85Decode" || NameValue == "LZWDecode" || NameValue == "FlateDecode" || NameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfCompressionFilterNames has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDashPatternsEntry">
			<id specification="PDF_1_2" clause="ArrayOfDashPatternsEntry" testNumber="8"/>
			<description>Entry in ArrayOfDashPatterns shall have type Number</description>
			<test>HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDashPatterns has type %1 instead of type Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDecodeParamsEntry">
			<id specification="PDF_1_2" clause="ArrayOfDecodeParamsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfDecodeParams shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfDecodeParams is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDecodeParamsEntry">
			<id specification="PDF_1_2" clause="ArrayOfDecodeParamsEntry" testNumber="8"/>
			<description>Entry in ArrayOfDecodeParams shall have one of types: Dictionary, Null</description>
			<test>HasTypeDictionary == true || HasTypeNull == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDecodeParams has type %1 instead of one of types: Dictionary, Null</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_2" clause="ArrayOfDescendantFonts" testNumber="2"/>
			<description>ArrayOfDescendantFonts shall contain exactly 1 element</description>
			<test>size == 1</test>
			<error>
				<message>ArrayOfDescendantFonts contains %1 element(s) instead of 1</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_2" clause="ArrayOfDescendantFonts-0-Dictionary" testNumber="17"/>
			<description>Entry 0 with type Dictionary in ArrayOfDescendantFonts shall be one of objects FontCIDType0, FontCIDType2</description>
			<test>entry0HasTypeDictionary != true || entry0_size == 1</test>
			<error>
				<message>Entry 0 with type Dictionary in ArrayOfDescendantFonts is not one of objects FontCIDType0, FontCIDType2</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_2" clause="ArrayOfDescendantFonts-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfDescendantFonts shall have type Dictionary</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true</test>
			<error>
				<message>Entry 0 in ArrayOfDescendantFonts has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDifferencesEntry">
			<id specification="PDF_1_2" clause="ArrayOfDifferencesEntry" testNumber="8"/>
			<description>Entry in ArrayOfDifferences shall have one of types: Integer, Name</description>
			<test>HasTypeInteger == true || HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDifferences has type %1 instead of one of types: Integer, Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration" testNumber="2"/>
			<description>ArrayOfDuration shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfDuration contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfDuration shall have one of types: Integer, StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in ArrayOfDuration has type %1 instead of one of types: Integer, StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration-0-Integer" testNumber="14"/>
			<description>Entry 0 with type Integer in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(@0 &gt; 0)</description>
			<test>entry0HasTypeInteger != true || entry0IntegerValue &gt; 0</test>
			<error>
				<message>Entry 0 with type Integer in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(@0 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration-0-StringByte" testNumber="14"/>
			<description>Entry 0 with type StringByte in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(fn:StringLength(0) == 8)</description>
			<test>entry0HasTypeStringByte != true || entry0StringSize == 8</test>
			<error>
				<message>Entry 0 with type StringByte in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(fn:StringLength(0) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfDuration shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOfDuration has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_2" clause="ArrayOfDuration-1-Integer" testNumber="14"/>
			<description>Entry 1 with type Integer in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(@1 &gt; 0)</description>
			<test>entry1HasTypeInteger != true || entry1IntegerValue &gt; 0</test>
			<error>
				<message>Entry 1 with type Integer in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(@1 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldChoiceOptEntry">
			<id specification="PDF_1_2" clause="ArrayOfFieldChoiceOptEntry" testNumber="8"/>
			<description>Entry in ArrayOfFieldChoiceOpt shall have one of types: Array, StringText</description>
			<test>HasTypeArray == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFieldChoiceOpt has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldIDEntry">
			<id specification="PDF_1_2" clause="ArrayOfFieldIDEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFieldID shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFieldID is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldIDEntry">
			<id specification="PDF_1_2" clause="ArrayOfFieldIDEntry" testNumber="8"/>
			<description>Entry in ArrayOfFieldID shall have one of types: Dictionary, StringText</description>
			<test>HasTypeDictionary == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFieldID has type %1 instead of one of types: Dictionary, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldsEntry">
			<id specification="PDF_1_2" clause="ArrayOfFieldsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFields shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidget, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFields is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidget, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldsEntry">
			<id specification="PDF_1_2" clause="ArrayOfFieldsEntry" testNumber="8"/>
			<description>Entry in ArrayOfFields shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFields has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFilterNamesEntry">
			<id specification="PDF_1_2" clause="ArrayOfFilterNamesEntry" testNumber="8"/>
			<description>Entry in ArrayOfFilterNames shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFilterNames has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFilterNamesEntry">
			<id specification="PDF_1_2" clause="ArrayOfFilterNamesEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfFilterNames shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>HasTypeName != true || NameValue == "ASCIIHexDecode" || NameValue == "ASCII85Decode" || NameValue == "LZWDecode" || NameValue == "FlateDecode" || NameValue == "RunLengthDecode" || NameValue == "CCITTFaxDecode" || NameValue == "DCTDecode"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfFilterNames has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_2" clause="ArrayOfFunctionsEntry" testNumber="8"/>
			<description>Entry in ArrayOfFunctions shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFunctions has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_2" clause="ArrayOfFunctionsEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfFunctions shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfFunctions is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfIntegersGeneralEntry">
			<id specification="PDF_1_2" clause="ArrayOfIntegersGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfIntegersGeneral shall have type Integer</description>
			<test>HasTypeInteger == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfIntegersGeneral has type %1 instead of type Integer</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNamesForProcSetEntry">
			<id specification="PDF_1_2" clause="ArrayOfNamesForProcSetEntry" testNumber="8"/>
			<description>Entry in ArrayOfNamesForProcSet shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNamesForProcSet has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNamesForProcSetEntry">
			<id specification="PDF_1_2" clause="ArrayOfNamesForProcSetEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfNamesForProcSet shall have one of values: ImageI, PDF, ImageC, ImageB, Text</description>
			<test>HasTypeName != true || NameValue == "PDF" || NameValue == "Text" || NameValue == "ImageB" || NameValue == "ImageC" || NameValue == "ImageI"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfNamesForProcSet has incorrect value %1 instead of ImageI, PDF, ImageC, ImageB, Text</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNumbersGeneralEntry">
			<id specification="PDF_1_2" clause="ArrayOfNumbersGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfNumbersGeneral shall have type Number</description>
			<test>HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNumbersGeneral has type %1 instead of type Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color" testNumber="2"/>
			<description>ArrayOfOPI13Color shall contain exactly 5 elements</description>
			<test>size == 5</test>
			<error>
				<message>ArrayOfOPI13Color contains %1 element(s) instead of 5</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</description>
			<test>entry0HasTypeNumber != true || (entry0NumberValue &gt;= 0) &amp;&amp; (entry0NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 0 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-2" testNumber="8"/>
			<description>Entry 2 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</description>
			<test>entry2HasTypeNumber != true || (entry2NumberValue &gt;= 0) &amp;&amp; (entry2NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 2 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-3" testNumber="8"/>
			<description>Entry 3 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</description>
			<test>entry3HasTypeNumber != true || (entry3NumberValue &gt;= 0) &amp;&amp; (entry3NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 3 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_2" clause="ArrayOfOPI13Color-4" testNumber="8"/>
			<description>Entry 4 in ArrayOfOPI13Color shall have type StringByte</description>
			<test>size &lt;= 4 || entry4HasTypeStringByte == true</test>
			<error>
				<message>Entry 4 in ArrayOfOPI13Color has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_2" clause="ArrayOfOPI2Inks" testNumber="3"/>
			<description>ArrayOfOPI2Inks shall contain 2 * n + 1 elements</description>
			<test>size &gt; 0 &amp;&amp; size % 2 == 1</test>
			<error>
				<message>ArrayOfOPI2Inks contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_2" clause="ArrayOfOPI2Inks-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI2Inks shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI2Inks has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_2" clause="ArrayOfOPI2Inks-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in ArrayOfOPI2Inks shall have value monochrome</description>
			<test>entry0HasTypeName != true || entry0NameValue == "monochrome"</test>
			<error>
				<message>Entry 0 with type Name in ArrayOfOPI2Inks has incorrect value %1 instead of monochrome</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_2" clause="ArrayOfOPI2InksSubArray" testNumber="2"/>
			<description>ArrayOfOPI2InksSubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfOPI2InksSubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_2" clause="ArrayOfOPI2InksSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI2InksSubArray shall have type String</description>
			<test>size &lt;= 0 || entry0HasTypeString == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI2InksSubArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_2" clause="ArrayOfOPI2InksSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfOPI2InksSubArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfOPI2InksSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_2" clause="ArrayOfOPI2InksSubArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOfOPI2InksSubArray shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOfOPI2InksSubArray does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_2" clause="ArrayOfPageTreeNodeKidsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfPageTreeNodeKids shall be one of objects PageTreeNode, PageObject</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPageTreeNodeKids is not one of objects PageTreeNode, PageObject</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_2" clause="ArrayOfPageTreeNodeKidsEntry" testNumber="8"/>
			<description>Entry in ArrayOfPageTreeNodeKids shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfPageTreeNodeKids has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_2" clause="ArrayOfPageTreeNodeKidsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfPageTreeNodeKids shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPageTreeNodeKids is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStreamsGeneralEntry">
			<id specification="PDF_1_2" clause="ArrayOfStreamsGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfStreamsGeneral shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStreamsGeneral has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStreamsGeneralEntry">
			<id specification="PDF_1_2" clause="ArrayOfStreamsGeneralEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfStreamsGeneral shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfStreamsGeneral is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStringsTextEntry">
			<id specification="PDF_1_2" clause="ArrayOfStringsTextEntry" testNumber="8"/>
			<description>Entry in ArrayOfStringsText shall have type StringText</description>
			<test>HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStringsText has type %1 instead of type StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTags">
			<id specification="PDF_1_2" clause="ArrayOfTags" testNumber="3"/>
			<description>ArrayOfTags shall contain 2 * n elements</description>
			<test>size &gt; 0 &amp;&amp; size % 2 == 0</test>
			<error>
				<message>ArrayOfTags contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_2" clause="ArrayOfTagsSubArray" testNumber="2"/>
			<description>ArrayOfTagsSubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfTagsSubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_2" clause="ArrayOfTagsSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfTagsSubArray shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOfTagsSubArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_2" clause="ArrayOfTagsSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfTagsSubArray shall have type StringAscii</description>
			<test>size &lt;= 1 || entry1HasTypeStringAscii == true</test>
			<error>
				<message>Entry 1 in ArrayOfTagsSubArray has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfThreadsEntry">
			<id specification="PDF_1_2" clause="ArrayOfThreadsEntry" testNumber="8"/>
			<description>Entry in ArrayOfThreads shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfThreads has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_2" clause="ArrayOf_2DashNumbers" testNumber="2"/>
			<description>ArrayOf_2DashNumbers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2DashNumbers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_2" clause="ArrayOf_2DashNumbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2DashNumbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2DashNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_2" clause="ArrayOf_2DashNumbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2DashNumbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2DashNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_2" clause="ArrayOf_2Integers" testNumber="2"/>
			<description>ArrayOf_2Integers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2Integers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_2" clause="ArrayOf_2Integers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2Integers shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_2" clause="ArrayOf_2Integers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2Integers shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_2Numbers" testNumber="2"/>
			<description>ArrayOf_2Numbers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2Numbers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_2Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_2Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_2" clause="ArrayOf_2StringsByte" testNumber="2"/>
			<description>ArrayOf_2StringsByte shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2StringsByte contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_2" clause="ArrayOf_2StringsByte-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2StringsByte shall have type StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2StringsByte has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_2" clause="ArrayOf_2StringsByte-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2StringsByte shall have type StringByte</description>
			<test>size &lt;= 1 || entry1HasTypeStringByte == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2StringsByte has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics" testNumber="24"/>
			<description>ArrayOf_4AnnotBorderCharacteristics shall contain 3 to 4 elements</description>
			<test>size &gt;= 3 &amp;&amp; size &lt;= 4</test>
			<error>
				<message>ArrayOf_4AnnotBorderCharacteristics contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_2" clause="ArrayOf_4AnnotBorderCharacteristics-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4AnnotBorderCharacteristics shall have type Array</description>
			<test>size &lt;= 3 || entry3HasTypeArray == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_2" clause="ArrayOf_4Integers" testNumber="2"/>
			<description>ArrayOf_4Integers shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf_4Integers contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_2" clause="ArrayOf_4Integers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_2" clause="ArrayOf_4Integers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_2" clause="ArrayOf_4Integers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 2 || entry2HasTypeInteger == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_2" clause="ArrayOf_4Integers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 3 || entry3HasTypeInteger == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_4Numbers" testNumber="2"/>
			<description>ArrayOf_4Numbers shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf_4Numbers contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_4Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_4Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_4Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_4Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation" testNumber="24"/>
			<description>ArrayOf_4NumbersColorAnnotation shall contain 0 to 4 elements</description>
			<test>size &gt;= 0 &amp;&amp; size &lt;= 4</test>
			<error>
				<message>ArrayOf_4NumbersColorAnnotation contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</description>
			<test>entry0HasTypeNumber != true || (entry0NumberValue &gt;= 0) &amp;&amp; (entry0NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 0 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-1-Number" testNumber="9"/>
			<description>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy special case: fn:Eval(fn:IsPresent(2))</description>
			<test>entry1HasTypeNumber != true || (contains2 == true)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy special case: fn:Eval(fn:IsPresent(2))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</description>
			<test>entry2HasTypeNumber != true || (entry2NumberValue &gt;= 0) &amp;&amp; (entry2NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 2 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_2" clause="ArrayOf_4NumbersColorAnnotation-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</description>
			<test>entry3HasTypeNumber != true || (entry3NumberValue &gt;= 0) &amp;&amp; (entry3NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 3 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers" testNumber="2"/>
			<description>ArrayOf_8Numbers shall contain exactly 8 elements</description>
			<test>size == 8</test>
			<error>
				<message>ArrayOf_8Numbers contains %1 element(s) instead of 8</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-4" testNumber="8"/>
			<description>Entry 4 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-5" testNumber="8"/>
			<description>Entry 5 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-6" testNumber="8"/>
			<description>Entry 6 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 6 || entry6HasTypeNumber == true</test>
			<error>
				<message>Entry 6 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry6Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_8Numbers-7" testNumber="8"/>
			<description>Entry 7 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 7 || entry7HasTypeNumber == true</test>
			<error>
				<message>Entry 7 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry7Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers" testNumber="2"/>
			<description>ArrayOf_9Numbers shall contain exactly 9 elements</description>
			<test>size == 9</test>
			<error>
				<message>ArrayOf_9Numbers contains %1 element(s) instead of 9</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-4" testNumber="8"/>
			<description>Entry 4 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-5" testNumber="8"/>
			<description>Entry 5 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-6" testNumber="8"/>
			<description>Entry 6 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 6 || entry6HasTypeNumber == true</test>
			<error>
				<message>Entry 6 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry6Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-7" testNumber="8"/>
			<description>Entry 7 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 7 || entry7HasTypeNumber == true</test>
			<error>
				<message>Entry 7 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry7Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_2" clause="ArrayOf_9Numbers-8" testNumber="8"/>
			<description>Entry 8 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 8 || entry8HasTypeNumber == true</test>
			<error>
				<message>Entry 8 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry8Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead" testNumber="1"/>
			<description>Bead shall not contain entries except P, R, Type, T, V, N</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Bead contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-N-Dictionary" testNumber="17"/>
			<description>Entry N with type Dictionary in Bead shall be one of objects BeadFirst, Bead</description>
			<test>NHasTypeDictionary != true || N_size == 1</test>
			<error>
				<message>Entry N with type Dictionary in Bead is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-N" testNumber="8"/>
			<description>Entry N in Bead shall have type Dictionary</description>
			<test>containsN == false || NHasTypeDictionary == true</test>
			<error>
				<message>Entry N in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-N" testNumber="7"/>
			<description>Entry N in Bead is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-N-Dictionary" testNumber="10"/>
			<description>Entry N with type Dictionary in Bead shall be indirect</description>
			<test>NHasTypeDictionary != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-P" testNumber="8"/>
			<description>Entry P in Bead shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-P" testNumber="7"/>
			<description>Entry P in Bead is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in Bead shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-R" testNumber="8"/>
			<description>Entry R in Bead shall have type Rectangle</description>
			<test>containsR == false || RHasTypeRectangle == true</test>
			<error>
				<message>Entry R in Bead has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-R" testNumber="7"/>
			<description>Entry R in Bead is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-T" testNumber="8"/>
			<description>Entry T in Bead shall have type Dictionary</description>
			<test>containsT == false || THasTypeDictionary == true</test>
			<error>
				<message>Entry T in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in Bead shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-Type" testNumber="8"/>
			<description>Entry Type in Bead shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Bead has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Bead shall have value Bead</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Bead"</test>
			<error>
				<message>Entry Type with type Name in Bead has incorrect value %1 instead of Bead</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in Bead shall be one of objects BeadFirst, Bead</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in Bead is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-V" testNumber="8"/>
			<description>Entry V in Bead shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-V" testNumber="7"/>
			<description>Entry V in Bead is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_2" clause="Bead-V-Dictionary" testNumber="10"/>
			<description>Entry V with type Dictionary in Bead shall be indirect</description>
			<test>VHasTypeDictionary != true || isVIndirect == true</test>
			<error>
				<message>Entry V with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst" testNumber="1"/>
			<description>BeadFirst shall not contain entries except P, R, Type, T, V, N</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BeadFirst contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'N' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-N-Dictionary" testNumber="17"/>
			<description>Entry N with type Dictionary in BeadFirst shall be one of objects BeadFirst, Bead</description>
			<test>NHasTypeDictionary != true || N_size == 1</test>
			<error>
				<message>Entry N with type Dictionary in BeadFirst is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-N" testNumber="8"/>
			<description>Entry N in BeadFirst shall have type Dictionary</description>
			<test>containsN == false || NHasTypeDictionary == true</test>
			<error>
				<message>Entry N in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-N" testNumber="7"/>
			<description>Entry N in BeadFirst is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-N-Dictionary" testNumber="10"/>
			<description>Entry N with type Dictionary in BeadFirst shall be indirect</description>
			<test>NHasTypeDictionary != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-P" testNumber="8"/>
			<description>Entry P in BeadFirst shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-P" testNumber="7"/>
			<description>Entry P in BeadFirst is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in BeadFirst shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-R" testNumber="8"/>
			<description>Entry R in BeadFirst shall have type Rectangle</description>
			<test>containsR == false || RHasTypeRectangle == true</test>
			<error>
				<message>Entry R in BeadFirst has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-R" testNumber="7"/>
			<description>Entry R in BeadFirst is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-T" testNumber="8"/>
			<description>Entry T in BeadFirst shall have type Dictionary</description>
			<test>containsT == false || THasTypeDictionary == true</test>
			<error>
				<message>Entry T in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-T" testNumber="7"/>
			<description>Entry T in BeadFirst is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in BeadFirst shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-Type" testNumber="8"/>
			<description>Entry Type in BeadFirst shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in BeadFirst has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in BeadFirst shall have value Bead</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Bead"</test>
			<error>
				<message>Entry Type with type Name in BeadFirst has incorrect value %1 instead of Bead</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in BeadFirst shall be one of objects BeadFirst, Bead</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in BeadFirst is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-V" testNumber="8"/>
			<description>Entry V in BeadFirst shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-V" testNumber="7"/>
			<description>Entry V in BeadFirst is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_2" clause="BeadFirst-V-Dictionary" testNumber="10"/>
			<description>Entry V with type Dictionary in BeadFirst shall be indirect</description>
			<test>VHasTypeDictionary != true || isVIndirect == true</test>
			<error>
				<message>Entry V with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray" testNumber="2"/>
			<description>BlackpointArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>BlackpointArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-0" testNumber="8"/>
			<description>Entry 0 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-1" testNumber="8"/>
			<description>Entry 1 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-2" testNumber="8"/>
			<description>Entry 2 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_2" clause="BlackpointArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle" testNumber="1"/>
			<description>BorderStyle shall not contain entries except Type, S, D, W</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BorderStyle contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-D" testNumber="8"/>
			<description>Entry D in BorderStyle shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in BorderStyle has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-S" testNumber="8"/>
			<description>Entry S in BorderStyle shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in BorderStyle has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-S-Name" testNumber="6"/>
			<description>Entry S with type Name in BorderStyle shall have one of values: B, S, D, U, I</description>
			<test>SHasTypeName != true || SNameValue == "S" || SNameValue == "B" || SNameValue == "D" || SNameValue == "I" || SNameValue == "U"</test>
			<error>
				<message>Entry S with type Name in BorderStyle has incorrect value %1 instead of B, S, D, U, I</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-Type" testNumber="8"/>
			<description>Entry Type in BorderStyle shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in BorderStyle has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in BorderStyle shall have value Border</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Border"</test>
			<error>
				<message>Entry Type with type Name in BorderStyle has incorrect value %1 instead of Border</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-W" testNumber="8"/>
			<description>Entry W in BorderStyle shall have type Number</description>
			<test>containsW == false || WHasTypeNumber == true</test>
			<error>
				<message>Entry W in BorderStyle has type %1 instead of type Number</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_2" clause="BorderStyle-W-Number" testNumber="14"/>
			<description>Entry W with type Number in BorderStyle shall satisfy possible value predicate: fn:Eval(@W &gt;= 0.0)</description>
			<test>WHasTypeNumber != true || WNumberValue &gt;= 0.0</test>
			<error>
				<message>Entry W with type Number in BorderStyle does not satisfy possible value predicate: fn:Eval(@W &gt;= 0.0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics" testNumber="1"/>
			<description>CIDFontDescriptorMetrics shall not contain entries except FontBBox, CharSet, StemV, CapHeight, Flags, Type, ItalicAngle, Ascent, MaxWidth, FontName, StemH, AvgWidth, Descent, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontBBox' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CIDFontDescriptorMetrics contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontBBox' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Ascent" testNumber="8"/>
			<description>Entry Ascent in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Ascent" testNumber="7"/>
			<description>Entry Ascent in CIDFontDescriptorMetrics is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-CharSet" testNumber="8"/>
			<description>Entry CharSet in CIDFontDescriptorMetrics shall have type String</description>
			<test>containsCharSet == false || CharSetHasTypeString == true</test>
			<error>
				<message>Entry CharSet in CIDFontDescriptorMetrics has type %1 instead of type String</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Descent" testNumber="8"/>
			<description>Entry Descent in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Descent" testNumber="7"/>
			<description>Entry Descent in CIDFontDescriptorMetrics is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in CIDFontDescriptorMetrics shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in CIDFontDescriptorMetrics does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Flags" testNumber="8"/>
			<description>Entry Flags in CIDFontDescriptorMetrics shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in CIDFontDescriptorMetrics has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Flags" testNumber="7"/>
			<description>Entry Flags in CIDFontDescriptorMetrics is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in CIDFontDescriptorMetrics shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in CIDFontDescriptorMetrics does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in CIDFontDescriptorMetrics shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in CIDFontDescriptorMetrics has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in CIDFontDescriptorMetrics is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-FontName" testNumber="8"/>
			<description>Entry FontName in CIDFontDescriptorMetrics shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in CIDFontDescriptorMetrics has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-FontName" testNumber="7"/>
			<description>Entry FontName in CIDFontDescriptorMetrics is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in CIDFontDescriptorMetrics is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Leading" testNumber="8"/>
			<description>Entry Leading in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-StemH" testNumber="8"/>
			<description>Entry StemH in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-StemV" testNumber="8"/>
			<description>Entry StemV in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-StemV" testNumber="7"/>
			<description>Entry StemV in CIDFontDescriptorMetrics is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Type" testNumber="8"/>
			<description>Entry Type in CIDFontDescriptorMetrics shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in CIDFontDescriptorMetrics has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Type" testNumber="7"/>
			<description>Entry Type in CIDFontDescriptorMetrics is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in CIDFontDescriptorMetrics shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in CIDFontDescriptorMetrics has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_2" clause="CIDFontDescriptorMetrics-XHeight" testNumber="8"/>
			<description>Entry XHeight in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo" testNumber="1"/>
			<description>CIDSystemInfo shall not contain entries except Ordering, Supplement, Registry</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ordering' &amp;&amp; elem != 'Supplement' &amp;&amp; elem != 'Registry' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CIDSystemInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ordering' &amp;&amp; elem != 'Supplement' &amp;&amp; elem != 'Registry' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Ordering" testNumber="8"/>
			<description>Entry Ordering in CIDSystemInfo shall have type StringAscii</description>
			<test>containsOrdering == false || OrderingHasTypeStringAscii == true</test>
			<error>
				<message>Entry Ordering in CIDSystemInfo has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>OrderingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Ordering" testNumber="7"/>
			<description>Entry Ordering in CIDSystemInfo is required</description>
			<test>containsOrdering == true</test>
			<error>
				<message>Entry Ordering in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Registry" testNumber="8"/>
			<description>Entry Registry in CIDSystemInfo shall have type StringAscii</description>
			<test>containsRegistry == false || RegistryHasTypeStringAscii == true</test>
			<error>
				<message>Entry Registry in CIDSystemInfo has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>RegistryType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Registry" testNumber="7"/>
			<description>Entry Registry in CIDSystemInfo is required</description>
			<test>containsRegistry == true</test>
			<error>
				<message>Entry Registry in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Supplement" testNumber="8"/>
			<description>Entry Supplement in CIDSystemInfo shall have type Integer</description>
			<test>containsSupplement == false || SupplementHasTypeInteger == true</test>
			<error>
				<message>Entry Supplement in CIDSystemInfo has type %1 instead of type Integer</message>
				<arguments>
					<argument>SupplementType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_2" clause="CIDSystemInfo-Supplement" testNumber="7"/>
			<description>Entry Supplement in CIDSystemInfo is required</description>
			<test>containsSupplement == true</test>
			<error>
				<message>Entry Supplement in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream" testNumber="1"/>
			<description>CMapStream shall not contain entries except FDecodeParms, Type, WMode, Filter, Length, F, CMapName, DecodeParms, CIDSystemInfo, UseCMap, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'WMode' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CMapStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'WMode' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream" testNumber="22"/>
			<description>CMapStream shall not contain entry DL in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL').length == 0</test>
			<error>
				<message>CMapStream contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in CMapStream shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in CMapStream has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in CMapStream is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-CMapName" testNumber="8"/>
			<description>Entry CMapName in CMapStream shall have type Name</description>
			<test>containsCMapName == false || CMapNameHasTypeName == true</test>
			<error>
				<message>Entry CMapName in CMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>CMapNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-CMapName" testNumber="7"/>
			<description>Entry CMapName in CMapStream is required</description>
			<test>containsCMapName == true</test>
			<error>
				<message>Entry CMapName in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in CMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in CMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in CMapStream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in CMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-F" testNumber="8"/>
			<description>Entry F in CMapStream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in CMapStream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in CMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in CMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in CMapStream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in CMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FFilter" testNumber="8"/>
			<description>Entry FFilter in CMapStream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in CMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in CMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in CMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Filter" testNumber="8"/>
			<description>Entry Filter in CMapStream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in CMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in CMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in CMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Length" testNumber="8"/>
			<description>Entry Length in CMapStream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in CMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Length" testNumber="7"/>
			<description>Entry Length in CMapStream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Type" testNumber="8"/>
			<description>Entry Type in CMapStream shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in CMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Type" testNumber="7"/>
			<description>Entry Type in CMapStream is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in CMapStream shall have value CMap</description>
			<test>TypeHasTypeName != true || TypeNameValue == "CMap"</test>
			<error>
				<message>Entry Type with type Name in CMapStream has incorrect value %1 instead of CMap</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-UseCMap" testNumber="8"/>
			<description>Entry UseCMap in CMapStream shall have one of types: Name, Stream</description>
			<test>containsUseCMap == false || UseCMapHasTypeName == true || UseCMapHasTypeStream == true</test>
			<error>
				<message>Entry UseCMap in CMapStream has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>UseCMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-UseCMap-Name" testNumber="6"/>
			<description>Entry UseCMap with type Name in CMapStream shall have one of values: GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</description>
			<test>UseCMapHasTypeName != true || UseCMapNameValue == "GB-EUC-H" || UseCMapNameValue == "GB-EUC-V" || UseCMapNameValue == "GBpc-EUC-H" || UseCMapNameValue == "GBpc-EUC-V" || UseCMapNameValue == "GBK-EUC-H" || UseCMapNameValue == "GBK-EUC-V" || UseCMapNameValue == "GBKp-EUC-H" || UseCMapNameValue == "GBKp-EUC-V" || UseCMapNameValue == "GBK2K-H" || UseCMapNameValue == "GBK2K-V" || UseCMapNameValue == "UniGB-UCS2-H" || UseCMapNameValue == "UniGB-UCS2-V" || UseCMapNameValue == "UniGB-UTF16-H" || UseCMapNameValue == "UniGB-UTF16-V" || UseCMapNameValue == "B5pc-H" || UseCMapNameValue == "B5pc-V" || UseCMapNameValue == "HKscs-B5-H" || UseCMapNameValue == "HKscs-B5-V" || UseCMapNameValue == "ETen-B5-H" || UseCMapNameValue == "ETen-B5-V" || UseCMapNameValue == "ETenms-B5-H" || UseCMapNameValue == "ETenms-B5-V" || UseCMapNameValue == "CNS-EUC-H" || UseCMapNameValue == "CNS-EUC-V" || UseCMapNameValue == "UniCNS-UCS2-H" || UseCMapNameValue == "UniCNS-UCS2-V" || UseCMapNameValue == "UniCNS-UTF16-H" || UseCMapNameValue == "UniCNS-UTF16-V" || UseCMapNameValue == "83pv-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-V" || UseCMapNameValue == "90msp-RKSJ-H" || UseCMapNameValue == "90msp-RKSJ-V" || UseCMapNameValue == "90pv-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-V" || UseCMapNameValue == "EUC-H" || UseCMapNameValue == "EUC-V" || UseCMapNameValue == "Ext-RKSJ-H" || UseCMapNameValue == "Ext-RKSJ-V" || UseCMapNameValue == "H" || UseCMapNameValue == "V" || UseCMapNameValue == "UniJIS-UCS2-H" || UseCMapNameValue == "UniJIS-UCS2-V" || UseCMapNameValue == "UniJIS-UCS2-HW-H" || UseCMapNameValue == "UniJIS-UCS2-HW-V" || UseCMapNameValue == "UniJIS-UTF16-H" || UseCMapNameValue == "UniJIS-UTF16-V" || UseCMapNameValue == "KSC-EUC-H" || UseCMapNameValue == "KSC-EUC-V" || UseCMapNameValue == "KSCms-UHC-H" || UseCMapNameValue == "KSCms-UHC-V" || UseCMapNameValue == "KSCms-UHC-HW-H" || UseCMapNameValue == "KSCms-UHC-HW-V" || UseCMapNameValue == "KSCpc-EUC-H" || UseCMapNameValue == "UniKS-UCS2-H" || UseCMapNameValue == "UniKS-UCS2-V" || UseCMapNameValue == "UniKS-UTF16-H" || UseCMapNameValue == "UniKS-UTF16-V" || UseCMapNameValue == "Identity-H" || UseCMapNameValue == "Identity-V"</test>
			<error>
				<message>Entry UseCMap with type Name in CMapStream has incorrect value %1 instead of GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</message>
				<arguments>
					<argument>UseCMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-UseCMap-Stream" testNumber="10"/>
			<description>Entry UseCMap with type Stream in CMapStream shall be indirect</description>
			<test>UseCMapHasTypeStream != true || isUseCMapIndirect == true</test>
			<error>
				<message>Entry UseCMap with type Stream in CMapStream is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-WMode" testNumber="8"/>
			<description>Entry WMode in CMapStream shall have type Integer</description>
			<test>containsWMode == false || WModeHasTypeInteger == true</test>
			<error>
				<message>Entry WMode in CMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>WModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_2" clause="CMapStream-WMode-Integer" testNumber="6"/>
			<description>Entry WMode with type Integer in CMapStream shall have one of values: 0, 1</description>
			<test>WModeHasTypeInteger != true || WModeIntegerValue == 1 || WModeIntegerValue == 0</test>
			<error>
				<message>Entry WMode with type Integer in CMapStream has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>WModeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_2" clause="CalGrayColorSpace" testNumber="2"/>
			<description>CalGrayColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>CalGrayColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_2" clause="CalGrayColorSpace-0" testNumber="8"/>
			<description>Entry 0 in CalGrayColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in CalGrayColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_2" clause="CalGrayColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in CalGrayColorSpace shall have value CalGray</description>
			<test>entry0HasTypeName != true || entry0NameValue == "CalGray"</test>
			<error>
				<message>Entry 0 with type Name in CalGrayColorSpace has incorrect value %1 instead of CalGray</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_2" clause="CalGrayColorSpace-1" testNumber="8"/>
			<description>Entry 1 in CalGrayColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in CalGrayColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict" testNumber="1"/>
			<description>CalGrayDict shall not contain entries except Gamma, WhitePoint, BlackPoint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; elem != 'BlackPoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CalGrayDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; elem != 'BlackPoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in CalGrayDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in CalGrayDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict-Gamma" testNumber="8"/>
			<description>Entry Gamma in CalGrayDict shall have type Number</description>
			<test>containsGamma == false || GammaHasTypeNumber == true</test>
			<error>
				<message>Entry Gamma in CalGrayDict has type %1 instead of type Number</message>
				<arguments>
					<argument>GammaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict-Gamma-Number" testNumber="14"/>
			<description>Entry Gamma with type Number in CalGrayDict shall satisfy possible value predicate: fn:Eval(@Gamma &gt; 0)</description>
			<test>GammaHasTypeNumber != true || GammaNumberValue &gt; 0</test>
			<error>
				<message>Entry Gamma with type Number in CalGrayDict does not satisfy possible value predicate: fn:Eval(@Gamma &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in CalGrayDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in CalGrayDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_2" clause="CalGrayDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in CalGrayDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in CalGrayDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_2" clause="CalRGBColorSpace" testNumber="2"/>
			<description>CalRGBColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>CalRGBColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_2" clause="CalRGBColorSpace-0" testNumber="8"/>
			<description>Entry 0 in CalRGBColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in CalRGBColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_2" clause="CalRGBColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in CalRGBColorSpace shall have value CalRGB</description>
			<test>entry0HasTypeName != true || entry0NameValue == "CalRGB"</test>
			<error>
				<message>Entry 0 with type Name in CalRGBColorSpace has incorrect value %1 instead of CalRGB</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_2" clause="CalRGBColorSpace-1" testNumber="8"/>
			<description>Entry 1 in CalRGBColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in CalRGBColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict" testNumber="1"/>
			<description>CalRGBDict shall not contain entries except Gamma, WhitePoint, Matrix, BlackPoint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'BlackPoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CalRGBDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'BlackPoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in CalRGBDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict-Gamma" testNumber="8"/>
			<description>Entry Gamma in CalRGBDict shall have type Array</description>
			<test>containsGamma == false || GammaHasTypeArray == true</test>
			<error>
				<message>Entry Gamma in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>GammaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict-Matrix" testNumber="8"/>
			<description>Entry Matrix in CalRGBDict shall have type Array</description>
			<test>containsMatrix == false || MatrixHasTypeArray == true</test>
			<error>
				<message>Entry Matrix in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in CalRGBDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_2" clause="CalRGBDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in CalRGBDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in CalRGBDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog" testNumber="1"/>
			<description>Catalog shall not contain entries except NeedsRendering, URI, Names, AcroForm, Outlines, Dests, PageMode, Pages, Threads, Type, OpenAction, PageLayout, ViewerPreferences</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DPartRoot' &amp;&amp; elem != 'Legal' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'NeedsRendering' &amp;&amp; elem != 'PageLabels' &amp;&amp; elem != 'Extensions' &amp;&amp; elem != 'URI' &amp;&amp; elem != 'Requirements' &amp;&amp; elem != 'Names' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'AcroForm' &amp;&amp; elem != 'Outlines' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'SpiderInfo' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'PageMode' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'DSS' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'OCProperties' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Threads' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'OpenAction' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'PageLayout' &amp;&amp; elem != 'Collection' &amp;&amp; elem != 'ViewerPreferences' &amp;&amp; elem != 'MarkInfo' &amp;&amp; elem != 'StructTreeRoot' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Catalog contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DPartRoot' &amp;&amp; elem != 'Legal' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'NeedsRendering' &amp;&amp; elem != 'PageLabels' &amp;&amp; elem != 'Extensions' &amp;&amp; elem != 'URI' &amp;&amp; elem != 'Requirements' &amp;&amp; elem != 'Names' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'AcroForm' &amp;&amp; elem != 'Outlines' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'SpiderInfo' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'PageMode' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'DSS' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'OCProperties' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Threads' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'OpenAction' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'PageLayout' &amp;&amp; elem != 'Collection' &amp;&amp; elem != 'ViewerPreferences' &amp;&amp; elem != 'MarkInfo' &amp;&amp; elem != 'StructTreeRoot' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog" testNumber="22"/>
			<description>Catalog shall not contain entries DPartRoot, Legal, Metadata, PageLabels, Extensions, Requirements, Version, SpiderInfo, AA, AF, DSS, OutputIntents, PieceInfo, Lang, OCProperties, Perms, Collection, MarkInfo, StructTreeRoot in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DPartRoot' || elem == 'Legal' || elem == 'Metadata' || elem == 'PageLabels' || elem == 'Extensions' || elem == 'Requirements' || elem == 'Version' || elem == 'SpiderInfo' || elem == 'AA' || elem == 'AF' || elem == 'DSS' || elem == 'OutputIntents' || elem == 'PieceInfo' || elem == 'Lang' || elem == 'OCProperties' || elem == 'Perms' || elem == 'Collection' || elem == 'MarkInfo' || elem == 'StructTreeRoot').length == 0</test>
			<error>
				<message>Catalog contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DPartRoot' || elem == 'Legal' || elem == 'Metadata' || elem == 'PageLabels' || elem == 'Extensions' || elem == 'Requirements' || elem == 'Version' || elem == 'SpiderInfo' || elem == 'AA' || elem == 'AF' || elem == 'DSS' || elem == 'OutputIntents' || elem == 'PieceInfo' || elem == 'Lang' || elem == 'OCProperties' || elem == 'Perms' || elem == 'Collection' || elem == 'MarkInfo' || elem == 'StructTreeRoot').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-AcroForm" testNumber="8"/>
			<description>Entry AcroForm in Catalog shall have type Dictionary</description>
			<test>containsAcroForm == false || AcroFormHasTypeDictionary == true</test>
			<error>
				<message>Entry AcroForm in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AcroFormType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Dests" testNumber="8"/>
			<description>Entry Dests in Catalog shall have type Dictionary</description>
			<test>containsDests == false || DestsHasTypeDictionary == true</test>
			<error>
				<message>Entry Dests in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DestsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Dests-Dictionary" testNumber="10"/>
			<description>Entry Dests with type Dictionary in Catalog shall be indirect</description>
			<test>DestsHasTypeDictionary != true || isDestsIndirect == true</test>
			<error>
				<message>Entry Dests with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Names" testNumber="8"/>
			<description>Entry Names in Catalog shall have type Dictionary</description>
			<test>containsNames == false || NamesHasTypeDictionary == true</test>
			<error>
				<message>Entry Names in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NamesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-NeedsRendering" testNumber="8"/>
			<description>Entry NeedsRendering in Catalog shall have type Boolean</description>
			<test>containsNeedsRendering == false || NeedsRenderingHasTypeBoolean == true</test>
			<error>
				<message>Entry NeedsRendering in Catalog has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NeedsRenderingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-OpenAction-Array" testNumber="17"/>
			<description>Entry OpenAction with type Array in Catalog shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>OpenActionHasTypeArray != true || OpenAction_size == 1</test>
			<error>
				<message>Entry OpenAction with type Array in Catalog is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-OpenAction-Dictionary" testNumber="17"/>
			<description>Entry OpenAction with type Dictionary in Catalog shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>OpenActionHasTypeDictionary != true || OpenAction_size == 1</test>
			<error>
				<message>Entry OpenAction with type Dictionary in Catalog is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-OpenAction" testNumber="8"/>
			<description>Entry OpenAction in Catalog shall have one of types: Array, Dictionary</description>
			<test>containsOpenAction == false || OpenActionHasTypeArray == true || OpenActionHasTypeDictionary == true</test>
			<error>
				<message>Entry OpenAction in Catalog has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>OpenActionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Outlines" testNumber="8"/>
			<description>Entry Outlines in Catalog shall have type Dictionary</description>
			<test>containsOutlines == false || OutlinesHasTypeDictionary == true</test>
			<error>
				<message>Entry Outlines in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OutlinesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Outlines-Dictionary" testNumber="10"/>
			<description>Entry Outlines with type Dictionary in Catalog shall be indirect</description>
			<test>OutlinesHasTypeDictionary != true || isOutlinesIndirect == true</test>
			<error>
				<message>Entry Outlines with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-PageLayout" testNumber="8"/>
			<description>Entry PageLayout in Catalog shall have type Name</description>
			<test>containsPageLayout == false || PageLayoutHasTypeName == true</test>
			<error>
				<message>Entry PageLayout in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>PageLayoutType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-PageLayout-Name" testNumber="6"/>
			<description>Entry PageLayout with type Name in Catalog shall have one of values: SinglePage, TwoColumnLeft, OneColumn, TwoPageRight, TwoPageLeft, TwoColumnRight</description>
			<test>PageLayoutHasTypeName != true || PageLayoutNameValue == "SinglePage" || PageLayoutNameValue == "OneColumn" || PageLayoutNameValue == "TwoColumnLeft" || PageLayoutNameValue == "TwoColumnRight" || PageLayoutNameValue == "TwoPageLeft" || PageLayoutNameValue == "TwoPageRight"</test>
			<error>
				<message>Entry PageLayout with type Name in Catalog has incorrect value %1 instead of SinglePage, TwoColumnLeft, OneColumn, TwoPageRight, TwoPageLeft, TwoColumnRight</message>
				<arguments>
					<argument>PageLayoutNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-PageMode" testNumber="8"/>
			<description>Entry PageMode in Catalog shall have type Name</description>
			<test>containsPageMode == false || PageModeHasTypeName == true</test>
			<error>
				<message>Entry PageMode in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>PageModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-PageMode-Name" testNumber="6"/>
			<description>Entry PageMode with type Name in Catalog shall have one of values: UseOutlines, UseThumbs, UseOC, UseAttachments, UseNone, FullScreen</description>
			<test>PageModeHasTypeName != true || PageModeNameValue == "UseNone" || PageModeNameValue == "UseOutlines" || PageModeNameValue == "UseThumbs" || PageModeNameValue == "FullScreen" || PageModeNameValue == "UseOC" || PageModeNameValue == "UseAttachments"</test>
			<error>
				<message>Entry PageMode with type Name in Catalog has incorrect value %1 instead of UseOutlines, UseThumbs, UseOC, UseAttachments, UseNone, FullScreen</message>
				<arguments>
					<argument>PageModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Pages" testNumber="8"/>
			<description>Entry Pages in Catalog shall have type Dictionary</description>
			<test>containsPages == false || PagesHasTypeDictionary == true</test>
			<error>
				<message>Entry Pages in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PagesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Pages" testNumber="7"/>
			<description>Entry Pages in Catalog is required</description>
			<test>containsPages == true</test>
			<error>
				<message>Entry Pages in Catalog is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Pages-Dictionary" testNumber="10"/>
			<description>Entry Pages with type Dictionary in Catalog shall be indirect</description>
			<test>PagesHasTypeDictionary != true || isPagesIndirect == true</test>
			<error>
				<message>Entry Pages with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Threads" testNumber="8"/>
			<description>Entry Threads in Catalog shall have type Array</description>
			<test>containsThreads == false || ThreadsHasTypeArray == true</test>
			<error>
				<message>Entry Threads in Catalog has type %1 instead of type Array</message>
				<arguments>
					<argument>ThreadsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Threads-Array" testNumber="10"/>
			<description>Entry Threads with type Array in Catalog shall be indirect</description>
			<test>ThreadsHasTypeArray != true || isThreadsIndirect == true</test>
			<error>
				<message>Entry Threads with type Array in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Type" testNumber="8"/>
			<description>Entry Type in Catalog shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Type" testNumber="7"/>
			<description>Entry Type in Catalog is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in Catalog is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Catalog shall have value Catalog</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Catalog"</test>
			<error>
				<message>Entry Type with type Name in Catalog has incorrect value %1 instead of Catalog</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-URI" testNumber="8"/>
			<description>Entry URI in Catalog shall have type Dictionary</description>
			<test>containsURI == false || URIHasTypeDictionary == true</test>
			<error>
				<message>Entry URI in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>URIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_2" clause="Catalog-ViewerPreferences" testNumber="8"/>
			<description>Entry ViewerPreferences in Catalog shall have type Dictionary</description>
			<test>containsViewerPreferences == false || ViewerPreferencesHasTypeDictionary == true</test>
			<error>
				<message>Entry ViewerPreferences in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ViewerPreferencesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACharProcMapEntry">
			<id specification="PDF_1_2" clause="CharProcMapEntry" testNumber="8"/>
			<description>Entry in CharProcMap shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in CharProcMap has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACharProcMapEntry">
			<id specification="PDF_1_2" clause="CharProcMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in CharProcMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in CharProcMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_2" clause="ColorSpaceMap-DefaultGray-Array" testNumber="17"/>
			<description>Entry DefaultGray with type Array in ColorSpaceMap shall be one of objects CalGrayColorSpace, SeparationColorSpace</description>
			<test>DefaultGrayHasTypeArray != true || DefaultGray_size == 1</test>
			<error>
				<message>Entry DefaultGray with type Array in ColorSpaceMap is not one of objects CalGrayColorSpace, SeparationColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_2" clause="ColorSpaceMap-DefaultGray" testNumber="8"/>
			<description>Entry DefaultGray in ColorSpaceMap shall have type Array</description>
			<test>containsDefaultGray == false || DefaultGrayHasTypeArray == true</test>
			<error>
				<message>Entry DefaultGray in ColorSpaceMap has type %1 instead of type Array</message>
				<arguments>
					<argument>DefaultGrayType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_2" clause="ColorSpaceMap-DefaultRGB" testNumber="8"/>
			<description>Entry DefaultRGB in ColorSpaceMap shall have type Array</description>
			<test>containsDefaultRGB == false || DefaultRGBHasTypeArray == true</test>
			<error>
				<message>Entry DefaultRGB in ColorSpaceMap has type %1 instead of type Array</message>
				<arguments>
					<argument>DefaultRGBType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_2" clause="ColorSpaceMapEntry-Array" testNumber="17"/>
			<description>Entry with type Array in ColorSpaceMap shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace, PatternColorSpace</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in ColorSpaceMap is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace, PatternColorSpace</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_2" clause="ColorSpaceMapEntry" testNumber="8"/>
			<description>Entry in ColorSpaceMap shall have one of types: Array, Name</description>
			<test>HasTypeArray == true || HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ColorSpaceMap has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_2" clause="ColorSpaceMapEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ColorSpaceMap shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>HasTypeName != true || NameValue == "DeviceCMYK" || NameValue == "DeviceRGB" || NameValue == "DeviceGray"</test>
			<error>
				<message>Entry %keyName% with type Name in ColorSpaceMap has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_2" clause="Dest0Array" testNumber="2"/>
			<description>Dest0Array shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>Dest0Array contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_2" clause="Dest0Array-0" testNumber="8"/>
			<description>Entry 0 in Dest0Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest0Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_2" clause="Dest0Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest0Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest0Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_2" clause="Dest0Array-1" testNumber="8"/>
			<description>Entry 1 in Dest0Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest0Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_2" clause="Dest0Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest0Array shall have one of values: Fit, FitB</description>
			<test>entry1HasTypeName != true || entry1NameValue == "Fit" || entry1NameValue == "FitB"</test>
			<error>
				<message>Entry 1 with type Name in Dest0Array has incorrect value %1 instead of Fit, FitB</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array" testNumber="2"/>
			<description>Dest1Array shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>Dest1Array contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array-0" testNumber="8"/>
			<description>Entry 0 in Dest1Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest1Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest1Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest1Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array-1" testNumber="8"/>
			<description>Entry 1 in Dest1Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest1Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest1Array shall have one of values: FitV, FitH, FitBH, FitBV</description>
			<test>entry1HasTypeName != true || entry1NameValue == "FitH" || entry1NameValue == "FitV" || entry1NameValue == "FitBH" || entry1NameValue == "FitBV"</test>
			<error>
				<message>Entry 1 with type Name in Dest1Array has incorrect value %1 instead of FitV, FitH, FitBH, FitBV</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_2" clause="Dest1Array-2" testNumber="8"/>
			<description>Entry 2 in Dest1Array shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in Dest1Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array" testNumber="2"/>
			<description>Dest4Array shall contain exactly 6 elements</description>
			<test>size == 6</test>
			<error>
				<message>Dest4Array contains %1 element(s) instead of 6</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-0" testNumber="8"/>
			<description>Entry 0 in Dest4Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest4Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest4Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest4Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-1" testNumber="8"/>
			<description>Entry 1 in Dest4Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest4Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest4Array shall have value FitR</description>
			<test>entry1HasTypeName != true || entry1NameValue == "FitR"</test>
			<error>
				<message>Entry 1 with type Name in Dest4Array has incorrect value %1 instead of FitR</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-2" testNumber="8"/>
			<description>Entry 2 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-3" testNumber="8"/>
			<description>Entry 3 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 3 || entry3HasTypeNull == true || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-4" testNumber="8"/>
			<description>Entry 4 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 4 || entry4HasTypeNull == true || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_2" clause="Dest4Array-5" testNumber="8"/>
			<description>Entry 5 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 5 || entry5HasTypeNull == true || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_2" clause="DestDict" testNumber="1"/>
			<description>DestDict shall not contain entries except D</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'D' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>DestDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'SD' &amp;&amp; elem != 'D' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_2" clause="DestDict" testNumber="22"/>
			<description>DestDict shall not contain entry SD in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'SD').length == 0</test>
			<error>
				<message>DestDict contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'SD').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_2" clause="DestDict-D-Array" testNumber="17"/>
			<description>Entry D with type Array in DestDict shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in DestDict is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_2" clause="DestDict-D" testNumber="8"/>
			<description>Entry D in DestDict shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in DestDict has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_2" clause="DestDict-D" testNumber="7"/>
			<description>Entry D in DestDict is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in DestDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray" testNumber="2"/>
			<description>DestXYZArray shall contain exactly 5 elements</description>
			<test>size == 5</test>
			<error>
				<message>DestXYZArray contains %1 element(s) instead of 5</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-0" testNumber="8"/>
			<description>Entry 0 in DestXYZArray shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in DestXYZArray has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in DestXYZArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in DestXYZArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-1" testNumber="8"/>
			<description>Entry 1 in DestXYZArray shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in DestXYZArray has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in DestXYZArray shall have value XYZ</description>
			<test>entry1HasTypeName != true || entry1NameValue == "XYZ"</test>
			<error>
				<message>Entry 1 with type Name in DestXYZArray has incorrect value %1 instead of XYZ</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-2" testNumber="8"/>
			<description>Entry 2 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-3" testNumber="8"/>
			<description>Entry 3 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 3 || entry3HasTypeNull == true || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_2" clause="DestXYZArray-4" testNumber="8"/>
			<description>Entry 4 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 4 || entry4HasTypeNull == true || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_2" clause="DestsMapEntry-Array" testNumber="17"/>
			<description>Entry with type Array in DestsMap shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in DestsMap is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_2" clause="DestsMapEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in DestsMap shall be one of objects ActionGoTo, ActionGoToR, DestDict</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in DestsMap is not one of objects ActionGoTo, ActionGoToR, DestDict</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_2" clause="DestsMapEntry" testNumber="8"/>
			<description>Entry in DestsMap shall have one of types: Array, Dictionary</description>
			<test>HasTypeArray == true || HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in DestsMap has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADictionaryOfDictionariesEntry">
			<id specification="PDF_1_2" clause="DictionaryOfDictionariesEntry" testNumber="8"/>
			<description>Entry in DictionaryOfDictionaries shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in DictionaryOfDictionaries has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Author" testNumber="8"/>
			<description>Entry Author in DocInfo shall have type StringText</description>
			<test>containsAuthor == false || AuthorHasTypeStringText == true</test>
			<error>
				<message>Entry Author in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>AuthorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-CreationDate" testNumber="8"/>
			<description>Entry CreationDate in DocInfo shall have type Date</description>
			<test>containsCreationDate == false || CreationDateHasTypeDate == true</test>
			<error>
				<message>Entry CreationDate in DocInfo has type %1 instead of type Date</message>
				<arguments>
					<argument>CreationDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Creator" testNumber="8"/>
			<description>Entry Creator in DocInfo shall have type StringText</description>
			<test>containsCreator == false || CreatorHasTypeStringText == true</test>
			<error>
				<message>Entry Creator in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>CreatorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Keywords" testNumber="8"/>
			<description>Entry Keywords in DocInfo shall have type StringText</description>
			<test>containsKeywords == false || KeywordsHasTypeStringText == true</test>
			<error>
				<message>Entry Keywords in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>KeywordsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-ModDate" testNumber="8"/>
			<description>Entry ModDate in DocInfo shall have type Date</description>
			<test>containsModDate == false || ModDateHasTypeDate == true</test>
			<error>
				<message>Entry ModDate in DocInfo has type %1 instead of type Date</message>
				<arguments>
					<argument>ModDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Producer" testNumber="8"/>
			<description>Entry Producer in DocInfo shall have type StringText</description>
			<test>containsProducer == false || ProducerHasTypeStringText == true</test>
			<error>
				<message>Entry Producer in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>ProducerType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Subject" testNumber="8"/>
			<description>Entry Subject in DocInfo shall have type StringText</description>
			<test>containsSubject == false || SubjectHasTypeStringText == true</test>
			<error>
				<message>Entry Subject in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>SubjectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_2" clause="DocInfo-Title" testNumber="8"/>
			<description>Entry Title in DocInfo shall have type StringText</description>
			<test>containsTitle == false || TitleHasTypeStringText == true</test>
			<error>
				<message>Entry Title in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>TitleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfoEntry">
			<id specification="PDF_1_2" clause="DocInfoEntry" testNumber="8"/>
			<description>Entry in DocInfo shall have type StringText</description>
			<test>HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_2" clause="Document-ObjectStreams" testNumber="25"/>
			<description>Document shall not contain ObjectStreams in PDF 1.2</description>
			<test>containsObjectStreams == false</test>
			<error>
				<message>Document contains ObjectStreams</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_2" clause="Document-XRefStream" testNumber="25"/>
			<description>Document shall not contain XRefStream in PDF 1.2</description>
			<test>containsXRefStream == false</test>
			<error>
				<message>Document contains XRefStream</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_2" clause="Document-FileTrailer" testNumber="8"/>
			<description>FileTrailer shall have type Dictionary</description>
			<test>containsFileTrailer == false || FileTrailerHasTypeDictionary == true</test>
			<error>
				<message>FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FileTrailerType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding" testNumber="1"/>
			<description>Encoding shall not contain entries except Type, Differences, BaseEncoding</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'Differences' &amp;&amp; elem != 'BaseEncoding' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Encoding contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'Differences' &amp;&amp; elem != 'BaseEncoding' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding-BaseEncoding" testNumber="8"/>
			<description>Entry BaseEncoding in Encoding shall have type Name</description>
			<test>containsBaseEncoding == false || BaseEncodingHasTypeName == true</test>
			<error>
				<message>Entry BaseEncoding in Encoding has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseEncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding-BaseEncoding-Name" testNumber="6"/>
			<description>Entry BaseEncoding with type Name in Encoding shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>BaseEncodingHasTypeName != true || BaseEncodingNameValue == "MacRomanEncoding" || BaseEncodingNameValue == "MacExpertEncoding" || BaseEncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry BaseEncoding with type Name in Encoding has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>BaseEncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding-Differences" testNumber="8"/>
			<description>Entry Differences in Encoding shall have type Array</description>
			<test>containsDifferences == false || DifferencesHasTypeArray == true</test>
			<error>
				<message>Entry Differences in Encoding has type %1 instead of type Array</message>
				<arguments>
					<argument>DifferencesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding-Type" testNumber="8"/>
			<description>Entry Type in Encoding shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Encoding has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_2" clause="Encoding-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Encoding shall have value Encoding</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Encoding"</test>
			<error>
				<message>Entry Type with type Name in Encoding has incorrect value %1 instead of Encoding</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey" testNumber="1"/>
			<description>EncryptionPublicKey shall not contain entries except Filter, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'Recipients' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'V' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EncryptionPublicKey contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'Recipients' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'V' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey" testNumber="22"/>
			<description>EncryptionPublicKey shall not contain entries P, SubFilter, StrF, CF, EFF, Recipients, Length, KDFSalt, StmF, EncryptMetadata in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'P' || elem == 'SubFilter' || elem == 'StrF' || elem == 'CF' || elem == 'EFF' || elem == 'Recipients' || elem == 'Length' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'EncryptMetadata').length == 0</test>
			<error>
				<message>EncryptionPublicKey contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'P' || elem == 'SubFilter' || elem == 'StrF' || elem == 'CF' || elem == 'EFF' || elem == 'Recipients' || elem == 'Length' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'EncryptMetadata').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-Filter" testNumber="8"/>
			<description>Entry Filter in EncryptionPublicKey shall have type Name</description>
			<test>containsFilter == false || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in EncryptionPublicKey has type %1 instead of type Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-Filter" testNumber="7"/>
			<description>Entry Filter in EncryptionPublicKey is required</description>
			<test>containsFilter == true</test>
			<error>
				<message>Entry Filter in EncryptionPublicKey is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in EncryptionPublicKey shall have one of values: Adobe.PubSec, AdobePPKLite</description>
			<test>FilterHasTypeName != true || FilterNameValue == "Adobe.PubSec" || FilterNameValue == "AdobePPKLite"</test>
			<error>
				<message>Entry Filter with type Name in EncryptionPublicKey has incorrect value %1 instead of Adobe.PubSec, AdobePPKLite</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-V" testNumber="8"/>
			<description>Entry V in EncryptionPublicKey shall have type Integer</description>
			<test>containsV == false || VHasTypeInteger == true</test>
			<error>
				<message>Entry V in EncryptionPublicKey has type %1 instead of type Integer</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-V" testNumber="7"/>
			<description>Entry V in EncryptionPublicKey is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in EncryptionPublicKey is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-V-Integer" testNumber="19"/>
			<description>Entry V with type Integer in EncryptionPublicKey should not have deprecated value 0</description>
			<test>VIntegerValue != 0</test>
			<error>
				<message>Entry V with type Integer in EncryptionPublicKey has deprecated value 0</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_2" clause="EncryptionPublicKey-V-Integer" testNumber="6"/>
			<description>Entry V with type Integer in EncryptionPublicKey shall have one of values: 0, 1</description>
			<test>VHasTypeInteger != true || VIntegerValue == 0 || VIntegerValue == 1</test>
			<error>
				<message>Entry V with type Integer in EncryptionPublicKey has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>VIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard" testNumber="1"/>
			<description>EncryptionStandard shall not contain entries except EFF, O, P, UE, R, Filter, Perms, U, OE, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'UE' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'R' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'U' &amp;&amp; elem != 'OE' &amp;&amp; elem != 'V' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'StmF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EncryptionStandard contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'UE' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'R' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'U' &amp;&amp; elem != 'OE' &amp;&amp; elem != 'V' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'StmF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard" testNumber="22"/>
			<description>EncryptionStandard shall not contain entries CF, EncryptMetadata, SubFilter, StrF, Length, KDFSalt, StmF in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EncryptMetadata' || elem == 'SubFilter' || elem == 'StrF' || elem == 'Length' || elem == 'KDFSalt' || elem == 'StmF').length == 0</test>
			<error>
				<message>EncryptionStandard contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EncryptMetadata' || elem == 'SubFilter' || elem == 'StrF' || elem == 'Length' || elem == 'KDFSalt' || elem == 'StmF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-EFF" testNumber="8"/>
			<description>Entry EFF in EncryptionStandard shall have type Name</description>
			<test>containsEFF == false || EFFHasTypeName == true</test>
			<error>
				<message>Entry EFF in EncryptionStandard has type %1 instead of type Name</message>
				<arguments>
					<argument>EFFType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-Filter" testNumber="8"/>
			<description>Entry Filter in EncryptionStandard shall have type Name</description>
			<test>containsFilter == false || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in EncryptionStandard has type %1 instead of type Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-Filter" testNumber="7"/>
			<description>Entry Filter in EncryptionStandard is required</description>
			<test>containsFilter == true</test>
			<error>
				<message>Entry Filter in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in EncryptionStandard shall have value Standard</description>
			<test>FilterHasTypeName != true || FilterNameValue == "Standard"</test>
			<error>
				<message>Entry Filter with type Name in EncryptionStandard has incorrect value %1 instead of Standard</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-O" testNumber="8"/>
			<description>Entry O in EncryptionStandard shall have type StringByte</description>
			<test>containsO == false || OHasTypeStringByte == true</test>
			<error>
				<message>Entry O in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-O" testNumber="7"/>
			<description>Entry O in EncryptionStandard is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-O-StringByte" testNumber="9"/>
			<description>Entry O with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(O) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(O) == 48))))</description>
			<test>OHasTypeStringByte != true || (((RHasTypeInteger == false || (RIntegerValue &lt;= 4)) &amp;&amp; (OStringSize == 32)) || ((RHasTypeInteger == false || ((RIntegerValue == 5) || (RIntegerValue == 6))) &amp;&amp; (OStringSize == 48)))</test>
			<error>
				<message>Entry O with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(O) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(O) == 48))))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-OE" testNumber="8"/>
			<description>Entry OE in EncryptionStandard shall have type StringByte</description>
			<test>containsOE == false || OEHasTypeStringByte == true</test>
			<error>
				<message>Entry OE in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>OEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-OE" testNumber="11"/>
			<description>Entry OE in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsOE == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry OE in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-OE-StringByte" testNumber="9"/>
			<description>Entry OE with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (fn:StringLength(OE) == 32))</description>
			<test>OEHasTypeStringByte != true || (OEStringSize == 32)</test>
			<error>
				<message>Entry OE with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (fn:StringLength(OE) == 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-P" testNumber="8"/>
			<description>Entry P in EncryptionStandard shall have type Bitmask</description>
			<test>containsP == false || PHasTypeBitmask == true</test>
			<error>
				<message>Entry P in EncryptionStandard has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-P" testNumber="7"/>
			<description>Entry P in EncryptionStandard is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-P-Bitmask" testNumber="9"/>
			<description>Entry P with type Bitmask in EncryptionStandard shall satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitsSet(7, 8) &amp;&amp; fn:BitsSet(13, 32))</description>
			<test>PHasTypeBitmask != true || (((PBitmaskValue &gt;&gt; 0 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 1 &amp; 1) == 0) &amp;&amp; ((PBitmaskValue &gt;&gt; 6 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 7 &amp; 1) == 1) &amp;&amp; ((PBitmaskValue &gt;&gt; 12 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 13 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 14 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 17 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 18 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 19 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 20 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 21 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 22 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 23 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 24 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 25 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 26 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 27 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 28 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 29 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 30 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 31 &amp; 1) == 1))</test>
			<error>
				<message>Entry P with type Bitmask in EncryptionStandard does not satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitsSet(7, 8) &amp;&amp; fn:BitsSet(13, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-Perms" testNumber="8"/>
			<description>Entry Perms in EncryptionStandard shall have type StringByte</description>
			<test>containsPerms == false || PermsHasTypeStringByte == true</test>
			<error>
				<message>Entry Perms in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PermsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-Perms" testNumber="11"/>
			<description>Entry Perms in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsPerms == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry Perms in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R" testNumber="8"/>
			<description>Entry R in EncryptionStandard shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in EncryptionStandard has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R" testNumber="7"/>
			<description>Entry R in EncryptionStandard is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R-Integer-2" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 2, if this object satisfies condition @V &lt; 2</description>
			<test>VHasTypeInteger == false || ((VIntegerValue &gt;= 2) || RIntegerValue == 2)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 2</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R-Integer-3" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 3, if this object satisfies condition (@V == 2) || (@V == 3)</description>
			<test>VHasTypeInteger == false || (((VIntegerValue != 2) &amp;&amp; (VIntegerValue != 3)) || RIntegerValue == 3)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R-Integer-4" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 4, if this object satisfies condition @V == 4</description>
			<test>VHasTypeInteger == false || ((VIntegerValue != 4) || RIntegerValue == 4)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-R-Integer" testNumber="6"/>
			<description>Entry R with type Integer in EncryptionStandard shall have one of values: 2, 3, 4</description>
			<test>RHasTypeInteger != true || RIntegerValue == 2 || RIntegerValue == 3 || RIntegerValue == 4</test>
			<error>
				<message>Entry R with type Integer in EncryptionStandard has incorrect value %1 instead of 2, 3, 4</message>
				<arguments>
					<argument>RIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-U" testNumber="8"/>
			<description>Entry U in EncryptionStandard shall have type StringByte</description>
			<test>containsU == false || UHasTypeStringByte == true</test>
			<error>
				<message>Entry U in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-U" testNumber="7"/>
			<description>Entry U in EncryptionStandard is required</description>
			<test>containsU == true</test>
			<error>
				<message>Entry U in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-U-StringByte" testNumber="9"/>
			<description>Entry U with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(U) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(U) == 48))))</description>
			<test>UHasTypeStringByte != true || (((RHasTypeInteger == false || (RIntegerValue &lt;= 4)) &amp;&amp; (UStringSize == 32)) || ((RHasTypeInteger == false || ((RIntegerValue == 5) || (RIntegerValue == 6))) &amp;&amp; (UStringSize == 48)))</test>
			<error>
				<message>Entry U with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(U) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(U) == 48))))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-UE" testNumber="8"/>
			<description>Entry UE in EncryptionStandard shall have type StringByte</description>
			<test>containsUE == false || UEHasTypeStringByte == true</test>
			<error>
				<message>Entry UE in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-UE" testNumber="11"/>
			<description>Entry UE in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsUE == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry UE in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-V" testNumber="8"/>
			<description>Entry V in EncryptionStandard shall have type Integer</description>
			<test>containsV == false || VHasTypeInteger == true</test>
			<error>
				<message>Entry V in EncryptionStandard has type %1 instead of type Integer</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-V" testNumber="7"/>
			<description>Entry V in EncryptionStandard is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-V-Integer" testNumber="19"/>
			<description>Entry V with type Integer in EncryptionStandard should not have deprecated value 0</description>
			<test>VIntegerValue != 0</test>
			<error>
				<message>Entry V with type Integer in EncryptionStandard has deprecated value 0</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_2" clause="EncryptionStandard-V-Integer" testNumber="6"/>
			<description>Entry V with type Integer in EncryptionStandard shall have one of values: 0, 1</description>
			<test>VHasTypeInteger != true || VIntegerValue == 0 || VIntegerValue == 1</test>
			<error>
				<message>Entry V with type Integer in EncryptionStandard has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>VIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFDDictEntry">
			<id specification="PDF_1_2" clause="FDDictEntry" testNumber="8"/>
			<description>Entry in FDDict shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in FDDict has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field" testNumber="1"/>
			<description>Field shall not contain entries except Ff, T, Parent, Kids</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Kids' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Field contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'Kids' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field" testNumber="22"/>
			<description>Field shall not contain entries AA, TU, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'TM').length == 0</test>
			<error>
				<message>Field contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-Ff" testNumber="8"/>
			<description>Entry Ff in Field shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in Field has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in Field shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in Field does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-Kids" testNumber="8"/>
			<description>Entry Kids in Field shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in Field has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in Field shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in Field is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-Parent" testNumber="8"/>
			<description>Entry Parent in Field shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in Field has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_2" clause="Field-T" testNumber="8"/>
			<description>Entry T in Field shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in Field has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox" testNumber="1"/>
			<description>FieldBtnCheckbox shall not contain entries except Ff, Parent, FT, Kids, Q, DV, T, V, DA</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox" testNumber="22"/>
			<description>FieldBtnCheckbox shall not contain entries AA, TU, RV, DS, Opt, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'Opt' || elem == 'TM').length == 0</test>
			<error>
				<message>FieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'Opt' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnCheckbox shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnCheckbox has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnCheckbox is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnCheckbox shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnCheckbox shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnCheckbox is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnCheckbox shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnCheckbox has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnCheckbox shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnCheckbox shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnCheckbox shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnCheckbox is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnCheckbox shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnCheckbox shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnCheckbox has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnCheckbox shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnCheckbox has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-T" testNumber="8"/>
			<description>Entry T in FieldBtnCheckbox shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_2" clause="FieldBtnCheckbox-V" testNumber="8"/>
			<description>Entry V in FieldBtnCheckbox shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush" testNumber="1"/>
			<description>FieldBtnPush shall not contain entries except Ff, Parent, FT, Kids, Q, DV, T, V, DA</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush" testNumber="22"/>
			<description>FieldBtnPush shall not contain entries AA, TU, RV, DS, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'TM').length == 0</test>
			<error>
				<message>FieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnPush shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnPush has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnPush is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnPush shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnPush shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnPush is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnPush shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnPush has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnPush shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnPush shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnPush shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnPush is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnPush shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnPush shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnPush has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnPush shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnPush has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-T" testNumber="8"/>
			<description>Entry T in FieldBtnPush shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_2" clause="FieldBtnPush-V" testNumber="8"/>
			<description>Entry V in FieldBtnPush shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio" testNumber="1"/>
			<description>FieldBtnRadio shall not contain entries except Ff, Parent, FT, Kids, Q, DV, T, V, DA</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio" testNumber="22"/>
			<description>FieldBtnRadio shall not contain entries AA, TU, RV, DS, Opt, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'Opt' || elem == 'TM').length == 0</test>
			<error>
				<message>FieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'Opt' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnRadio shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnRadio has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnRadio is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnRadio shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnRadio shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnRadio is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnRadio shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnRadio has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnRadio shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnRadio shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnRadio shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnRadio is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnRadio shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnRadio shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnRadio has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnRadio shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnRadio has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-T" testNumber="8"/>
			<description>Entry T in FieldBtnRadio shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_2" clause="FieldBtnRadio-V" testNumber="8"/>
			<description>Entry V in FieldBtnRadio shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice" testNumber="1"/>
			<description>FieldChoice shall not contain entries except Ff, Parent, FT, Kids, Q, DV, Opt, T, TI, V, DA</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'I' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'I' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice" testNumber="22"/>
			<description>FieldChoice shall not contain entries AA, TU, RV, I, DS, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'I' || elem == 'DS' || elem == 'TM').length == 0</test>
			<error>
				<message>FieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'I' || elem == 'DS' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-DA" testNumber="8"/>
			<description>Entry DA in FieldChoice shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldChoice has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-DA" testNumber="7"/>
			<description>Entry DA in FieldChoice is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-DV" testNumber="8"/>
			<description>Entry DV in FieldChoice shall have one of types: Array, StringText</description>
			<test>containsDV == false || DVHasTypeArray == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in FieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-FT" testNumber="8"/>
			<description>Entry FT in FieldChoice shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-FT" testNumber="7"/>
			<description>Entry FT in FieldChoice is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldChoice shall have value Ch</description>
			<test>FTHasTypeName != true || FTNameValue == "Ch"</test>
			<error>
				<message>Entry FT with type Name in FieldChoice has incorrect value %1 instead of Ch</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Ff" testNumber="8"/>
			<description>Entry Ff in FieldChoice shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(22, 23) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(22, 23) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Kids" testNumber="8"/>
			<description>Entry Kids in FieldChoice shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Opt" testNumber="8"/>
			<description>Entry Opt in FieldChoice shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in FieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldChoice shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldChoice is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Parent" testNumber="8"/>
			<description>Entry Parent in FieldChoice shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Q" testNumber="8"/>
			<description>Entry Q in FieldChoice shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldChoice shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldChoice has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-T" testNumber="8"/>
			<description>Entry T in FieldChoice shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-TI" testNumber="8"/>
			<description>Entry TI in FieldChoice shall have type Integer</description>
			<test>containsTI == false || TIHasTypeInteger == true</test>
			<error>
				<message>Entry TI in FieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>TIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-TI-Integer" testNumber="14"/>
			<description>Entry TI with type Integer in FieldChoice shall satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</description>
			<test>TIHasTypeInteger != true || (TIIntegerValue &gt;= 0) &amp;&amp; (OptHasTypeArray == false || (TIIntegerValue &lt; OptArraySize))</test>
			<error>
				<message>Entry TI with type Integer in FieldChoice does not satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_2" clause="FieldChoice-V" testNumber="8"/>
			<description>Entry V in FieldChoice shall have one of types: Array, StringText</description>
			<test>containsV == false || VHasTypeArray == true || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in FieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx" testNumber="1"/>
			<description>FieldTx shall not contain entries except Ff, MaxLen, Parent, FT, Kids, Q, DV, T, V, DA</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'V' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'DA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx" testNumber="22"/>
			<description>FieldTx shall not contain entries AA, TU, RV, DS, TM in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'TM').length == 0</test>
			<error>
				<message>FieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AA' || elem == 'TU' || elem == 'RV' || elem == 'DS' || elem == 'TM').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-DA" testNumber="8"/>
			<description>Entry DA in FieldTx shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldTx has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-DA" testNumber="7"/>
			<description>Entry DA in FieldTx is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-DV" testNumber="8"/>
			<description>Entry DV in FieldTx shall have one of types: Stream, StringText</description>
			<test>containsDV == false || DVHasTypeStream == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in FieldTx has type %1 instead of one of types: Stream, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-DV-Stream" testNumber="10"/>
			<description>Entry DV with type Stream in FieldTx shall be indirect</description>
			<test>DVHasTypeStream != true || isDVIndirect == true</test>
			<error>
				<message>Entry DV with type Stream in FieldTx is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-FT" testNumber="8"/>
			<description>Entry FT in FieldTx shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-FT" testNumber="7"/>
			<description>Entry FT in FieldTx is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldTx shall have value Tx</description>
			<test>FTHasTypeName != true || FTNameValue == "Tx"</test>
			<error>
				<message>Entry FT with type Name in FieldTx has incorrect value %1 instead of Tx</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Ff" testNumber="8"/>
			<description>Entry Ff in FieldTx shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldTx shall satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(23, 24) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldTx does not satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(23, 24) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Kids" testNumber="8"/>
			<description>Entry Kids in FieldTx shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-MaxLen" testNumber="8"/>
			<description>Entry MaxLen in FieldTx shall have type Integer</description>
			<test>containsMaxLen == false || MaxLenHasTypeInteger == true</test>
			<error>
				<message>Entry MaxLen in FieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>MaxLenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-MaxLen-Integer" testNumber="9"/>
			<description>Entry MaxLen with type Integer in FieldTx shall satisfy special case: fn:Eval(@MaxLen &gt;= 0)</description>
			<test>MaxLenHasTypeInteger != true || (MaxLenIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry MaxLen with type Integer in FieldTx does not satisfy special case: fn:Eval(@MaxLen &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldTx shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldTx is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Parent" testNumber="8"/>
			<description>Entry Parent in FieldTx shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Q" testNumber="8"/>
			<description>Entry Q in FieldTx shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldTx shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldTx has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-T" testNumber="8"/>
			<description>Entry T in FieldTx shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_2" clause="FieldTx-V" testNumber="8"/>
			<description>Entry V in FieldTx shall have type StringText</description>
			<test>containsV == false || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification" testNumber="1"/>
			<description>FileSpecification shall not contain entries except Unix, F, DOS, FS, Mac, V, ID</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Unix' &amp;&amp; elem != 'EF' &amp;&amp; elem != 'CI' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'DOS' &amp;&amp; elem != 'EP' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'AFRelationship' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'UF' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'RF' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ID' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileSpecification contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Unix' &amp;&amp; elem != 'EF' &amp;&amp; elem != 'CI' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'DOS' &amp;&amp; elem != 'EP' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'AFRelationship' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'UF' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'RF' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ID' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification" testNumber="22"/>
			<description>FileSpecification shall not contain entries EF, CI, Thumb, EP, AFRelationship, Desc, UF, Type, RF in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'EF' || elem == 'CI' || elem == 'Thumb' || elem == 'EP' || elem == 'AFRelationship' || elem == 'Desc' || elem == 'UF' || elem == 'Type' || elem == 'RF').length == 0</test>
			<error>
				<message>FileSpecification contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'EF' || elem == 'CI' || elem == 'Thumb' || elem == 'EP' || elem == 'AFRelationship' || elem == 'Desc' || elem == 'UF' || elem == 'Type' || elem == 'RF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-DOS" testNumber="8"/>
			<description>Entry DOS in FileSpecification shall have type StringByte</description>
			<test>containsDOS == false || DOSHasTypeStringByte == true</test>
			<error>
				<message>Entry DOS in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DOSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-F" testNumber="8"/>
			<description>Entry F in FileSpecification shall have type String</description>
			<test>containsF == false || FHasTypeString == true</test>
			<error>
				<message>Entry F in FileSpecification has type %1 instead of type String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-F" testNumber="11"/>
			<description>Entry F in FileSpecification is required, when fn:Not(fn:IsPresent(DOS)) &amp;&amp; fn:Not(fn:IsPresent(Mac)) &amp;&amp; fn:Not(fn:IsPresent(Unix))</description>
			<test>containsF == true || ((containsDOS == true) || (containsMac == true) || (containsUnix == true))</test>
			<error>
				<message>Entry F in FileSpecification is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-FS" testNumber="8"/>
			<description>Entry FS in FileSpecification shall have type Name</description>
			<test>containsFS == false || FSHasTypeName == true</test>
			<error>
				<message>Entry FS in FileSpecification has type %1 instead of type Name</message>
				<arguments>
					<argument>FSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-ID" testNumber="8"/>
			<description>Entry ID in FileSpecification shall have type Array</description>
			<test>containsID == false || entryIDHasTypeArray == true</test>
			<error>
				<message>Entry ID in FileSpecification has type %1 instead of type Array</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-Mac" testNumber="8"/>
			<description>Entry Mac in FileSpecification shall have type StringByte</description>
			<test>containsMac == false || MacHasTypeStringByte == true</test>
			<error>
				<message>Entry Mac in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>MacType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-Unix" testNumber="8"/>
			<description>Entry Unix in FileSpecification shall have type StringByte</description>
			<test>containsUnix == false || UnixHasTypeStringByte == true</test>
			<error>
				<message>Entry Unix in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UnixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_2" clause="FileSpecification-V" testNumber="8"/>
			<description>Entry V in FileSpecification shall have type Boolean</description>
			<test>containsV == false || VHasTypeBoolean == true</test>
			<error>
				<message>Entry V in FileSpecification has type %1 instead of type Boolean</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer" testNumber="1"/>
			<description>FileTrailer shall not contain entries except Root, Prev, Size, ID, Info, Encrypt</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'XRefStm' &amp;&amp; elem != 'AuthCode' &amp;&amp; elem != 'Root' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'Encrypt' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileTrailer contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'XRefStm' &amp;&amp; elem != 'AuthCode' &amp;&amp; elem != 'Root' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'Encrypt' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer" testNumber="22"/>
			<description>FileTrailer shall not contain entries XRefStm, AuthCode in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'XRefStm' || elem == 'AuthCode').length == 0</test>
			<error>
				<message>FileTrailer contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'XRefStm' || elem == 'AuthCode').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Encrypt-Dictionary" testNumber="17"/>
			<description>Entry Encrypt with type Dictionary in FileTrailer shall be one of objects EncryptionStandard, EncryptionPublicKey</description>
			<test>EncryptHasTypeDictionary != true || Encrypt_size == 1</test>
			<error>
				<message>Entry Encrypt with type Dictionary in FileTrailer is not one of objects EncryptionStandard, EncryptionPublicKey</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Encrypt" testNumber="8"/>
			<description>Entry Encrypt in FileTrailer shall have type Dictionary</description>
			<test>containsEncrypt == false || EncryptHasTypeDictionary == true</test>
			<error>
				<message>Entry Encrypt in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EncryptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-ID" testNumber="8"/>
			<description>Entry ID in FileTrailer shall have type Array</description>
			<test>containsID == false || entryIDHasTypeArray == true</test>
			<error>
				<message>Entry ID in FileTrailer has type %1 instead of type Array</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-ID" testNumber="11"/>
			<description>Entry ID in FileTrailer is required, when fn:IsPresent(Encrypt)</description>
			<test>containsID == true || (containsEncrypt != true)</test>
			<error>
				<message>Entry ID in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-ID-Array" testNumber="16"/>
			<description>If entry ID with type Array in FileTrailer satisfies condition fn:IsPresent(Encrypt), it shall be direct</description>
			<test>entryIDHasTypeArray != true || (isentryIDIndirect == false || (containsEncrypt != true))</test>
			<error>
				<message>Entry ID with type Array in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Info" testNumber="8"/>
			<description>Entry Info in FileTrailer shall have type Dictionary</description>
			<test>containsInfo == false || InfoHasTypeDictionary == true</test>
			<error>
				<message>Entry Info in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>InfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Info-Dictionary" testNumber="10"/>
			<description>Entry Info with type Dictionary in FileTrailer shall be indirect</description>
			<test>InfoHasTypeDictionary != true || isInfoIndirect == true</test>
			<error>
				<message>Entry Info with type Dictionary in FileTrailer is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Prev" testNumber="8"/>
			<description>Entry Prev in FileTrailer shall have type Integer</description>
			<test>containsPrev == false || PrevHasTypeInteger == true</test>
			<error>
				<message>Entry Prev in FileTrailer has type %1 instead of type Integer</message>
				<arguments>
					<argument>PrevType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Prev-Integer" testNumber="10"/>
			<description>Entry Prev with type Integer in FileTrailer shall be direct</description>
			<test>PrevHasTypeInteger != true || isPrevIndirect == false</test>
			<error>
				<message>Entry Prev with type Integer in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Prev-Integer" testNumber="14"/>
			<description>Entry Prev with type Integer in FileTrailer shall satisfy possible value predicate: fn:Eval((@Prev &gt;= 0) &amp;&amp; (@Prev &lt;= fn:FileSize()))</description>
			<test>PrevHasTypeInteger != true || (PrevIntegerValue &gt;= 0) &amp;&amp; (PrevIntegerValue &lt;= fileSize)</test>
			<error>
				<message>Entry Prev with type Integer in FileTrailer does not satisfy possible value predicate: fn:Eval((@Prev &gt;= 0) &amp;&amp; (@Prev &lt;= fn:FileSize()))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Root" testNumber="8"/>
			<description>Entry Root in FileTrailer shall have type Dictionary</description>
			<test>containsRoot == false || RootHasTypeDictionary == true</test>
			<error>
				<message>Entry Root in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RootType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Root" testNumber="7"/>
			<description>Entry Root in FileTrailer is required</description>
			<test>containsRoot == true</test>
			<error>
				<message>Entry Root in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Root-Dictionary" testNumber="10"/>
			<description>Entry Root with type Dictionary in FileTrailer shall be indirect</description>
			<test>RootHasTypeDictionary != true || isRootIndirect == true</test>
			<error>
				<message>Entry Root with type Dictionary in FileTrailer is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Size" testNumber="8"/>
			<description>Entry Size in FileTrailer shall have type Integer</description>
			<test>containsSize == false || SizeHasTypeInteger == true</test>
			<error>
				<message>Entry Size in FileTrailer has type %1 instead of type Integer</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Size" testNumber="7"/>
			<description>Entry Size in FileTrailer is required</description>
			<test>containsSize == true</test>
			<error>
				<message>Entry Size in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Size-Integer" testNumber="10"/>
			<description>Entry Size with type Integer in FileTrailer shall be direct</description>
			<test>SizeHasTypeInteger != true || isSizeIndirect == false</test>
			<error>
				<message>Entry Size with type Integer in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_2" clause="FileTrailer-Size-Integer" testNumber="14"/>
			<description>Entry Size with type Integer in FileTrailer shall satisfy possible value predicate: fn:Eval(@Size &gt; 0)</description>
			<test>SizeHasTypeInteger != true || SizeIntegerValue &gt; 0</test>
			<error>
				<message>Entry Size with type Integer in FileTrailer does not satisfy possible value predicate: fn:Eval(@Size &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode" testNumber="1"/>
			<description>FilterCCITTFaxDecode shall not contain entries except BlackIs1, Blackls1, EndOfBlock, EndOfLine, DamagedRowsBeforeError, Columns, K, EncodedByteAlign, Rows</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BlackIs1' &amp;&amp; elem != 'Blackls1' &amp;&amp; elem != 'EndOfBlock' &amp;&amp; elem != 'EndOfLine' &amp;&amp; elem != 'DamagedRowsBeforeError' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'K' &amp;&amp; elem != 'EncodedByteAlign' &amp;&amp; elem != 'Rows' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterCCITTFaxDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BlackIs1' &amp;&amp; elem != 'Blackls1' &amp;&amp; elem != 'EndOfBlock' &amp;&amp; elem != 'EndOfLine' &amp;&amp; elem != 'DamagedRowsBeforeError' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'K' &amp;&amp; elem != 'EncodedByteAlign' &amp;&amp; elem != 'Rows' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-BlackIs1" testNumber="8"/>
			<description>Entry BlackIs1 in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsBlackIs1 == false || BlackIs1HasTypeBoolean == true</test>
			<error>
				<message>Entry BlackIs1 in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>BlackIs1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Blackls1" testNumber="8"/>
			<description>Entry Blackls1 in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsBlackls1 == false || Blackls1HasTypeBoolean == true</test>
			<error>
				<message>Entry Blackls1 in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>Blackls1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Blackls1" testNumber="23"/>
			<description>Entry Blackls1 in FilterCCITTFaxDecode can only be present, if satisfy predicate fn:Extension(Malforms)</description>
			<test>containsBlackls1 == false || hasExtensionMalforms == true</test>
			<error>
				<message>Entry Blackls1 in FilterCCITTFaxDecode is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Columns-Integer" testNumber="14"/>
			<description>Entry Columns with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@Columns &gt;= 0)</description>
			<test>ColumnsHasTypeInteger != true || ColumnsIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Columns with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@Columns &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-DamagedRowsBeforeError" testNumber="8"/>
			<description>Entry DamagedRowsBeforeError in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsDamagedRowsBeforeError == false || DamagedRowsBeforeErrorHasTypeInteger == true</test>
			<error>
				<message>Entry DamagedRowsBeforeError in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>DamagedRowsBeforeErrorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-DamagedRowsBeforeError-Integer" testNumber="14"/>
			<description>Entry DamagedRowsBeforeError with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@DamagedRowsBeforeError &gt;= 0)</description>
			<test>DamagedRowsBeforeErrorHasTypeInteger != true || DamagedRowsBeforeErrorIntegerValue &gt;= 0</test>
			<error>
				<message>Entry DamagedRowsBeforeError with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@DamagedRowsBeforeError &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-EncodedByteAlign" testNumber="8"/>
			<description>Entry EncodedByteAlign in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEncodedByteAlign == false || EncodedByteAlignHasTypeBoolean == true</test>
			<error>
				<message>Entry EncodedByteAlign in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EncodedByteAlignType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-EndOfBlock" testNumber="8"/>
			<description>Entry EndOfBlock in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEndOfBlock == false || EndOfBlockHasTypeBoolean == true</test>
			<error>
				<message>Entry EndOfBlock in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EndOfBlockType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-EndOfLine" testNumber="8"/>
			<description>Entry EndOfLine in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEndOfLine == false || EndOfLineHasTypeBoolean == true</test>
			<error>
				<message>Entry EndOfLine in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EndOfLineType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-K" testNumber="8"/>
			<description>Entry K in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsK == false || KHasTypeInteger == true</test>
			<error>
				<message>Entry K in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Rows" testNumber="8"/>
			<description>Entry Rows in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsRows == false || RowsHasTypeInteger == true</test>
			<error>
				<message>Entry Rows in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>RowsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_2" clause="FilterCCITTFaxDecode-Rows-Integer" testNumber="14"/>
			<description>Entry Rows with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@Rows &gt;= 0)</description>
			<test>RowsHasTypeInteger != true || RowsIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Rows with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@Rows &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_2" clause="FilterDCTDecode" testNumber="1"/>
			<description>FilterDCTDecode shall not contain entries except ColorTransform</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ColorTransform' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterDCTDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ColorTransform' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_2" clause="FilterDCTDecode-ColorTransform" testNumber="8"/>
			<description>Entry ColorTransform in FilterDCTDecode shall have type Integer</description>
			<test>containsColorTransform == false || ColorTransformHasTypeInteger == true</test>
			<error>
				<message>Entry ColorTransform in FilterDCTDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorTransformType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_2" clause="FilterDCTDecode-ColorTransform-Integer" testNumber="6"/>
			<description>Entry ColorTransform with type Integer in FilterDCTDecode shall have one of values: 0, 1</description>
			<test>ColorTransformHasTypeInteger != true || ColorTransformIntegerValue == 0 || ColorTransformIntegerValue == 1</test>
			<error>
				<message>Entry ColorTransform with type Integer in FilterDCTDecode has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>ColorTransformIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode" testNumber="1"/>
			<description>FilterFlateDecode shall not contain entries except Colors, Predictor, Columns, BitsPerComponent</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Colors' &amp;&amp; elem != 'Predictor' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterFlateDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Colors' &amp;&amp; elem != 'Predictor' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in FilterFlateDecode shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in FilterFlateDecode shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in FilterFlateDecode has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-Colors" testNumber="8"/>
			<description>Entry Colors in FilterFlateDecode shall have type Integer</description>
			<test>containsColors == false || ColorsHasTypeInteger == true</test>
			<error>
				<message>Entry Colors in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-Colors-Integer" testNumber="14"/>
			<description>Entry Colors with type Integer in FilterFlateDecode shall satisfy possible value predicate: fn:Eval((@Colors &gt;= 1) &amp;&amp; fn:Eval(@Colors &lt;= 4))</description>
			<test>ColorsHasTypeInteger != true || (ColorsIntegerValue &gt;= 1) &amp;&amp; ColorsIntegerValue &lt;= 4</test>
			<error>
				<message>Entry Colors with type Integer in FilterFlateDecode does not satisfy possible value predicate: fn:Eval((@Colors &gt;= 1) &amp;&amp; fn:Eval(@Colors &lt;= 4))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterFlateDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-Predictor" testNumber="8"/>
			<description>Entry Predictor in FilterFlateDecode shall have type Integer</description>
			<test>containsPredictor == false || PredictorHasTypeInteger == true</test>
			<error>
				<message>Entry Predictor in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>PredictorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_2" clause="FilterFlateDecode-Predictor-Integer" testNumber="6"/>
			<description>Entry Predictor with type Integer in FilterFlateDecode shall have one of values: 11, 1, 12, 2, 13, 14, 15, 10</description>
			<test>PredictorHasTypeInteger != true || PredictorIntegerValue == 1 || PredictorIntegerValue == 2 || PredictorIntegerValue == 10 || PredictorIntegerValue == 11 || PredictorIntegerValue == 12 || PredictorIntegerValue == 13 || PredictorIntegerValue == 14 || PredictorIntegerValue == 15</test>
			<error>
				<message>Entry Predictor with type Integer in FilterFlateDecode has incorrect value %1 instead of 11, 1, 12, 2, 13, 14, 15, 10</message>
				<arguments>
					<argument>PredictorIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode" testNumber="1"/>
			<description>FilterLZWDecode shall not contain entries except Colors, Predictor, Columns, EarlyChange, BitsPerComponent</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Colors' &amp;&amp; elem != 'Predictor' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'EarlyChange' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterLZWDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Colors' &amp;&amp; elem != 'Predictor' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'EarlyChange' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in FilterLZWDecode shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in FilterLZWDecode shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in FilterLZWDecode has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-Colors" testNumber="8"/>
			<description>Entry Colors in FilterLZWDecode shall have type Integer</description>
			<test>containsColors == false || ColorsHasTypeInteger == true</test>
			<error>
				<message>Entry Colors in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-Colors-Integer" testNumber="14"/>
			<description>Entry Colors with type Integer in FilterLZWDecode shall satisfy possible value predicate: fn:Eval((@Colors &gt;= 1) &amp;&amp; fn:Eval(@Colors &lt;= 4))</description>
			<test>ColorsHasTypeInteger != true || (ColorsIntegerValue &gt;= 1) &amp;&amp; ColorsIntegerValue &lt;= 4</test>
			<error>
				<message>Entry Colors with type Integer in FilterLZWDecode does not satisfy possible value predicate: fn:Eval((@Colors &gt;= 1) &amp;&amp; fn:Eval(@Colors &lt;= 4))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterLZWDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-EarlyChange" testNumber="8"/>
			<description>Entry EarlyChange in FilterLZWDecode shall have type Integer</description>
			<test>containsEarlyChange == false || EarlyChangeHasTypeInteger == true</test>
			<error>
				<message>Entry EarlyChange in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>EarlyChangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-EarlyChange-Integer" testNumber="6"/>
			<description>Entry EarlyChange with type Integer in FilterLZWDecode shall have one of values: 0, 1</description>
			<test>EarlyChangeHasTypeInteger != true || EarlyChangeIntegerValue == 0 || EarlyChangeIntegerValue == 1</test>
			<error>
				<message>Entry EarlyChange with type Integer in FilterLZWDecode has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>EarlyChangeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-Predictor" testNumber="8"/>
			<description>Entry Predictor in FilterLZWDecode shall have type Integer</description>
			<test>containsPredictor == false || PredictorHasTypeInteger == true</test>
			<error>
				<message>Entry Predictor in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>PredictorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_2" clause="FilterLZWDecode-Predictor-Integer" testNumber="6"/>
			<description>Entry Predictor with type Integer in FilterLZWDecode shall have one of values: 11, 1, 12, 2, 13, 14, 15, 10</description>
			<test>PredictorHasTypeInteger != true || PredictorIntegerValue == 1 || PredictorIntegerValue == 2 || PredictorIntegerValue == 10 || PredictorIntegerValue == 11 || PredictorIntegerValue == 12 || PredictorIntegerValue == 13 || PredictorIntegerValue == 14 || PredictorIntegerValue == 15</test>
			<error>
				<message>Entry Predictor with type Integer in FilterLZWDecode has incorrect value %1 instead of 11, 1, 12, 2, 13, 14, 15, 10</message>
				<arguments>
					<argument>PredictorIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0" testNumber="1"/>
			<description>FontCIDType0 shall not contain entries except ToUnicode, Type, DW, W, BaseFont, CIDSystemInfo, W2, Subtype, DW2, CIDToGIDMap, FontDescriptor</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'W' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'W2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'W' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'W2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontCIDType0 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontCIDType0 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in FontCIDType0 shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in FontCIDType0 is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-CIDToGIDMap" testNumber="8"/>
			<description>Entry CIDToGIDMap in FontCIDType0 shall have one of types: Name, Stream</description>
			<test>containsCIDToGIDMap == false || CIDToGIDMapHasTypeName == true || CIDToGIDMapHasTypeStream == true</test>
			<error>
				<message>Entry CIDToGIDMap in FontCIDType0 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>CIDToGIDMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-CIDToGIDMap-Name" testNumber="6"/>
			<description>Entry CIDToGIDMap with type Name in FontCIDType0 shall have value Identity</description>
			<test>CIDToGIDMapHasTypeName != true || CIDToGIDMapNameValue == "Identity"</test>
			<error>
				<message>Entry CIDToGIDMap with type Name in FontCIDType0 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>CIDToGIDMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-CIDToGIDMap-Stream" testNumber="10"/>
			<description>Entry CIDToGIDMap with type Stream in FontCIDType0 shall be indirect</description>
			<test>CIDToGIDMapHasTypeStream != true || isCIDToGIDMapIndirect == true</test>
			<error>
				<message>Entry CIDToGIDMap with type Stream in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-DW" testNumber="8"/>
			<description>Entry DW in FontCIDType0 shall have type Number</description>
			<test>containsDW == false || DWHasTypeNumber == true</test>
			<error>
				<message>Entry DW in FontCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>DWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-DW2" testNumber="8"/>
			<description>Entry DW2 in FontCIDType0 shall have type Array</description>
			<test>containsDW2 == false || DW2HasTypeArray == true</test>
			<error>
				<message>Entry DW2 in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DW2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontCIDType0 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-FontDescriptor" testNumber="7"/>
			<description>Entry FontDescriptor in FontCIDType0 is required</description>
			<test>containsFontDescriptor == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontCIDType0 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontCIDType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontCIDType0 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontCIDType0 shall have value CIDFontType0</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType0"</test>
			<error>
				<message>Entry Subtype with type Name in FontCIDType0 has incorrect value %1 instead of CIDFontType0</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontCIDType0 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontCIDType0 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Type" testNumber="8"/>
			<description>Entry Type in FontCIDType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Type" testNumber="7"/>
			<description>Entry Type in FontCIDType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontCIDType0 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontCIDType0 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-W" testNumber="8"/>
			<description>Entry W in FontCIDType0 shall have type Array</description>
			<test>containsW == false || WHasTypeArray == true</test>
			<error>
				<message>Entry W in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_2" clause="FontCIDType0-W2" testNumber="8"/>
			<description>Entry W2 in FontCIDType0 shall have type Array</description>
			<test>containsW2 == false || W2HasTypeArray == true</test>
			<error>
				<message>Entry W2 in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>W2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2" testNumber="1"/>
			<description>FontCIDType2 shall not contain entries except ToUnicode, Type, DW, W, BaseFont, CIDSystemInfo, W2, Subtype, DW2, CIDToGIDMap, FontDescriptor</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'W' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'W2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'W' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'W2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontCIDType2 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontCIDType2 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in FontCIDType2 shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in FontCIDType2 is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-CIDToGIDMap" testNumber="8"/>
			<description>Entry CIDToGIDMap in FontCIDType2 shall have one of types: Name, Stream</description>
			<test>containsCIDToGIDMap == false || CIDToGIDMapHasTypeName == true || CIDToGIDMapHasTypeStream == true</test>
			<error>
				<message>Entry CIDToGIDMap in FontCIDType2 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>CIDToGIDMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-CIDToGIDMap-Name" testNumber="6"/>
			<description>Entry CIDToGIDMap with type Name in FontCIDType2 shall have value Identity</description>
			<test>CIDToGIDMapHasTypeName != true || CIDToGIDMapNameValue == "Identity"</test>
			<error>
				<message>Entry CIDToGIDMap with type Name in FontCIDType2 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>CIDToGIDMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-CIDToGIDMap-Stream" testNumber="10"/>
			<description>Entry CIDToGIDMap with type Stream in FontCIDType2 shall be indirect</description>
			<test>CIDToGIDMapHasTypeStream != true || isCIDToGIDMapIndirect == true</test>
			<error>
				<message>Entry CIDToGIDMap with type Stream in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-DW" testNumber="8"/>
			<description>Entry DW in FontCIDType2 shall have type Number</description>
			<test>containsDW == false || DWHasTypeNumber == true</test>
			<error>
				<message>Entry DW in FontCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>DWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-DW2" testNumber="8"/>
			<description>Entry DW2 in FontCIDType2 shall have type Array</description>
			<test>containsDW2 == false || DW2HasTypeArray == true</test>
			<error>
				<message>Entry DW2 in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>DW2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontCIDType2 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-FontDescriptor" testNumber="7"/>
			<description>Entry FontDescriptor in FontCIDType2 is required</description>
			<test>containsFontDescriptor == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontCIDType2 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontCIDType2 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontCIDType2 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontCIDType2 shall have value CIDFontType2</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType2"</test>
			<error>
				<message>Entry Subtype with type Name in FontCIDType2 has incorrect value %1 instead of CIDFontType2</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontCIDType2 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontCIDType2 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Type" testNumber="8"/>
			<description>Entry Type in FontCIDType2 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Type" testNumber="7"/>
			<description>Entry Type in FontCIDType2 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontCIDType2 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontCIDType2 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-W" testNumber="8"/>
			<description>Entry W in FontCIDType2 shall have type Array</description>
			<test>containsW == false || WHasTypeArray == true</test>
			<error>
				<message>Entry W in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_2" clause="FontCIDType2-W2" testNumber="8"/>
			<description>Entry W2 in FontCIDType2 shall have type Array</description>
			<test>containsW2 == false || W2HasTypeArray == true</test>
			<error>
				<message>Entry W2 in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>W2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0" testNumber="1"/>
			<description>FontDescriptorCIDType0 shall not contain entries except FontBBox, StemV, CapHeight, Flags, FontFile3, Type, ItalicAngle, Ascent, FontFile, MaxWidth, FontName, StemH, Style, CIDSet, AvgWidth, Descent, FD, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0" testNumber="22"/>
			<description>FontDescriptorCIDType0 shall not contain entries FontFamily, FontStretch, Lang, FontWeight in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'Lang' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'Lang' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorCIDType0 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-CIDSet" testNumber="8"/>
			<description>Entry CIDSet in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsCIDSet == false || CIDSetHasTypeStream == true</test>
			<error>
				<message>Entry CIDSet in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>CIDSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-CIDSet-Stream" testNumber="10"/>
			<description>Entry CIDSet with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>CIDSetHasTypeStream != true || isCIDSetIndirect == true</test>
			<error>
				<message>Entry CIDSet with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorCIDType0 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorCIDType0 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorCIDType0 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FD" testNumber="8"/>
			<description>Entry FD in FontDescriptorCIDType0 shall have type Dictionary</description>
			<test>containsFD == false || FDHasTypeDictionary == true</test>
			<error>
				<message>Entry FD in FontDescriptorCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorCIDType0 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType0 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorCIDType0 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorCIDType0 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType0 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorCIDType0 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile3 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile3" testNumber="8"/>
			<description>Entry FontFile3 in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsFontFile3 == false || FontFile3HasTypeStream == true</test>
			<error>
				<message>Entry FontFile3 in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile3-Stream" testNumber="10"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>FontFile3HasTypeStream != true || isFontFile3Indirect == true</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontFile3-Stream" testNumber="9"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile3HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorCIDType0 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorCIDType0 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType0 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorCIDType0 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Style" testNumber="8"/>
			<description>Entry Style in FontDescriptorCIDType0 shall have type Dictionary</description>
			<test>containsStyle == false || StyleHasTypeDictionary == true</test>
			<error>
				<message>Entry Style in FontDescriptorCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>StyleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorCIDType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorCIDType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorCIDType0 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorCIDType0 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType0-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2" testNumber="1"/>
			<description>FontDescriptorCIDType2 shall not contain entries except FontFile2, FontBBox, StemV, CapHeight, Flags, Type, ItalicAngle, Ascent, FontFile, MaxWidth, FontName, StemH, Style, CIDSet, AvgWidth, Descent, FD, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2" testNumber="22"/>
			<description>FontDescriptorCIDType2 shall not contain entries FontFamily, FontStretch, Lang, FontWeight in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'Lang' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'Lang' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorCIDType2 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-CIDSet" testNumber="8"/>
			<description>Entry CIDSet in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsCIDSet == false || CIDSetHasTypeStream == true</test>
			<error>
				<message>Entry CIDSet in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>CIDSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-CIDSet-Stream" testNumber="10"/>
			<description>Entry CIDSet with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>CIDSetHasTypeStream != true || isCIDSetIndirect == true</test>
			<error>
				<message>Entry CIDSet with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorCIDType2 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorCIDType2 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorCIDType2 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FD" testNumber="8"/>
			<description>Entry FD in FontDescriptorCIDType2 shall have type Dictionary</description>
			<test>containsFD == false || FDHasTypeDictionary == true</test>
			<error>
				<message>Entry FD in FontDescriptorCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorCIDType2 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType2 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorCIDType2 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorCIDType2 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType2 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorCIDType2 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile2 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile2" testNumber="8"/>
			<description>Entry FontFile2 in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsFontFile2 == false || FontFile2HasTypeStream == true</test>
			<error>
				<message>Entry FontFile2 in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile2-Stream" testNumber="10"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>FontFile2HasTypeStream != true || isFontFile2Indirect == true</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontFile2-Stream" testNumber="9"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile2HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorCIDType2 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorCIDType2 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType2 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorCIDType2 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Style" testNumber="8"/>
			<description>Entry Style in FontDescriptorCIDType2 shall have type Dictionary</description>
			<test>containsStyle == false || StyleHasTypeDictionary == true</test>
			<error>
				<message>Entry Style in FontDescriptorCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>StyleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorCIDType2 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorCIDType2 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorCIDType2 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorCIDType2 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_2" clause="FontDescriptorCIDType2-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType" testNumber="1"/>
			<description>FontDescriptorTrueType shall not contain entries except FontFile2, FontBBox, StemV, CapHeight, Flags, Type, ItalicAngle, Ascent, FontFile, MaxWidth, FontName, StemH, AvgWidth, Descent, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType" testNumber="22"/>
			<description>FontDescriptorTrueType shall not contain entries FontFamily, FontStretch, FontWeight in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorTrueType shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorTrueType is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorTrueType shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorTrueType shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorTrueType is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorTrueType shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorTrueType does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorTrueType shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorTrueType has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorTrueType is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorTrueType shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorTrueType has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorTrueType is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorTrueType shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorTrueType shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile2 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile2" testNumber="8"/>
			<description>Entry FontFile2 in FontDescriptorTrueType shall have type Stream</description>
			<test>containsFontFile2 == false || FontFile2HasTypeStream == true</test>
			<error>
				<message>Entry FontFile2 in FontDescriptorTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile2-Stream" testNumber="10"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorTrueType shall be indirect</description>
			<test>FontFile2HasTypeStream != true || isFontFile2Indirect == true</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontFile2-Stream" testNumber="9"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile2HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorTrueType shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorTrueType is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorTrueType shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorTrueType does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorTrueType shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorTrueType is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorTrueType shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorTrueType shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorTrueType shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorTrueType is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorTrueType shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorTrueType is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorTrueType shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorTrueType has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_2" clause="FontDescriptorTrueType-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorTrueType shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1" testNumber="1"/>
			<description>FontDescriptorType1 shall not contain entries except FontBBox, CharSet, StemV, CapHeight, Flags, FontFile3, Type, ItalicAngle, Ascent, FontFile, MaxWidth, FontName, StemH, AvgWidth, Descent, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1" testNumber="22"/>
			<description>FontDescriptorType1 shall not contain entries FontFamily, FontStretch, FontWeight in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorType1 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorType1 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorType1 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-CharSet" testNumber="8"/>
			<description>Entry CharSet in FontDescriptorType1 shall have one of types: StringAscii, StringByte</description>
			<test>containsCharSet == false || CharSetHasTypeStringAscii == true || CharSetHasTypeStringByte == true</test>
			<error>
				<message>Entry CharSet in FontDescriptorType1 has type %1 instead of one of types: StringAscii, StringByte</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorType1 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorType1 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorType1 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorType1 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorType1 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType1 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorType1 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorType1 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorType1 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorType1 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorType1 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorType1 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorType1 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontFile3" testNumber="8"/>
			<description>Entry FontFile3 in FontDescriptorType1 shall have type Stream</description>
			<test>containsFontFile3 == false || FontFile3HasTypeStream == true</test>
			<error>
				<message>Entry FontFile3 in FontDescriptorType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontFile3-Stream" testNumber="10"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorType1 shall be indirect</description>
			<test>FontFile3HasTypeStream != true || isFontFile3Indirect == true</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorType1 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorType1 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorType1 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorType1 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorType1 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorType1 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorType1 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorType1 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorType1 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorType1 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorType1 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorType1 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorType1 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_2" clause="FontDescriptorType1-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorType1 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3" testNumber="1"/>
			<description>FontDescriptorType3 shall not contain entries except FontBBox, StemV, CapHeight, Flags, Type, ItalicAngle, Ascent, MaxWidth, FontName, StemH, AvgWidth, Descent, XHeight, Leading, MissingWidth</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FontFamily' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Ascent' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'XHeight' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MissingWidth' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3" testNumber="22"/>
			<description>FontDescriptorType3 shall not contain entries FontFamily, FontStretch, FontWeight in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorType3 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorType3 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorType3 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorType3 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorType3 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorType3 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType3 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorType3 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorType3 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorType3 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorType3 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType3 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorType3 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorType3 shall satisfy special case: fn:Eval(@FontName == parent::@Name)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentNameNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorType3 does not satisfy special case: fn:Eval(@FontName == parent::@Name)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorType3 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorType3 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorType3 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorType3 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorType3 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorType3 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorType3 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorType3 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorType3 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_2" clause="FontDescriptorType3-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorType3 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile" testNumber="1"/>
			<description>FontFile shall not contain entries except Length1, Length3, Length2, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile" testNumber="22"/>
			<description>FontFile shall not contain entries FDecodeParms, Filter, Length, F, DL, DecodeParms, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').length == 0</test>
			<error>
				<message>FontFile contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_2" clause="FontFile-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile shall have one of values: OpenType, CIDFontType0C, Type1C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1C" || SubtypeNameValue == "CIDFontType0C" || SubtypeNameValue == "OpenType"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile has incorrect value %1 instead of OpenType, CIDFontType0C, Type1C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2" testNumber="1"/>
			<description>FontFile2 shall not contain entries except FDecodeParms, Filter, Length, F, DecodeParms, Length1, Length3, Length2, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2" testNumber="22"/>
			<description>FontFile2 shall not contain entry DL in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL').length == 0</test>
			<error>
				<message>FontFile2 contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile2 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile2 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile2 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile2 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-F" testNumber="8"/>
			<description>Entry F in FontFile2 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile2 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile2 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile2 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile2 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile2 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile2 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile2 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile2 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile2 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile2 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile2 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile2 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile2 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length" testNumber="8"/>
			<description>Entry Length in FontFile2 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length" testNumber="7"/>
			<description>Entry Length in FontFile2 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile2 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length1" testNumber="11"/>
			<description>Entry Length1 in FontFile2 is required, when parent::parent::@Subtype == TrueType</description>
			<test>containsLength1 == true || (parentparentSubtypeNameValue != "TrueType")</test>
			<error>
				<message>Entry Length1 in FontFile2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile2 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile2 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_2" clause="FontFile2-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile2 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile2 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0" testNumber="1"/>
			<description>FontFile3CIDType0 shall not contain entries except FDecodeParms, Filter, Length, F, DecodeParms, Length1, Length3, Length2, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile3CIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0" testNumber="22"/>
			<description>FontFile3CIDType0 shall not contain entry DL in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL').length == 0</test>
			<error>
				<message>FontFile3CIDType0 contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile3CIDType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile3CIDType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile3CIDType0 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile3CIDType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-F" testNumber="8"/>
			<description>Entry F in FontFile3CIDType0 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile3CIDType0 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile3CIDType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile3CIDType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile3CIDType0 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile3CIDType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile3CIDType0 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile3CIDType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile3CIDType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile3CIDType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile3CIDType0 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile3CIDType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile3CIDType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile3CIDType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length" testNumber="8"/>
			<description>Entry Length in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length" testNumber="7"/>
			<description>Entry Length in FontFile3CIDType0 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile3CIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile3CIDType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile3CIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_2" clause="FontFile3CIDType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile3CIDType0 shall have value CIDFontType0C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType0C"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile3CIDType0 has incorrect value %1 instead of CIDFontType0C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1" testNumber="1"/>
			<description>FontFile3Type1 shall not contain entries except Length1, Length3, Length2, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile3Type1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1" testNumber="22"/>
			<description>FontFile3Type1 shall not contain entries FDecodeParms, Filter, Length, F, DL, DecodeParms, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').length == 0</test>
			<error>
				<message>FontFile3Type1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile3Type1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile3Type1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontFile3Type1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontFile3Type1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_2" clause="FontFile3Type1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile3Type1 shall have one of values: OpenType, CIDFontType0C, Type1C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1C" || SubtypeNameValue == "CIDFontType0C" || SubtypeNameValue == "OpenType"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile3Type1 has incorrect value %1 instead of OpenType, CIDFontType0C, Type1C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1" testNumber="1"/>
			<description>FontFileType1 shall not contain entries except Length1, Length3, Length2, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFileType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1" testNumber="22"/>
			<description>FontFileType1 shall not contain entries FDecodeParms, Filter, Length, F, DL, DecodeParms, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').length == 0</test>
			<error>
				<message>FontFileType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFileType1 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length1" testNumber="7"/>
			<description>Entry Length1 in FontFileType1 is required</description>
			<test>containsLength1 == true</test>
			<error>
				<message>Entry Length1 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFileType1 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length2" testNumber="7"/>
			<description>Entry Length2 in FontFileType1 is required</description>
			<test>containsLength2 == true</test>
			<error>
				<message>Entry Length2 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFileType1 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length3" testNumber="7"/>
			<description>Entry Length3 in FontFileType1 is required</description>
			<test>containsLength3 == true</test>
			<error>
				<message>Entry Length3 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_2" clause="FontFileType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFileType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFileType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMapEntry">
			<id specification="PDF_1_2" clause="FontMapEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in FontMap shall be one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in FontMap is not one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMapEntry">
			<id specification="PDF_1_2" clause="FontMapEntry" testNumber="8"/>
			<description>Entry in FontMap shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in FontMap has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster" testNumber="1"/>
			<description>FontMultipleMaster shall not contain entries except ToUnicode, Widths, Type, BaseFont, LastChar, Encoding, Subtype, FirstChar, FontDescriptor, Name</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontMultipleMaster contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontMultipleMaster shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontMultipleMaster is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontMultipleMaster shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontMultipleMaster has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontMultipleMaster shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontMultipleMaster has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontMultipleMaster shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontMultipleMaster has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontMultipleMaster shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontMultipleMaster has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontMultipleMaster shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontMultipleMaster is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontMultipleMaster shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontMultipleMaster has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Name" testNumber="8"/>
			<description>Entry Name in FontMultipleMaster shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontMultipleMaster shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontMultipleMaster is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontMultipleMaster shall have value MMType1</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "MMType1"</test>
			<error>
				<message>Entry Subtype with type Name in FontMultipleMaster has incorrect value %1 instead of MMType1</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontMultipleMaster shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontMultipleMaster has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontMultipleMaster shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontMultipleMaster is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Type" testNumber="8"/>
			<description>Entry Type in FontMultipleMaster shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Type" testNumber="7"/>
			<description>Entry Type in FontMultipleMaster is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontMultipleMaster shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontMultipleMaster has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Widths" testNumber="8"/>
			<description>Entry Widths in FontMultipleMaster shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontMultipleMaster has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_2" clause="FontMultipleMaster-Widths" testNumber="11"/>
			<description>Entry Widths in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType" testNumber="1"/>
			<description>FontTrueType shall not contain entries except ToUnicode, Widths, Type, BaseFont, LastChar, Encoding, Subtype, FirstChar, FontDescriptor, Name</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontTrueType shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontTrueType is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontTrueType shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontTrueType has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontTrueType shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontTrueType has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontTrueType shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontTrueType has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontTrueType shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontTrueType has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontTrueType shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontTrueType shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontTrueType has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Name" testNumber="8"/>
			<description>Entry Name in FontTrueType shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontTrueType shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontTrueType is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontTrueType shall have value TrueType</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "TrueType"</test>
			<error>
				<message>Entry Subtype with type Name in FontTrueType has incorrect value %1 instead of TrueType</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontTrueType shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontTrueType shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Type" testNumber="8"/>
			<description>Entry Type in FontTrueType shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Type" testNumber="7"/>
			<description>Entry Type in FontTrueType is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontTrueType shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontTrueType has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Widths" testNumber="8"/>
			<description>Entry Widths in FontTrueType shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontTrueType has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_2" clause="FontTrueType-Widths" testNumber="11"/>
			<description>Entry Widths in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0" testNumber="1"/>
			<description>FontType0 shall not contain entries except ToUnicode, Type, BaseFont, Encoding, DescendantFonts, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'DescendantFonts' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'DescendantFonts' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontType0 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontType0 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-DescendantFonts" testNumber="8"/>
			<description>Entry DescendantFonts in FontType0 shall have type Array</description>
			<test>containsDescendantFonts == false || DescendantFontsHasTypeArray == true</test>
			<error>
				<message>Entry DescendantFonts in FontType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DescendantFontsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-DescendantFonts" testNumber="7"/>
			<description>Entry DescendantFonts in FontType0 is required</description>
			<test>containsDescendantFonts == true</test>
			<error>
				<message>Entry DescendantFonts in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType0 shall have one of types: Name, Stream</description>
			<test>containsEncoding == false || EncodingHasTypeName == true || EncodingHasTypeStream == true</test>
			<error>
				<message>Entry Encoding in FontType0 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Encoding" testNumber="7"/>
			<description>Entry Encoding in FontType0 is required</description>
			<test>containsEncoding == true</test>
			<error>
				<message>Entry Encoding in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontType0 shall have one of values: GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "GB-EUC-H" || EncodingNameValue == "GB-EUC-V" || EncodingNameValue == "GBpc-EUC-H" || EncodingNameValue == "GBpc-EUC-V" || EncodingNameValue == "GBK-EUC-H" || EncodingNameValue == "GBK-EUC-V" || EncodingNameValue == "GBKp-EUC-H" || EncodingNameValue == "GBKp-EUC-V" || EncodingNameValue == "GBK2K-H" || EncodingNameValue == "GBK2K-V" || EncodingNameValue == "UniGB-UCS2-H" || EncodingNameValue == "UniGB-UCS2-V" || EncodingNameValue == "UniGB-UTF16-H" || EncodingNameValue == "UniGB-UTF16-V" || EncodingNameValue == "B5pc-H" || EncodingNameValue == "B5pc-V" || EncodingNameValue == "HKscs-B5-H" || EncodingNameValue == "HKscs-B5-V" || EncodingNameValue == "ETen-B5-H" || EncodingNameValue == "ETen-B5-V" || EncodingNameValue == "ETenms-B5-H" || EncodingNameValue == "ETenms-B5-V" || EncodingNameValue == "CNS-EUC-H" || EncodingNameValue == "CNS-EUC-V" || EncodingNameValue == "UniCNS-UCS2-H" || EncodingNameValue == "UniCNS-UCS2-V" || EncodingNameValue == "UniCNS-UTF16-H" || EncodingNameValue == "UniCNS-UTF16-V" || EncodingNameValue == "83pv-RKSJ-H" || EncodingNameValue == "90ms-RKSJ-H" || EncodingNameValue == "90ms-RKSJ-V" || EncodingNameValue == "90msp-RKSJ-H" || EncodingNameValue == "90msp-RKSJ-V" || EncodingNameValue == "90pv-RKSJ-H" || EncodingNameValue == "Add-RKSJ-H" || EncodingNameValue == "Add-RKSJ-V" || EncodingNameValue == "EUC-H" || EncodingNameValue == "EUC-V" || EncodingNameValue == "Ext-RKSJ-H" || EncodingNameValue == "Ext-RKSJ-V" || EncodingNameValue == "H" || EncodingNameValue == "V" || EncodingNameValue == "UniJIS-UCS2-H" || EncodingNameValue == "UniJIS-UCS2-V" || EncodingNameValue == "UniJIS-UCS2-HW-H" || EncodingNameValue == "UniJIS-UCS2-HW-V" || EncodingNameValue == "UniJIS-UTF16-H" || EncodingNameValue == "UniJIS-UTF16-V" || EncodingNameValue == "KSC-EUC-H" || EncodingNameValue == "KSC-EUC-V" || EncodingNameValue == "KSCms-UHC-H" || EncodingNameValue == "KSCms-UHC-V" || EncodingNameValue == "KSCms-UHC-HW-H" || EncodingNameValue == "KSCms-UHC-HW-V" || EncodingNameValue == "KSCpc-EUC-H" || EncodingNameValue == "UniKS-UCS2-H" || EncodingNameValue == "UniKS-UCS2-V" || EncodingNameValue == "UniKS-UTF16-H" || EncodingNameValue == "UniKS-UTF16-V" || EncodingNameValue == "Identity-H" || EncodingNameValue == "Identity-V"</test>
			<error>
				<message>Entry Encoding with type Name in FontType0 has incorrect value %1 instead of GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Encoding-Stream" testNumber="10"/>
			<description>Entry Encoding with type Stream in FontType0 shall be indirect</description>
			<test>EncodingHasTypeStream != true || isEncodingIndirect == true</test>
			<error>
				<message>Entry Encoding with type Stream in FontType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType0 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType0 shall have value Type0</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type0"</test>
			<error>
				<message>Entry Subtype with type Name in FontType0 has incorrect value %1 instead of Type0</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType0 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType0 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Type" testNumber="8"/>
			<description>Entry Type in FontType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Type" testNumber="7"/>
			<description>Entry Type in FontType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_2" clause="FontType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType0 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType0 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1" testNumber="1"/>
			<description>FontType1 shall not contain entries except ToUnicode, Widths, Type, BaseFont, LastChar, Encoding, Subtype, FirstChar, FontDescriptor, Name</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ToUnicode' &amp;&amp; elem != 'Widths' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'BaseFont' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Name' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontType1 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontType1 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType1 shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontType1 has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontType1 shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontType1 has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontType1 shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontType1 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontType1 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontType1 shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Name" testNumber="8"/>
			<description>Entry Name in FontType1 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType1 shall have value Type1</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1"</test>
			<error>
				<message>Entry Subtype with type Name in FontType1 has incorrect value %1 instead of Type1</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType1 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType1 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Type" testNumber="8"/>
			<description>Entry Type in FontType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Type" testNumber="7"/>
			<description>Entry Type in FontType1 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType1 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType1 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Widths" testNumber="8"/>
			<description>Entry Widths in FontType1 shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Widths" testNumber="11"/>
			<description>Entry Widths in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_2" clause="FontType1-Widths-Array" testNumber="9"/>
			<description>Entry Widths with type Array in FontType1 shall satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</description>
			<test>WidthsHasTypeArray != true || (LastCharHasTypeInteger == false || FirstCharHasTypeInteger == false || WidthsArraySize == (1 + (LastCharIntegerValue - FirstCharIntegerValue)))</test>
			<error>
				<message>Entry Widths with type Array in FontType1 does not satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3" testNumber="1"/>
			<description>FontType3 shall not contain entries except Widths, CharProcs, FontBBox, Encoding, Name, ToUnicode, Type, FontMatrix, LastChar, Resources, Subtype, FirstChar, FontDescriptor</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Widths' &amp;&amp; elem != 'CharProcs' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'FontMatrix' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Widths' &amp;&amp; elem != 'CharProcs' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'FontMatrix' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-CharProcs" testNumber="8"/>
			<description>Entry CharProcs in FontType3 shall have type Dictionary</description>
			<test>containsCharProcs == false || CharProcsHasTypeDictionary == true</test>
			<error>
				<message>Entry CharProcs in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CharProcsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-CharProcs" testNumber="7"/>
			<description>Entry CharProcs in FontType3 is required</description>
			<test>containsCharProcs == true</test>
			<error>
				<message>Entry CharProcs in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType3 shall have type Dictionary</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true</test>
			<error>
				<message>Entry Encoding in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Encoding" testNumber="7"/>
			<description>Entry Encoding in FontType3 is required</description>
			<test>containsEncoding == true</test>
			<error>
				<message>Entry Encoding in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontType3 shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FirstChar" testNumber="7"/>
			<description>Entry FirstChar in FontType3 is required</description>
			<test>containsFirstChar == true</test>
			<error>
				<message>Entry FirstChar in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontType3 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontType3 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontType3 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontType3 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontType3 is required, when fn:IsPDFTagged()</description>
			<test>containsFontDescriptor == true || isPDFTagged == false</test>
			<error>
				<message>Entry FontDescriptor in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontType3 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontType3 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontMatrix" testNumber="8"/>
			<description>Entry FontMatrix in FontType3 shall have type Matrix</description>
			<test>containsFontMatrix == false || FontMatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry FontMatrix in FontType3 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>FontMatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-FontMatrix" testNumber="7"/>
			<description>Entry FontMatrix in FontType3 is required</description>
			<test>containsFontMatrix == true</test>
			<error>
				<message>Entry FontMatrix in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontType3 shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-LastChar" testNumber="7"/>
			<description>Entry LastChar in FontType3 is required</description>
			<test>containsLastChar == true</test>
			<error>
				<message>Entry LastChar in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Name" testNumber="8"/>
			<description>Entry Name in FontType3 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Resources" testNumber="8"/>
			<description>Entry Resources in FontType3 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType3 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType3 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType3 shall have value Type3</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type3"</test>
			<error>
				<message>Entry Subtype with type Name in FontType3 has incorrect value %1 instead of Type3</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType3 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType3 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType3 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType3 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Type" testNumber="8"/>
			<description>Entry Type in FontType3 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Type" testNumber="7"/>
			<description>Entry Type in FontType3 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType3 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType3 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Widths" testNumber="8"/>
			<description>Entry Widths in FontType3 shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Widths" testNumber="7"/>
			<description>Entry Widths in FontType3 is required</description>
			<test>containsWidths == true</test>
			<error>
				<message>Entry Widths in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_2" clause="FontType3-Widths-Array" testNumber="9"/>
			<description>Entry Widths with type Array in FontType3 shall satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</description>
			<test>WidthsHasTypeArray != true || (LastCharHasTypeInteger == false || FirstCharHasTypeInteger == false || WidthsArraySize == (1 + (LastCharIntegerValue - FirstCharIntegerValue)))</test>
			<error>
				<message>Entry Widths with type Array in FontType3 does not satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0" testNumber="1"/>
			<description>FunctionType0 shall not contain entries except Order, Size, FunctionType, Decode, Range, Encode, BitsPerSample, Domain</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Order' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'BitsPerSample' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FunctionType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Order' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'BitsPerSample' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0" testNumber="22"/>
			<description>FunctionType0 shall not contain entries F, DL, DecodeParms, FDecodeParms, Filter, Length, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').length == 0</test>
			<error>
				<message>FunctionType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-BitsPerSample" testNumber="8"/>
			<description>Entry BitsPerSample in FunctionType0 shall have type Integer</description>
			<test>containsBitsPerSample == false || BitsPerSampleHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerSample in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerSampleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-BitsPerSample" testNumber="7"/>
			<description>Entry BitsPerSample in FunctionType0 is required</description>
			<test>containsBitsPerSample == true</test>
			<error>
				<message>Entry BitsPerSample in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-BitsPerSample-Integer" testNumber="6"/>
			<description>Entry BitsPerSample with type Integer in FunctionType0 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerSampleHasTypeInteger != true || BitsPerSampleIntegerValue == 1 || BitsPerSampleIntegerValue == 2 || BitsPerSampleIntegerValue == 4 || BitsPerSampleIntegerValue == 8 || BitsPerSampleIntegerValue == 12 || BitsPerSampleIntegerValue == 16 || BitsPerSampleIntegerValue == 24 || BitsPerSampleIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerSample with type Integer in FunctionType0 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerSampleIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Decode" testNumber="8"/>
			<description>Entry Decode in FunctionType0 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Decode-Array" testNumber="9"/>
			<description>Entry Decode with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Decode) == fn:ArrayLength(Range))</description>
			<test>DecodeHasTypeArray != true || (RangeHasTypeArray == false || DecodeArraySize == RangeArraySize)</test>
			<error>
				<message>Entry Decode with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Decode) == fn:ArrayLength(Range))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Domain" testNumber="8"/>
			<description>Entry Domain in FunctionType0 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Domain" testNumber="7"/>
			<description>Entry Domain in FunctionType0 is required</description>
			<test>containsDomain == true</test>
			<error>
				<message>Entry Domain in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Domain-Array" testNumber="9"/>
			<description>Entry Domain with type Array in FunctionType0 shall satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</description>
			<test>DomainHasTypeArray != true || ((DomainArraySize % 2) == 0)</test>
			<error>
				<message>Entry Domain with type Array in FunctionType0 does not satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Encode" testNumber="8"/>
			<description>Entry Encode in FunctionType0 shall have type Array</description>
			<test>containsEncode == false || EncodeHasTypeArray == true</test>
			<error>
				<message>Entry Encode in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>EncodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Encode-Array" testNumber="9"/>
			<description>Entry Encode with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Encode) == (2 * fn:ArrayLength(Size)))</description>
			<test>EncodeHasTypeArray != true || (SizeHasTypeArray == false || EncodeArraySize == (2 * SizeArraySize))</test>
			<error>
				<message>Entry Encode with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Encode) == (2 * fn:ArrayLength(Size)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-FunctionType" testNumber="8"/>
			<description>Entry FunctionType in FunctionType0 shall have type Integer</description>
			<test>containsFunctionType == false || FunctionTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FunctionType in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FunctionTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-FunctionType" testNumber="7"/>
			<description>Entry FunctionType in FunctionType0 is required</description>
			<test>containsFunctionType == true</test>
			<error>
				<message>Entry FunctionType in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-FunctionType-Integer" testNumber="6"/>
			<description>Entry FunctionType with type Integer in FunctionType0 shall have value 0</description>
			<test>FunctionTypeHasTypeInteger != true || FunctionTypeIntegerValue == 0</test>
			<error>
				<message>Entry FunctionType with type Integer in FunctionType0 has incorrect value %1 instead of 0</message>
				<arguments>
					<argument>FunctionTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Order" testNumber="8"/>
			<description>Entry Order in FunctionType0 shall have type Integer</description>
			<test>containsOrder == false || OrderHasTypeInteger == true</test>
			<error>
				<message>Entry Order in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>OrderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Order-Integer" testNumber="6"/>
			<description>Entry Order with type Integer in FunctionType0 shall have one of values: 1, 3</description>
			<test>OrderHasTypeInteger != true || OrderIntegerValue == 1 || OrderIntegerValue == 3</test>
			<error>
				<message>Entry Order with type Integer in FunctionType0 has incorrect value %1 instead of 1, 3</message>
				<arguments>
					<argument>OrderIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Range" testNumber="8"/>
			<description>Entry Range in FunctionType0 shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Range" testNumber="7"/>
			<description>Entry Range in FunctionType0 is required</description>
			<test>containsRange == true</test>
			<error>
				<message>Entry Range in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in FunctionType0 shall satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</description>
			<test>RangeHasTypeArray != true || ((RangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Range with type Array in FunctionType0 does not satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Size" testNumber="8"/>
			<description>Entry Size in FunctionType0 shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Size" testNumber="7"/>
			<description>Entry Size in FunctionType0 is required</description>
			<test>containsSize == true</test>
			<error>
				<message>Entry Size in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_2" clause="FunctionType0-Size-Array" testNumber="9"/>
			<description>Entry Size with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Domain) == (2 * fn:ArrayLength(Size)))</description>
			<test>SizeHasTypeArray != true || (DomainHasTypeArray == false || DomainArraySize == (2 * SizeArraySize))</test>
			<error>
				<message>Entry Size with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Domain) == (2 * fn:ArrayLength(Size)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray" testNumber="2"/>
			<description>GammaArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>GammaArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-0" testNumber="8"/>
			<description>Entry 0 in GammaArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-1" testNumber="8"/>
			<description>Entry 1 in GammaArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-2" testNumber="8"/>
			<description>Entry 2 in GammaArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_2" clause="GammaArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter" testNumber="1"/>
			<description>GraphicsStateParameter shall not contain entries except BG, HTP, UCR, HT, SA, AAPL:AA, AAPL:ST, OP, Type, TR</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'HTO' &amp;&amp; elem != 'D' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'HTP' &amp;&amp; elem != 'UCR' &amp;&amp; elem != 'FL' &amp;&amp; elem != 'UCR2' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'LW' &amp;&amp; elem != 'BG2' &amp;&amp; elem != 'HT' &amp;&amp; elem != 'OPM' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'SA' &amp;&amp; elem != 'AAPL:AA' &amp;&amp; elem != 'AAPL:ST' &amp;&amp; elem != 'SM' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'ML' &amp;&amp; elem != 'UseBlackPtComp' &amp;&amp; elem != 'OP' &amp;&amp; elem != 'op' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'AIS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'TR2' &amp;&amp; elem != 'LC' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'TK' &amp;&amp; elem != 'LJ' &amp;&amp; elem != 'TR' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>GraphicsStateParameter contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'HTO' &amp;&amp; elem != 'D' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'HTP' &amp;&amp; elem != 'UCR' &amp;&amp; elem != 'FL' &amp;&amp; elem != 'UCR2' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'LW' &amp;&amp; elem != 'BG2' &amp;&amp; elem != 'HT' &amp;&amp; elem != 'OPM' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'SA' &amp;&amp; elem != 'AAPL:AA' &amp;&amp; elem != 'AAPL:ST' &amp;&amp; elem != 'SM' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'ML' &amp;&amp; elem != 'UseBlackPtComp' &amp;&amp; elem != 'OP' &amp;&amp; elem != 'op' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'AIS' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'TR2' &amp;&amp; elem != 'LC' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'TK' &amp;&amp; elem != 'LJ' &amp;&amp; elem != 'TR' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter" testNumber="22"/>
			<description>GraphicsStateParameter shall not contain entries HTO, D, FL, UCR2, BM, LW, BG2, OPM, Font, SM, CA, ca, ML, UseBlackPtComp, op, SMask, AIS, TR2, LC, RI, TK, LJ in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'HTO' || elem == 'D' || elem == 'FL' || elem == 'UCR2' || elem == 'BM' || elem == 'LW' || elem == 'BG2' || elem == 'OPM' || elem == 'Font' || elem == 'SM' || elem == 'CA' || elem == 'ca' || elem == 'ML' || elem == 'UseBlackPtComp' || elem == 'op' || elem == 'SMask' || elem == 'AIS' || elem == 'TR2' || elem == 'LC' || elem == 'RI' || elem == 'TK' || elem == 'LJ').length == 0</test>
			<error>
				<message>GraphicsStateParameter contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'HTO' || elem == 'D' || elem == 'FL' || elem == 'UCR2' || elem == 'BM' || elem == 'LW' || elem == 'BG2' || elem == 'OPM' || elem == 'Font' || elem == 'SM' || elem == 'CA' || elem == 'ca' || elem == 'ML' || elem == 'UseBlackPtComp' || elem == 'op' || elem == 'SMask' || elem == 'AIS' || elem == 'TR2' || elem == 'LC' || elem == 'RI' || elem == 'TK' || elem == 'LJ').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-AAPL:AA" testNumber="8"/>
			<description>Entry AAPL:AA in GraphicsStateParameter shall have type Boolean</description>
			<test>containsAAPLAA == false || AAPLAAHasTypeBoolean == true</test>
			<error>
				<message>Entry AAPL:AA in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AAPLAAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-AAPL:AA" testNumber="23"/>
			<description>Entry AAPL:AA in GraphicsStateParameter can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsAAPLAA == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry AAPL:AA in GraphicsStateParameter is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-AAPL:ST" testNumber="8"/>
			<description>Entry AAPL:ST in GraphicsStateParameter shall have one of types: Dictionary, Name</description>
			<test>containsAAPLST == false || AAPLSTHasTypeDictionary == true || AAPLSTHasTypeName == true</test>
			<error>
				<message>Entry AAPL:ST in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>AAPLSTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-AAPL:ST" testNumber="23"/>
			<description>Entry AAPL:ST in GraphicsStateParameter can only be present, if satisfy predicate fn:Extension(AAPL)</description>
			<test>containsAAPLST == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry AAPL:ST in GraphicsStateParameter is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-BG" testNumber="8"/>
			<description>Entry BG in GraphicsStateParameter shall have type Stream</description>
			<test>containsBG == false || BGHasTypeStream == true</test>
			<error>
				<message>Entry BG in GraphicsStateParameter has type %1 instead of type Stream</message>
				<arguments>
					<argument>BGType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-BG-Stream" testNumber="10"/>
			<description>Entry BG with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>BGHasTypeStream != true || isBGIndirect == true</test>
			<error>
				<message>Entry BG with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-HT-Dictionary" testNumber="17"/>
			<description>Entry HT with type Dictionary in GraphicsStateParameter shall be one of objects HalftoneType1, HalftoneType5</description>
			<test>HTHasTypeDictionary != true || HT_size == 1</test>
			<error>
				<message>Entry HT with type Dictionary in GraphicsStateParameter is not one of objects HalftoneType1, HalftoneType5</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-HT-Stream" testNumber="17"/>
			<description>Entry HT with type Stream in GraphicsStateParameter shall be one of objects HalftoneType6, HalftoneType10</description>
			<test>HTHasTypeStream != true || HT_size == 1</test>
			<error>
				<message>Entry HT with type Stream in GraphicsStateParameter is not one of objects HalftoneType6, HalftoneType10</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-HT" testNumber="8"/>
			<description>Entry HT in GraphicsStateParameter shall have one of types: Dictionary, Name, Stream</description>
			<test>containsHT == false || HTHasTypeDictionary == true || HTHasTypeName == true || HTHasTypeStream == true</test>
			<error>
				<message>Entry HT in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>HTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-HT-Stream" testNumber="10"/>
			<description>Entry HT with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>HTHasTypeStream != true || isHTIndirect == true</test>
			<error>
				<message>Entry HT with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-HTP" testNumber="8"/>
			<description>Entry HTP in GraphicsStateParameter shall have type Array</description>
			<test>containsHTP == false || HTPHasTypeArray == true</test>
			<error>
				<message>Entry HTP in GraphicsStateParameter has type %1 instead of type Array</message>
				<arguments>
					<argument>HTPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-OP" testNumber="8"/>
			<description>Entry OP in GraphicsStateParameter shall have type Boolean</description>
			<test>containsOP == false || OPHasTypeBoolean == true</test>
			<error>
				<message>Entry OP in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-SA" testNumber="8"/>
			<description>Entry SA in GraphicsStateParameter shall have type Boolean</description>
			<test>containsSA == false || SAHasTypeBoolean == true</test>
			<error>
				<message>Entry SA in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-TR" testNumber="8"/>
			<description>Entry TR in GraphicsStateParameter shall have one of types: Array, Name, Stream</description>
			<test>containsTR == false || TRHasTypeArray == true || TRHasTypeName == true || TRHasTypeStream == true</test>
			<error>
				<message>Entry TR in GraphicsStateParameter has type %1 instead of one of types: Array, Name, Stream</message>
				<arguments>
					<argument>TRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-TR-Stream" testNumber="10"/>
			<description>Entry TR with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>TRHasTypeStream != true || isTRIndirect == true</test>
			<error>
				<message>Entry TR with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-Type" testNumber="8"/>
			<description>Entry Type in GraphicsStateParameter shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in GraphicsStateParameter has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in GraphicsStateParameter shall have value ExtGState</description>
			<test>TypeHasTypeName != true || TypeNameValue == "ExtGState"</test>
			<error>
				<message>Entry Type with type Name in GraphicsStateParameter has incorrect value %1 instead of ExtGState</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-UCR" testNumber="8"/>
			<description>Entry UCR in GraphicsStateParameter shall have type Stream</description>
			<test>containsUCR == false || UCRHasTypeStream == true</test>
			<error>
				<message>Entry UCR in GraphicsStateParameter has type %1 instead of type Stream</message>
				<arguments>
					<argument>UCRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_2" clause="GraphicsStateParameter-UCR-Stream" testNumber="10"/>
			<description>Entry UCR with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>UCRHasTypeStream != true || isUCRIndirect == true</test>
			<error>
				<message>Entry UCR with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameterMapEntry">
			<id specification="PDF_1_2" clause="GraphicsStateParameterMapEntry" testNumber="8"/>
			<description>Entry in GraphicsStateParameterMap shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in GraphicsStateParameterMap has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1" testNumber="1"/>
			<description>HalftoneType1 shall not contain entries except SpotFunction, TransferFunction, Type, HalftoneName, Angle, AccurateScreens, Frequency, HalftoneType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'SpotFunction' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Angle' &amp;&amp; elem != 'AccurateScreens' &amp;&amp; elem != 'Frequency' &amp;&amp; elem != 'HalftoneType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'SpotFunction' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Angle' &amp;&amp; elem != 'AccurateScreens' &amp;&amp; elem != 'Frequency' &amp;&amp; elem != 'HalftoneType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-AccurateScreens" testNumber="8"/>
			<description>Entry AccurateScreens in HalftoneType1 shall have type Boolean</description>
			<test>containsAccurateScreens == false || AccurateScreensHasTypeBoolean == true</test>
			<error>
				<message>Entry AccurateScreens in HalftoneType1 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AccurateScreensType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Angle" testNumber="8"/>
			<description>Entry Angle in HalftoneType1 shall have type Number</description>
			<test>containsAngle == false || AngleHasTypeNumber == true</test>
			<error>
				<message>Entry Angle in HalftoneType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Angle" testNumber="7"/>
			<description>Entry Angle in HalftoneType1 is required</description>
			<test>containsAngle == true</test>
			<error>
				<message>Entry Angle in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Frequency" testNumber="8"/>
			<description>Entry Frequency in HalftoneType1 shall have type Number</description>
			<test>containsFrequency == false || FrequencyHasTypeNumber == true</test>
			<error>
				<message>Entry Frequency in HalftoneType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>FrequencyType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Frequency" testNumber="7"/>
			<description>Entry Frequency in HalftoneType1 is required</description>
			<test>containsFrequency == true</test>
			<error>
				<message>Entry Frequency in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Frequency-Number" testNumber="14"/>
			<description>Entry Frequency with type Number in HalftoneType1 shall satisfy possible value predicate: fn:Eval(@Frequency &gt;= 0)</description>
			<test>FrequencyHasTypeNumber != true || FrequencyNumberValue &gt;= 0</test>
			<error>
				<message>Entry Frequency with type Number in HalftoneType1 does not satisfy possible value predicate: fn:Eval(@Frequency &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType1 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType1 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType1 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType1 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType1 shall have value 1</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 1</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-SpotFunction" testNumber="8"/>
			<description>Entry SpotFunction in HalftoneType1 shall have one of types: Array, Name, Stream</description>
			<test>containsSpotFunction == false || SpotFunctionHasTypeArray == true || SpotFunctionHasTypeName == true || SpotFunctionHasTypeStream == true</test>
			<error>
				<message>Entry SpotFunction in HalftoneType1 has type %1 instead of one of types: Array, Name, Stream</message>
				<arguments>
					<argument>SpotFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-SpotFunction" testNumber="7"/>
			<description>Entry SpotFunction in HalftoneType1 is required</description>
			<test>containsSpotFunction == true</test>
			<error>
				<message>Entry SpotFunction in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-SpotFunction-Name" testNumber="6"/>
			<description>Entry SpotFunction with type Name in HalftoneType1 shall have one of values: Ellipse, LineX, SimpleDot, LineY, Cross, InvertedDouble, Diamond, InvertedDoubleDot, Square, Double, InvertedEllipseC, InvertedEllipseA, Line, CosineDot, InvertedSimpleDot, Round, EllipseA, DoubleDot, EllipseC, Rhomboid, EllipseB</description>
			<test>SpotFunctionHasTypeName != true || SpotFunctionNameValue == "SimpleDot" || SpotFunctionNameValue == "InvertedSimpleDot" || SpotFunctionNameValue == "DoubleDot" || SpotFunctionNameValue == "InvertedDoubleDot" || SpotFunctionNameValue == "CosineDot" || SpotFunctionNameValue == "Double" || SpotFunctionNameValue == "InvertedDouble" || SpotFunctionNameValue == "Line" || SpotFunctionNameValue == "LineX" || SpotFunctionNameValue == "LineY" || SpotFunctionNameValue == "Round" || SpotFunctionNameValue == "Ellipse" || SpotFunctionNameValue == "EllipseA" || SpotFunctionNameValue == "InvertedEllipseA" || SpotFunctionNameValue == "EllipseB" || SpotFunctionNameValue == "EllipseC" || SpotFunctionNameValue == "InvertedEllipseC" || SpotFunctionNameValue == "Square" || SpotFunctionNameValue == "Cross" || SpotFunctionNameValue == "Rhomboid" || SpotFunctionNameValue == "Diamond"</test>
			<error>
				<message>Entry SpotFunction with type Name in HalftoneType1 has incorrect value %1 instead of Ellipse, LineX, SimpleDot, LineY, Cross, InvertedDouble, Diamond, InvertedDoubleDot, Square, Double, InvertedEllipseC, InvertedEllipseA, Line, CosineDot, InvertedSimpleDot, Round, EllipseA, DoubleDot, EllipseC, Rhomboid, EllipseB</message>
				<arguments>
					<argument>SpotFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-SpotFunction-Stream" testNumber="10"/>
			<description>Entry SpotFunction with type Stream in HalftoneType1 shall be indirect</description>
			<test>SpotFunctionHasTypeStream != true || isSpotFunctionIndirect == true</test>
			<error>
				<message>Entry SpotFunction with type Stream in HalftoneType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType1 shall have one of types: Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType1 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-TransferFunction" testNumber="11"/>
			<description>Entry TransferFunction in HalftoneType1 is required, when parent::@HalftoneType == 5</description>
			<test>parentHalftoneTypeHasTypeInteger == false || (containsTransferFunction == true || (parentHalftoneTypeIntegerValue != 5))</test>
			<error>
				<message>Entry TransferFunction in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType1 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType1 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType1 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_2" clause="HalftoneType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType1 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType1 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10" testNumber="1"/>
			<description>HalftoneType10 shall not contain entries except Ysquare, Xsquare, TransferFunction, Type, HalftoneName, HalftoneType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ysquare' &amp;&amp; elem != 'Xsquare' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType10 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ysquare' &amp;&amp; elem != 'Xsquare' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10" testNumber="22"/>
			<description>HalftoneType10 shall not contain entries F, DL, DecodeParms, FDecodeParms, Filter, Length, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').length == 0</test>
			<error>
				<message>HalftoneType10 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType10 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType10 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType10 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType10 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType10 shall have value 10</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 10</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType10 has incorrect value %1 instead of 10</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType10 shall have one of types: Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType10 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-TransferFunction" testNumber="11"/>
			<description>Entry TransferFunction in HalftoneType10 is required, when parent::@HalftoneType == 5</description>
			<test>parentHalftoneTypeHasTypeInteger == false || (containsTransferFunction == true || (parentHalftoneTypeIntegerValue != 5))</test>
			<error>
				<message>Entry TransferFunction in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType10 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType10 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType10 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType10 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType10 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType10 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType10 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType10 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Xsquare" testNumber="8"/>
			<description>Entry Xsquare in HalftoneType10 shall have type Integer</description>
			<test>containsXsquare == false || XsquareHasTypeInteger == true</test>
			<error>
				<message>Entry Xsquare in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>XsquareType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Xsquare" testNumber="7"/>
			<description>Entry Xsquare in HalftoneType10 is required</description>
			<test>containsXsquare == true</test>
			<error>
				<message>Entry Xsquare in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Xsquare-Integer" testNumber="14"/>
			<description>Entry Xsquare with type Integer in HalftoneType10 shall satisfy possible value predicate: fn:Eval(@Xsquare &gt; 0)</description>
			<test>XsquareHasTypeInteger != true || XsquareIntegerValue &gt; 0</test>
			<error>
				<message>Entry Xsquare with type Integer in HalftoneType10 does not satisfy possible value predicate: fn:Eval(@Xsquare &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Ysquare" testNumber="8"/>
			<description>Entry Ysquare in HalftoneType10 shall have type Integer</description>
			<test>containsYsquare == false || YsquareHasTypeInteger == true</test>
			<error>
				<message>Entry Ysquare in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>YsquareType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Ysquare" testNumber="7"/>
			<description>Entry Ysquare in HalftoneType10 is required</description>
			<test>containsYsquare == true</test>
			<error>
				<message>Entry Ysquare in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_2" clause="HalftoneType10-Ysquare-Integer" testNumber="14"/>
			<description>Entry Ysquare with type Integer in HalftoneType10 shall satisfy possible value predicate: fn:Eval(@Ysquare &gt; 0)</description>
			<test>YsquareHasTypeInteger != true || YsquareIntegerValue &gt; 0</test>
			<error>
				<message>Entry Ysquare with type Integer in HalftoneType10 does not satisfy possible value predicate: fn:Eval(@Ysquare &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Default-Stream" testNumber="17"/>
			<description>Entry Default with type Stream in HalftoneType5 shall be one of objects HalftoneType6, HalftoneType10</description>
			<test>DefaultHasTypeStream != true || Default_size == 1</test>
			<error>
				<message>Entry Default with type Stream in HalftoneType5 is not one of objects HalftoneType6, HalftoneType10</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Default" testNumber="8"/>
			<description>Entry Default in HalftoneType5 shall have one of types: Dictionary, Stream</description>
			<test>containsDefault == false || DefaultHasTypeDictionary == true || DefaultHasTypeStream == true</test>
			<error>
				<message>Entry Default in HalftoneType5 has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>DefaultType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Default" testNumber="7"/>
			<description>Entry Default in HalftoneType5 is required</description>
			<test>containsDefault == true</test>
			<error>
				<message>Entry Default in HalftoneType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Default-Stream" testNumber="10"/>
			<description>Entry Default with type Stream in HalftoneType5 shall be indirect</description>
			<test>DefaultHasTypeStream != true || isDefaultIndirect == true</test>
			<error>
				<message>Entry Default with type Stream in HalftoneType5 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType5 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType5 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType5 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType5 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType5 shall have value 5</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 5</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType5 has incorrect value %1 instead of 5</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType5 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType5 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_2" clause="HalftoneType5-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType5 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType5 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_2" clause="HalftoneType5Entry-Stream" testNumber="17"/>
			<description>Entry with type Stream in HalftoneType5 shall be one of objects HalftoneType6, HalftoneType10</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in HalftoneType5 is not one of objects HalftoneType6, HalftoneType10</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_2" clause="HalftoneType5Entry" testNumber="8"/>
			<description>Entry in HalftoneType5 shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in HalftoneType5 has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_2" clause="HalftoneType5Entry-Stream" testNumber="10"/>
			<description>Entry with type Stream in HalftoneType5 shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in HalftoneType5 is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6" testNumber="1"/>
			<description>HalftoneType6 shall not contain entries except TransferFunction, Type, HalftoneName, HalftoneType, Height, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType6 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6" testNumber="22"/>
			<description>HalftoneType6 shall not contain entries F, DL, DecodeParms, FDecodeParms, Filter, Length, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').length == 0</test>
			<error>
				<message>HalftoneType6 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType6 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType6 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType6 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType6 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType6 shall have value 6</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 6</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType6 has incorrect value %1 instead of 6</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Height" testNumber="8"/>
			<description>Entry Height in HalftoneType6 shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Height" testNumber="7"/>
			<description>Entry Height in HalftoneType6 is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Height-Integer" testNumber="14"/>
			<description>Entry Height with type Integer in HalftoneType6 shall satisfy possible value predicate: fn:Eval(@Height &gt;= 0)</description>
			<test>HeightHasTypeInteger != true || HeightIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Height with type Integer in HalftoneType6 does not satisfy possible value predicate: fn:Eval(@Height &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType6 shall have one of types: Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType6 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType6 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType6 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType6 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType6 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType6 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType6 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType6 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType6 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Width" testNumber="8"/>
			<description>Entry Width in HalftoneType6 shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Width" testNumber="7"/>
			<description>Entry Width in HalftoneType6 is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_2" clause="HalftoneType6-Width-Integer" testNumber="14"/>
			<description>Entry Width with type Integer in HalftoneType6 shall satisfy possible value predicate: fn:Eval(@Width &gt; 0)</description>
			<test>WidthHasTypeInteger != true || WidthIntegerValue &gt; 0</test>
			<error>
				<message>Entry Width with type Integer in HalftoneType6 does not satisfy possible value predicate: fn:Eval(@Width &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace" testNumber="2"/>
			<description>IndexedColorSpace shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>IndexedColorSpace contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-0" testNumber="8"/>
			<description>Entry 0 in IndexedColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in IndexedColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in IndexedColorSpace shall have value Indexed</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Indexed"</test>
			<error>
				<message>Entry 0 with type Name in IndexedColorSpace has incorrect value %1 instead of Indexed</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-1-Array" testNumber="17"/>
			<description>Entry 1 with type Array in IndexedColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, SeparationColorSpace</description>
			<test>entry1HasTypeArray != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Array in IndexedColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, SeparationColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-1" testNumber="8"/>
			<description>Entry 1 in IndexedColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 1 || entry1HasTypeArray == true || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in IndexedColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in IndexedColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry1HasTypeName != true || entry1NameValue == "DeviceCMYK" || entry1NameValue == "DeviceRGB" || entry1NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 1 with type Name in IndexedColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-2" testNumber="8"/>
			<description>Entry 2 in IndexedColorSpace shall have type Integer</description>
			<test>size &lt;= 2 || entry2HasTypeInteger == true</test>
			<error>
				<message>Entry 2 in IndexedColorSpace has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-2-Integer" testNumber="14"/>
			<description>Entry 2 with type Integer in IndexedColorSpace shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 255))</description>
			<test>entry2HasTypeInteger != true || (entry2IntegerValue &gt;= 0) &amp;&amp; (entry2IntegerValue &lt;= 255)</test>
			<error>
				<message>Entry 2 with type Integer in IndexedColorSpace does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 255))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-3" testNumber="8"/>
			<description>Entry 3 in IndexedColorSpace shall have one of types: Stream, String</description>
			<test>size &lt;= 3 || entry3HasTypeStream == true || entry3HasTypeString == true</test>
			<error>
				<message>Entry 3 in IndexedColorSpace has type %1 instead of one of types: Stream, String</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_2" clause="IndexedColorSpace-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in IndexedColorSpace shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in IndexedColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm" testNumber="1"/>
			<description>InteractiveForm shall not contain entries except Q, Fields, NeedAppearances, DA, DR</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Q' &amp;&amp; elem != 'XFA' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'NeedAppearances' &amp;&amp; elem != 'SigFlags' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DR' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>InteractiveForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Q' &amp;&amp; elem != 'XFA' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'NeedAppearances' &amp;&amp; elem != 'SigFlags' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DR' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm" testNumber="22"/>
			<description>InteractiveForm shall not contain entries XFA, SigFlags, CO in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'XFA' || elem == 'SigFlags' || elem == 'CO').length == 0</test>
			<error>
				<message>InteractiveForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'XFA' || elem == 'SigFlags' || elem == 'CO').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-DA" testNumber="8"/>
			<description>Entry DA in InteractiveForm shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in InteractiveForm has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-DR" testNumber="8"/>
			<description>Entry DR in InteractiveForm shall have type Dictionary</description>
			<test>containsDR == false || DRHasTypeDictionary == true</test>
			<error>
				<message>Entry DR in InteractiveForm has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-DR-Dictionary" testNumber="9"/>
			<description>Entry DR with type Dictionary in InteractiveForm shall satisfy special case: fn:Eval(fn:IsPresent(DR::Font::*))</description>
			<test>DRHasTypeDictionary != true || (containsDRFontAny == true)</test>
			<error>
				<message>Entry DR with type Dictionary in InteractiveForm does not satisfy special case: fn:Eval(fn:IsPresent(DR::Font::*))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-Fields" testNumber="8"/>
			<description>Entry Fields in InteractiveForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in InteractiveForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-Fields" testNumber="7"/>
			<description>Entry Fields in InteractiveForm is required</description>
			<test>containsFields == true</test>
			<error>
				<message>Entry Fields in InteractiveForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-NeedAppearances" testNumber="8"/>
			<description>Entry NeedAppearances in InteractiveForm shall have type Boolean</description>
			<test>containsNeedAppearances == false || NeedAppearancesHasTypeBoolean == true</test>
			<error>
				<message>Entry NeedAppearances in InteractiveForm has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NeedAppearancesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-Q" testNumber="8"/>
			<description>Entry Q in InteractiveForm shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in InteractiveForm has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_2" clause="InteractiveForm-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in InteractiveForm shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in InteractiveForm has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_2" clause="LabColorSpace" testNumber="2"/>
			<description>LabColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>LabColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_2" clause="LabColorSpace-0" testNumber="8"/>
			<description>Entry 0 in LabColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in LabColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_2" clause="LabColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in LabColorSpace shall have value Lab</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Lab"</test>
			<error>
				<message>Entry 0 with type Name in LabColorSpace has incorrect value %1 instead of Lab</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_2" clause="LabColorSpace-1" testNumber="8"/>
			<description>Entry 1 in LabColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in LabColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_2" clause="LabDict" testNumber="1"/>
			<description>LabDict shall not contain entries except WhitePoint, BlackPoint, Range</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'WhitePoint' &amp;&amp; elem != 'BlackPoint' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>LabDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'WhitePoint' &amp;&amp; elem != 'BlackPoint' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_2" clause="LabDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in LabDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_2" clause="LabDict-Range" testNumber="8"/>
			<description>Entry Range in LabDict shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_2" clause="LabDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in LabDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_2" clause="LabDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in LabDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in LabDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray" testNumber="2"/>
			<description>LabRangeArray shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>LabRangeArray contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-0" testNumber="8"/>
			<description>Entry 0 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@0 &lt;= @1)</description>
			<test>entry0HasTypeNumber != true || (entry1HasTypeNumber == false || entry0NumberValue &lt;= entry1NumberValue)</test>
			<error>
				<message>Entry 0 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@0 &lt;= @1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-1" testNumber="8"/>
			<description>Entry 1 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= @0)</description>
			<test>entry1HasTypeNumber != true || (entry0HasTypeNumber == false || entry1NumberValue &gt;= entry0NumberValue)</test>
			<error>
				<message>Entry 1 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= @0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-2" testNumber="8"/>
			<description>Entry 2 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@2 &lt;= @3)</description>
			<test>entry2HasTypeNumber != true || (entry3HasTypeNumber == false || entry2NumberValue &lt;= entry3NumberValue)</test>
			<error>
				<message>Entry 2 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@2 &lt;= @3)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-3" testNumber="8"/>
			<description>Entry 3 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_2" clause="LabRangeArray-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@3 &gt;= @2)</description>
			<test>entry3HasTypeNumber != true || (entry2HasTypeNumber == false || entry3NumberValue &gt;= entry2NumberValue)</test>
			<error>
				<message>Entry 3 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@3 &gt;= @2)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict" testNumber="1"/>
			<description>LinearizationParameterDict shall not contain entries except P, T, E, Linearized, H, L, N, O</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'T' &amp;&amp; elem != 'E' &amp;&amp; elem != 'Linearized' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'N' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>LinearizationParameterDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'T' &amp;&amp; elem != 'E' &amp;&amp; elem != 'Linearized' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'N' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-E" testNumber="8"/>
			<description>Entry E in LinearizationParameterDict shall have type Integer</description>
			<test>containsE == false || EHasTypeInteger == true</test>
			<error>
				<message>Entry E in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-E" testNumber="7"/>
			<description>Entry E in LinearizationParameterDict is required</description>
			<test>containsE == true</test>
			<error>
				<message>Entry E in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-E-Integer" testNumber="10"/>
			<description>Entry E with type Integer in LinearizationParameterDict shall be direct</description>
			<test>EHasTypeInteger != true || isEIndirect == false</test>
			<error>
				<message>Entry E with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-E-Integer" testNumber="14"/>
			<description>Entry E with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval((@E &gt; 0) &amp;&amp; (@E &lt;= @L))</description>
			<test>EHasTypeInteger != true || (EIntegerValue &gt; 0) &amp;&amp; (LHasTypeInteger == false || (EIntegerValue &lt;= LIntegerValue))</test>
			<error>
				<message>Entry E with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval((@E &gt; 0) &amp;&amp; (@E &lt;= @L))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-H-Array" testNumber="17"/>
			<description>Entry H with type Array in LinearizationParameterDict shall be one of objects ArrayOf_2Integers, ArrayOf_4Integers</description>
			<test>HHasTypeArray != true || H_size == 1</test>
			<error>
				<message>Entry H with type Array in LinearizationParameterDict is not one of objects ArrayOf_2Integers, ArrayOf_4Integers</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-H" testNumber="8"/>
			<description>Entry H in LinearizationParameterDict shall have type Array</description>
			<test>containsH == false || HHasTypeArray == true</test>
			<error>
				<message>Entry H in LinearizationParameterDict has type %1 instead of type Array</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-H" testNumber="7"/>
			<description>Entry H in LinearizationParameterDict is required</description>
			<test>containsH == true</test>
			<error>
				<message>Entry H in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-H-Array" testNumber="10"/>
			<description>Entry H with type Array in LinearizationParameterDict shall be direct</description>
			<test>HHasTypeArray != true || isHIndirect == false</test>
			<error>
				<message>Entry H with type Array in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-L" testNumber="8"/>
			<description>Entry L in LinearizationParameterDict shall have type Integer</description>
			<test>containsL == false || LHasTypeInteger == true</test>
			<error>
				<message>Entry L in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>LType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-L" testNumber="7"/>
			<description>Entry L in LinearizationParameterDict is required</description>
			<test>containsL == true</test>
			<error>
				<message>Entry L in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-L-Integer" testNumber="10"/>
			<description>Entry L with type Integer in LinearizationParameterDict shall be direct</description>
			<test>LHasTypeInteger != true || isLIndirect == false</test>
			<error>
				<message>Entry L with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-L-Integer" testNumber="14"/>
			<description>Entry L with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@L &gt; 0)</description>
			<test>LHasTypeInteger != true || LIntegerValue &gt; 0</test>
			<error>
				<message>Entry L with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@L &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-Linearized" testNumber="8"/>
			<description>Entry Linearized in LinearizationParameterDict shall have type Number</description>
			<test>containsLinearized == false || LinearizedHasTypeNumber == true</test>
			<error>
				<message>Entry Linearized in LinearizationParameterDict has type %1 instead of type Number</message>
				<arguments>
					<argument>LinearizedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-Linearized" testNumber="7"/>
			<description>Entry Linearized in LinearizationParameterDict is required</description>
			<test>containsLinearized == true</test>
			<error>
				<message>Entry Linearized in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-Linearized-Number" testNumber="10"/>
			<description>Entry Linearized with type Number in LinearizationParameterDict shall be direct</description>
			<test>LinearizedHasTypeNumber != true || isLinearizedIndirect == false</test>
			<error>
				<message>Entry Linearized with type Number in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-Linearized-Number" testNumber="6"/>
			<description>Entry Linearized with type Number in LinearizationParameterDict shall have value 1.0</description>
			<test>LinearizedHasTypeNumber != true || LinearizedNumberValue == 1.0</test>
			<error>
				<message>Entry Linearized with type Number in LinearizationParameterDict has incorrect value %1 instead of 1.0</message>
				<arguments>
					<argument>LinearizedNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-N" testNumber="8"/>
			<description>Entry N in LinearizationParameterDict shall have type Integer</description>
			<test>containsN == false || NHasTypeInteger == true</test>
			<error>
				<message>Entry N in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-N" testNumber="7"/>
			<description>Entry N in LinearizationParameterDict is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-N-Integer" testNumber="10"/>
			<description>Entry N with type Integer in LinearizationParameterDict shall be direct</description>
			<test>NHasTypeInteger != true || isNIndirect == false</test>
			<error>
				<message>Entry N with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-N-Integer" testNumber="14"/>
			<description>Entry N with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@N &gt; 0)</description>
			<test>NHasTypeInteger != true || NIntegerValue &gt; 0</test>
			<error>
				<message>Entry N with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@N &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-O" testNumber="8"/>
			<description>Entry O in LinearizationParameterDict shall have type Integer</description>
			<test>containsO == false || OHasTypeInteger == true</test>
			<error>
				<message>Entry O in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-O" testNumber="7"/>
			<description>Entry O in LinearizationParameterDict is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-O-Integer" testNumber="10"/>
			<description>Entry O with type Integer in LinearizationParameterDict shall be direct</description>
			<test>OHasTypeInteger != true || isOIndirect == false</test>
			<error>
				<message>Entry O with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-O-Integer" testNumber="14"/>
			<description>Entry O with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@O &gt; 0)</description>
			<test>OHasTypeInteger != true || OIntegerValue &gt; 0</test>
			<error>
				<message>Entry O with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@O &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-P" testNumber="8"/>
			<description>Entry P in LinearizationParameterDict shall have type Integer</description>
			<test>containsP == false || PHasTypeInteger == true</test>
			<error>
				<message>Entry P in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-P-Integer" testNumber="10"/>
			<description>Entry P with type Integer in LinearizationParameterDict shall be direct</description>
			<test>PHasTypeInteger != true || isPIndirect == false</test>
			<error>
				<message>Entry P with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-P-Integer" testNumber="14"/>
			<description>Entry P with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@P &gt;= 0)</description>
			<test>PHasTypeInteger != true || PIntegerValue &gt;= 0</test>
			<error>
				<message>Entry P with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@P &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-T" testNumber="8"/>
			<description>Entry T in LinearizationParameterDict shall have type Integer</description>
			<test>containsT == false || THasTypeInteger == true</test>
			<error>
				<message>Entry T in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-T" testNumber="7"/>
			<description>Entry T in LinearizationParameterDict is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-T-Integer" testNumber="10"/>
			<description>Entry T with type Integer in LinearizationParameterDict shall be direct</description>
			<test>THasTypeInteger != true || isTIndirect == false</test>
			<error>
				<message>Entry T with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_2" clause="LinearizationParameterDict-T-Integer" testNumber="14"/>
			<description>Entry T with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@T &gt; 0)</description>
			<test>THasTypeInteger != true || TIntegerValue &gt; 0</test>
			<error>
				<message>Entry T with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@T &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam" testNumber="1"/>
			<description>MicrosoftWindowsLaunchParam shall not contain entries except P, D, F, O</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MicrosoftWindowsLaunchParam contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-D" testNumber="8"/>
			<description>Entry D in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsD == false || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-F" testNumber="8"/>
			<description>Entry F in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsF == false || FHasTypeStringByte == true</test>
			<error>
				<message>Entry F in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-F" testNumber="7"/>
			<description>Entry F in MicrosoftWindowsLaunchParam is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in MicrosoftWindowsLaunchParam is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-O" testNumber="8"/>
			<description>Entry O in MicrosoftWindowsLaunchParam shall have type StringAscii</description>
			<test>containsO == false || OHasTypeStringAscii == true</test>
			<error>
				<message>Entry O in MicrosoftWindowsLaunchParam has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-O-StringAscii" testNumber="6"/>
			<description>Entry O with type StringAscii in MicrosoftWindowsLaunchParam shall have one of values: print, open</description>
			<test>OHasTypeStringAscii != true || OStringAsciiValue == "open" || OStringAsciiValue == "print"</test>
			<error>
				<message>Entry O with type StringAscii in MicrosoftWindowsLaunchParam has incorrect value %1 instead of print, open</message>
				<arguments>
					<argument>OStringAsciiValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_2" clause="MicrosoftWindowsLaunchParam-P" testNumber="8"/>
			<description>Entry P in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsP == false || PHasTypeStringByte == true</test>
			<error>
				<message>Entry P in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie" testNumber="1"/>
			<description>Movie shall not contain entries except Rotate, F, Poster, Aspect</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Rotate' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Poster' &amp;&amp; elem != 'Aspect' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Movie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Rotate' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Poster' &amp;&amp; elem != 'Aspect' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-Aspect" testNumber="8"/>
			<description>Entry Aspect in Movie shall have type Array</description>
			<test>containsAspect == false || AspectHasTypeArray == true</test>
			<error>
				<message>Entry Aspect in Movie has type %1 instead of type Array</message>
				<arguments>
					<argument>AspectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-F" testNumber="8"/>
			<description>Entry F in Movie shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Movie has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-F" testNumber="7"/>
			<description>Entry F in Movie is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in Movie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-Poster" testNumber="8"/>
			<description>Entry Poster in Movie shall have one of types: Boolean, Stream</description>
			<test>containsPoster == false || PosterHasTypeBoolean == true || PosterHasTypeStream == true</test>
			<error>
				<message>Entry Poster in Movie has type %1 instead of one of types: Boolean, Stream</message>
				<arguments>
					<argument>PosterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-Poster-Stream" testNumber="10"/>
			<description>Entry Poster with type Stream in Movie shall be indirect</description>
			<test>PosterHasTypeStream != true || isPosterIndirect == true</test>
			<error>
				<message>Entry Poster with type Stream in Movie is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-Rotate" testNumber="8"/>
			<description>Entry Rotate in Movie shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in Movie has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_2" clause="Movie-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in Movie shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in Movie does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation" testNumber="1"/>
			<description>MovieActivation shall not contain entries except FWScale, Synchronous, Start, Volume, Rate, Mode, FWPosition, Duration, ShowControls</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FWScale' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Start' &amp;&amp; elem != 'Volume' &amp;&amp; elem != 'Rate' &amp;&amp; elem != 'Mode' &amp;&amp; elem != 'FWPosition' &amp;&amp; elem != 'Duration' &amp;&amp; elem != 'ShowControls' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MovieActivation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FWScale' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Start' &amp;&amp; elem != 'Volume' &amp;&amp; elem != 'Rate' &amp;&amp; elem != 'Mode' &amp;&amp; elem != 'FWPosition' &amp;&amp; elem != 'Duration' &amp;&amp; elem != 'ShowControls' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Duration" testNumber="8"/>
			<description>Entry Duration in MovieActivation shall have one of types: Array, Integer, StringByte</description>
			<test>containsDuration == false || DurationHasTypeArray == true || DurationHasTypeInteger == true || DurationHasTypeStringByte == true</test>
			<error>
				<message>Entry Duration in MovieActivation has type %1 instead of one of types: Array, Integer, StringByte</message>
				<arguments>
					<argument>DurationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Duration-Integer" testNumber="9"/>
			<description>Entry Duration with type Integer in MovieActivation shall satisfy special case: fn:Eval(@Duration &gt; 0)</description>
			<test>DurationHasTypeInteger != true || (DurationIntegerValue &gt; 0)</test>
			<error>
				<message>Entry Duration with type Integer in MovieActivation does not satisfy special case: fn:Eval(@Duration &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Duration-StringByte" testNumber="9"/>
			<description>Entry Duration with type StringByte in MovieActivation shall satisfy special case: fn:Eval(fn:StringLength(Duration) == 8)</description>
			<test>DurationHasTypeStringByte != true || (DurationStringSize == 8)</test>
			<error>
				<message>Entry Duration with type StringByte in MovieActivation does not satisfy special case: fn:Eval(fn:StringLength(Duration) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-FWPosition" testNumber="8"/>
			<description>Entry FWPosition in MovieActivation shall have type Array</description>
			<test>containsFWPosition == false || FWPositionHasTypeArray == true</test>
			<error>
				<message>Entry FWPosition in MovieActivation has type %1 instead of type Array</message>
				<arguments>
					<argument>FWPositionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-FWPosition-Array" testNumber="9"/>
			<description>Entry FWPosition with type Array in MovieActivation shall satisfy special case: fn:Eval((FWPosition::@0 &gt;= 0.0) &amp;&amp; (FWPosition::@0 &lt;= 1.0) &amp;&amp; (FWPosition::@1 &gt;= 0.0) &amp;&amp; (FWPosition::@1 &lt;= 1.0))</description>
			<test>FWPositionHasTypeArray != true || ((FWPosition0HasTypeNumber == false || (FWPosition0NumberValue &gt;= 0.0) &amp;&amp; (FWPosition0NumberValue &lt;= 1.0)) &amp;&amp; (FWPosition1HasTypeNumber == false || (FWPosition1NumberValue &gt;= 0.0)) &amp;&amp; (FWPosition1HasTypeNumber == false || (FWPosition1NumberValue &lt;= 1.0)))</test>
			<error>
				<message>Entry FWPosition with type Array in MovieActivation does not satisfy special case: fn:Eval((FWPosition::@0 &gt;= 0.0) &amp;&amp; (FWPosition::@0 &lt;= 1.0) &amp;&amp; (FWPosition::@1 &gt;= 0.0) &amp;&amp; (FWPosition::@1 &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-FWScale" testNumber="8"/>
			<description>Entry FWScale in MovieActivation shall have type Array</description>
			<test>containsFWScale == false || FWScaleHasTypeArray == true</test>
			<error>
				<message>Entry FWScale in MovieActivation has type %1 instead of type Array</message>
				<arguments>
					<argument>FWScaleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-FWScale-Array" testNumber="9"/>
			<description>Entry FWScale with type Array in MovieActivation shall satisfy special case: fn:Eval((FWScale::@0 &gt; 0) &amp;&amp; (FWScale::@1 &gt; 0))</description>
			<test>FWScaleHasTypeArray != true || ((FWScale0HasTypeInteger == false || (FWScale0IntegerValue &gt; 0)) &amp;&amp; (FWScale1HasTypeInteger == false || (FWScale1IntegerValue &gt; 0)))</test>
			<error>
				<message>Entry FWScale with type Array in MovieActivation does not satisfy special case: fn:Eval((FWScale::@0 &gt; 0) &amp;&amp; (FWScale::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Mode" testNumber="8"/>
			<description>Entry Mode in MovieActivation shall have type Name</description>
			<test>containsMode == false || ModeHasTypeName == true</test>
			<error>
				<message>Entry Mode in MovieActivation has type %1 instead of type Name</message>
				<arguments>
					<argument>ModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Mode-Name" testNumber="6"/>
			<description>Entry Mode with type Name in MovieActivation shall have one of values: Palindrome, Once, Repeat, Open</description>
			<test>ModeHasTypeName != true || ModeNameValue == "Once" || ModeNameValue == "Open" || ModeNameValue == "Repeat" || ModeNameValue == "Palindrome"</test>
			<error>
				<message>Entry Mode with type Name in MovieActivation has incorrect value %1 instead of Palindrome, Once, Repeat, Open</message>
				<arguments>
					<argument>ModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Rate" testNumber="8"/>
			<description>Entry Rate in MovieActivation shall have type Number</description>
			<test>containsRate == false || RateHasTypeNumber == true</test>
			<error>
				<message>Entry Rate in MovieActivation has type %1 instead of type Number</message>
				<arguments>
					<argument>RateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-ShowControls" testNumber="8"/>
			<description>Entry ShowControls in MovieActivation shall have type Boolean</description>
			<test>containsShowControls == false || ShowControlsHasTypeBoolean == true</test>
			<error>
				<message>Entry ShowControls in MovieActivation has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ShowControlsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Start" testNumber="8"/>
			<description>Entry Start in MovieActivation shall have one of types: Array, Integer, StringByte</description>
			<test>containsStart == false || StartHasTypeArray == true || StartHasTypeInteger == true || StartHasTypeStringByte == true</test>
			<error>
				<message>Entry Start in MovieActivation has type %1 instead of one of types: Array, Integer, StringByte</message>
				<arguments>
					<argument>StartType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Start-Integer" testNumber="9"/>
			<description>Entry Start with type Integer in MovieActivation shall satisfy special case: fn:Eval(@Start &gt;= 0)</description>
			<test>StartHasTypeInteger != true || (StartIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Start with type Integer in MovieActivation does not satisfy special case: fn:Eval(@Start &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Start-StringByte" testNumber="9"/>
			<description>Entry Start with type StringByte in MovieActivation shall satisfy special case: fn:Eval(fn:StringLength(Start) == 8)</description>
			<test>StartHasTypeStringByte != true || (StartStringSize == 8)</test>
			<error>
				<message>Entry Start with type StringByte in MovieActivation does not satisfy special case: fn:Eval(fn:StringLength(Start) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Synchronous" testNumber="8"/>
			<description>Entry Synchronous in MovieActivation shall have type Boolean</description>
			<test>containsSynchronous == false || SynchronousHasTypeBoolean == true</test>
			<error>
				<message>Entry Synchronous in MovieActivation has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SynchronousType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Volume" testNumber="8"/>
			<description>Entry Volume in MovieActivation shall have type Number</description>
			<test>containsVolume == false || VolumeHasTypeNumber == true</test>
			<error>
				<message>Entry Volume in MovieActivation has type %1 instead of type Number</message>
				<arguments>
					<argument>VolumeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_2" clause="MovieActivation-Volume-Number" testNumber="14"/>
			<description>Entry Volume with type Number in MovieActivation shall satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</description>
			<test>VolumeHasTypeNumber != true || (VolumeNumberValue &gt;= -1) &amp;&amp; (VolumeNumberValue &lt;= 1)</test>
			<error>
				<message>Entry Volume with type Number in MovieActivation does not satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_2" clause="Name" testNumber="1"/>
			<description>Name shall not contain entries except Dests</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Pages' &amp;&amp; elem != 'URLS' &amp;&amp; elem != 'JavaScript' &amp;&amp; elem != 'Renditions' &amp;&amp; elem != 'IDS' &amp;&amp; elem != 'Templates' &amp;&amp; elem != 'AlternatePresentations' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'XFAResources' &amp;&amp; elem != 'EmbeddedFiles' &amp;&amp; elem != 'AP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Name contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Pages' &amp;&amp; elem != 'URLS' &amp;&amp; elem != 'JavaScript' &amp;&amp; elem != 'Renditions' &amp;&amp; elem != 'IDS' &amp;&amp; elem != 'Templates' &amp;&amp; elem != 'AlternatePresentations' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'XFAResources' &amp;&amp; elem != 'EmbeddedFiles' &amp;&amp; elem != 'AP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_2" clause="Name" testNumber="22"/>
			<description>Name shall not contain entries Pages, URLS, JavaScript, Renditions, IDS, Templates, AlternatePresentations, XFAResources, EmbeddedFiles, AP in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Pages' || elem == 'URLS' || elem == 'JavaScript' || elem == 'Renditions' || elem == 'IDS' || elem == 'Templates' || elem == 'AlternatePresentations' || elem == 'XFAResources' || elem == 'EmbeddedFiles' || elem == 'AP').length == 0</test>
			<error>
				<message>Name contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Pages' || elem == 'URLS' || elem == 'JavaScript' || elem == 'Renditions' || elem == 'IDS' || elem == 'Templates' || elem == 'AlternatePresentations' || elem == 'XFAResources' || elem == 'EmbeddedFiles' || elem == 'AP').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_2" clause="Name-Dests" testNumber="8"/>
			<description>Entry Dests in Name shall have type NameTree</description>
			<test>containsDests == false || DestsHasTypeNameTree == true</test>
			<error>
				<message>Entry Dests in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>DestsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeDestsEntry">
			<id specification="PDF_1_2" clause="NameNameTreeDestsEntry-Array" testNumber="17"/>
			<description>Entry with type Array in NameNameTreeDests shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in NameNameTreeDests is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeDestsEntry">
			<id specification="PDF_1_2" clause="NameNameTreeDestsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in NameNameTreeDests shall be one of objects ActionGoTo, ActionGoToR, DestDict</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in NameNameTreeDests is not one of objects ActionGoTo, ActionGoToR, DestDict</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13">
			<id specification="PDF_1_2" clause="OPIVersion13" testNumber="1"/>
			<description>OPIVersion13 shall not contain entries except 1.3</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != '1.3' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion13 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != '1.3' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13">
			<id specification="PDF_1_2" clause="OPIVersion13-1.3" testNumber="8"/>
			<description>Entry 1.3 in OPIVersion13 shall have type Dictionary</description>
			<test>contains13 == false || entry13HasTypeDictionary == true</test>
			<error>
				<message>Entry 1.3 in OPIVersion13 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry13Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict" testNumber="1"/>
			<description>OPIVersion13Dict shall not contain entries except Transparency, CropRect, Position, Comments, F, Size, Color, GrayMap, CropFixed, ImageType, Type, Version, ColorType, ID, Tint, Tags, Overprint, Resolution</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Transparency' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'Position' &amp;&amp; elem != 'Comments' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'GrayMap' &amp;&amp; elem != 'CropFixed' &amp;&amp; elem != 'ImageType' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ColorType' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Tint' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Resolution' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion13Dict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Transparency' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'Position' &amp;&amp; elem != 'Comments' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'GrayMap' &amp;&amp; elem != 'CropFixed' &amp;&amp; elem != 'ImageType' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ColorType' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Tint' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Resolution' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Color" testNumber="8"/>
			<description>Entry Color in OPIVersion13Dict shall have type Array</description>
			<test>containsColor == false || ColorHasTypeArray == true</test>
			<error>
				<message>Entry Color in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ColorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-ColorType" testNumber="8"/>
			<description>Entry ColorType in OPIVersion13Dict shall have type Name</description>
			<test>containsColorType == false || ColorTypeHasTypeName == true</test>
			<error>
				<message>Entry ColorType in OPIVersion13Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>ColorTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Comments" testNumber="8"/>
			<description>Entry Comments in OPIVersion13Dict shall have type StringText</description>
			<test>containsComments == false || CommentsHasTypeStringText == true</test>
			<error>
				<message>Entry Comments in OPIVersion13Dict has type %1 instead of type StringText</message>
				<arguments>
					<argument>CommentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-CropFixed" testNumber="8"/>
			<description>Entry CropFixed in OPIVersion13Dict shall have type Array</description>
			<test>containsCropFixed == false || CropFixedHasTypeArray == true</test>
			<error>
				<message>Entry CropFixed in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>CropFixedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-CropRect" testNumber="8"/>
			<description>Entry CropRect in OPIVersion13Dict shall have type Rectangle</description>
			<test>containsCropRect == false || CropRectHasTypeRectangle == true</test>
			<error>
				<message>Entry CropRect in OPIVersion13Dict has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropRectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-F" testNumber="8"/>
			<description>Entry F in OPIVersion13Dict shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in OPIVersion13Dict has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-F" testNumber="7"/>
			<description>Entry F in OPIVersion13Dict is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in OPIVersion13Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-GrayMap" testNumber="8"/>
			<description>Entry GrayMap in OPIVersion13Dict shall have type Array</description>
			<test>containsGrayMap == false || GrayMapHasTypeArray == true</test>
			<error>
				<message>Entry GrayMap in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>GrayMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-GrayMap-Array" testNumber="9"/>
			<description>Entry GrayMap with type Array in OPIVersion13Dict shall satisfy special case: fn:Eval((fn:ArrayLength(GrayMap) mod 2) == 0)</description>
			<test>GrayMapHasTypeArray != true || ((GrayMapArraySize % 2) == 0)</test>
			<error>
				<message>Entry GrayMap with type Array in OPIVersion13Dict does not satisfy special case: fn:Eval((fn:ArrayLength(GrayMap) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-ID" testNumber="8"/>
			<description>Entry ID in OPIVersion13Dict shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in OPIVersion13Dict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-ImageType" testNumber="8"/>
			<description>Entry ImageType in OPIVersion13Dict shall have type Array</description>
			<test>containsImageType == false || ImageTypeHasTypeArray == true</test>
			<error>
				<message>Entry ImageType in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ImageTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Overprint" testNumber="8"/>
			<description>Entry Overprint in OPIVersion13Dict shall have type Boolean</description>
			<test>containsOverprint == false || OverprintHasTypeBoolean == true</test>
			<error>
				<message>Entry Overprint in OPIVersion13Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OverprintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Position" testNumber="8"/>
			<description>Entry Position in OPIVersion13Dict shall have type Array</description>
			<test>containsPosition == false || PositionHasTypeArray == true</test>
			<error>
				<message>Entry Position in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>PositionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Resolution" testNumber="8"/>
			<description>Entry Resolution in OPIVersion13Dict shall have type Array</description>
			<test>containsResolution == false || ResolutionHasTypeArray == true</test>
			<error>
				<message>Entry Resolution in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ResolutionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Size" testNumber="8"/>
			<description>Entry Size in OPIVersion13Dict shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Tags" testNumber="8"/>
			<description>Entry Tags in OPIVersion13Dict shall have type Array</description>
			<test>containsTags == false || TagsHasTypeArray == true</test>
			<error>
				<message>Entry Tags in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>TagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Tint" testNumber="8"/>
			<description>Entry Tint in OPIVersion13Dict shall have type Number</description>
			<test>containsTint == false || TintHasTypeNumber == true</test>
			<error>
				<message>Entry Tint in OPIVersion13Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>TintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Transparency" testNumber="8"/>
			<description>Entry Transparency in OPIVersion13Dict shall have type Boolean</description>
			<test>containsTransparency == false || TransparencyHasTypeBoolean == true</test>
			<error>
				<message>Entry Transparency in OPIVersion13Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>TransparencyType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Type" testNumber="8"/>
			<description>Entry Type in OPIVersion13Dict shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in OPIVersion13Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in OPIVersion13Dict shall have value OPI</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OPI"</test>
			<error>
				<message>Entry Type with type Name in OPIVersion13Dict has incorrect value %1 instead of OPI</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Version" testNumber="8"/>
			<description>Entry Version in OPIVersion13Dict shall have type Number</description>
			<test>containsVersion == false || VersionHasTypeNumber == true</test>
			<error>
				<message>Entry Version in OPIVersion13Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Version" testNumber="7"/>
			<description>Entry Version in OPIVersion13Dict is required</description>
			<test>containsVersion == true</test>
			<error>
				<message>Entry Version in OPIVersion13Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_2" clause="OPIVersion13Dict-Version-Number" testNumber="6"/>
			<description>Entry Version with type Number in OPIVersion13Dict shall have value 1.3</description>
			<test>VersionHasTypeNumber != true || VersionNumberValue == 1.3</test>
			<error>
				<message>Entry Version with type Number in OPIVersion13Dict has incorrect value %1 instead of 1.3</message>
				<arguments>
					<argument>VersionNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20">
			<id specification="PDF_1_2" clause="OPIVersion20" testNumber="1"/>
			<description>OPIVersion20 shall not contain entries except 2.0</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != '2.0' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion20 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != '2.0' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20">
			<id specification="PDF_1_2" clause="OPIVersion20-2.0" testNumber="8"/>
			<description>Entry 2.0 in OPIVersion20 shall have type Dictionary</description>
			<test>contains20 == false || entry20HasTypeDictionary == true</test>
			<error>
				<message>Entry 2.0 in OPIVersion20 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry20Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict" testNumber="1"/>
			<description>OPIVersion20Dict shall not contain entries except MainImage, Type, CropRect, IncludedImageQuality, Version, F, Size, IncludedImageDimensions, Tags, Inks, Overprint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'MainImage' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'IncludedImageQuality' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'IncludedImageDimensions' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Inks' &amp;&amp; elem != 'Overprint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion20Dict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'MainImage' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'IncludedImageQuality' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'IncludedImageDimensions' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Inks' &amp;&amp; elem != 'Overprint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-CropRect" testNumber="8"/>
			<description>Entry CropRect in OPIVersion20Dict shall have type Rectangle</description>
			<test>containsCropRect == false || CropRectHasTypeRectangle == true</test>
			<error>
				<message>Entry CropRect in OPIVersion20Dict has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropRectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-CropRect" testNumber="11"/>
			<description>Entry CropRect in OPIVersion20Dict is required, when fn:IsPresent(Size)</description>
			<test>containsCropRect == true || (containsSize != true)</test>
			<error>
				<message>Entry CropRect in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-F" testNumber="8"/>
			<description>Entry F in OPIVersion20Dict shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in OPIVersion20Dict has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-F" testNumber="7"/>
			<description>Entry F in OPIVersion20Dict is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-IncludedImageDimensions" testNumber="8"/>
			<description>Entry IncludedImageDimensions in OPIVersion20Dict shall have type Array</description>
			<test>containsIncludedImageDimensions == false || IncludedImageDimensionsHasTypeArray == true</test>
			<error>
				<message>Entry IncludedImageDimensions in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>IncludedImageDimensionsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-IncludedImageDimensions-Array" testNumber="9"/>
			<description>Entry IncludedImageDimensions with type Array in OPIVersion20Dict shall satisfy special case: fn:Eval((IncludedImageDimensions::@0 &gt; 0) &amp;&amp; (IncludedImageDimensions::@1 &gt; 0))</description>
			<test>IncludedImageDimensionsHasTypeArray != true || ((IncludedImageDimensions0HasTypeInteger == false || (IncludedImageDimensions0IntegerValue &gt; 0)) &amp;&amp; (IncludedImageDimensions1HasTypeInteger == false || (IncludedImageDimensions1IntegerValue &gt; 0)))</test>
			<error>
				<message>Entry IncludedImageDimensions with type Array in OPIVersion20Dict does not satisfy special case: fn:Eval((IncludedImageDimensions::@0 &gt; 0) &amp;&amp; (IncludedImageDimensions::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-IncludedImageQuality" testNumber="8"/>
			<description>Entry IncludedImageQuality in OPIVersion20Dict shall have type Number</description>
			<test>containsIncludedImageQuality == false || IncludedImageQualityHasTypeNumber == true</test>
			<error>
				<message>Entry IncludedImageQuality in OPIVersion20Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>IncludedImageQualityType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-IncludedImageQuality-Number" testNumber="6"/>
			<description>Entry IncludedImageQuality with type Number in OPIVersion20Dict shall have one of values: 1, 2, 3</description>
			<test>IncludedImageQualityHasTypeNumber != true || IncludedImageQualityNumberValue == 1 || IncludedImageQualityNumberValue == 2 || IncludedImageQualityNumberValue == 3</test>
			<error>
				<message>Entry IncludedImageQuality with type Number in OPIVersion20Dict has incorrect value %1 instead of 1, 2, 3</message>
				<arguments>
					<argument>IncludedImageQualityNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Inks" testNumber="8"/>
			<description>Entry Inks in OPIVersion20Dict shall have one of types: Array, Name</description>
			<test>containsInks == false || InksHasTypeArray == true || InksHasTypeName == true</test>
			<error>
				<message>Entry Inks in OPIVersion20Dict has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>InksType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Inks-Name" testNumber="6"/>
			<description>Entry Inks with type Name in OPIVersion20Dict shall have one of values: registration, full_color</description>
			<test>InksHasTypeName != true || InksNameValue == "full_color" || InksNameValue == "registration"</test>
			<error>
				<message>Entry Inks with type Name in OPIVersion20Dict has incorrect value %1 instead of registration, full_color</message>
				<arguments>
					<argument>InksNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-MainImage" testNumber="8"/>
			<description>Entry MainImage in OPIVersion20Dict shall have type StringByte</description>
			<test>containsMainImage == false || MainImageHasTypeStringByte == true</test>
			<error>
				<message>Entry MainImage in OPIVersion20Dict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>MainImageType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Overprint" testNumber="8"/>
			<description>Entry Overprint in OPIVersion20Dict shall have type Boolean</description>
			<test>containsOverprint == false || OverprintHasTypeBoolean == true</test>
			<error>
				<message>Entry Overprint in OPIVersion20Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OverprintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Size" testNumber="8"/>
			<description>Entry Size in OPIVersion20Dict shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Size" testNumber="11"/>
			<description>Entry Size in OPIVersion20Dict is required, when fn:IsPresent(CropRect)</description>
			<test>containsSize == true || (containsCropRect != true)</test>
			<error>
				<message>Entry Size in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Size-Array" testNumber="9"/>
			<description>Entry Size with type Array in OPIVersion20Dict shall satisfy special case: fn:Eval((Size::@0 &gt; 0) &amp;&amp; (Size::@1 &gt; 0))</description>
			<test>SizeHasTypeArray != true || ((Size0HasTypeNumber == false || (Size0NumberValue &gt; 0)) &amp;&amp; (Size1HasTypeNumber == false || (Size1NumberValue &gt; 0)))</test>
			<error>
				<message>Entry Size with type Array in OPIVersion20Dict does not satisfy special case: fn:Eval((Size::@0 &gt; 0) &amp;&amp; (Size::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Tags" testNumber="8"/>
			<description>Entry Tags in OPIVersion20Dict shall have type Array</description>
			<test>containsTags == false || TagsHasTypeArray == true</test>
			<error>
				<message>Entry Tags in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>TagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Type" testNumber="8"/>
			<description>Entry Type in OPIVersion20Dict shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in OPIVersion20Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in OPIVersion20Dict shall have value OPI</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OPI"</test>
			<error>
				<message>Entry Type with type Name in OPIVersion20Dict has incorrect value %1 instead of OPI</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Version" testNumber="8"/>
			<description>Entry Version in OPIVersion20Dict shall have type Number</description>
			<test>containsVersion == false || VersionHasTypeNumber == true</test>
			<error>
				<message>Entry Version in OPIVersion20Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Version" testNumber="7"/>
			<description>Entry Version in OPIVersion20Dict is required</description>
			<test>containsVersion == true</test>
			<error>
				<message>Entry Version in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_2" clause="OPIVersion20Dict-Version-Number" testNumber="6"/>
			<description>Entry Version with type Number in OPIVersion20Dict shall have value 2.0</description>
			<test>VersionHasTypeNumber != true || VersionNumberValue == 2.0</test>
			<error>
				<message>Entry Version with type Number in OPIVersion20Dict has incorrect value %1 instead of 2.0</message>
				<arguments>
					<argument>VersionNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline" testNumber="1"/>
			<description>Outline shall not contain entries except Last, Type, Count, First</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Last' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Outline contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Last' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Count" testNumber="8"/>
			<description>Entry Count in Outline shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in Outline has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in Outline shall satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Count with type Integer in Outline does not satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-First" testNumber="8"/>
			<description>Entry First in Outline shall have type Dictionary</description>
			<test>containsFirst == false || FirstHasTypeDictionary == true</test>
			<error>
				<message>Entry First in Outline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FirstType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-First-Dictionary" testNumber="10"/>
			<description>Entry First with type Dictionary in Outline shall be indirect</description>
			<test>FirstHasTypeDictionary != true || isFirstIndirect == true</test>
			<error>
				<message>Entry First with type Dictionary in Outline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Last" testNumber="8"/>
			<description>Entry Last in Outline shall have type Dictionary</description>
			<test>containsLast == false || LastHasTypeDictionary == true</test>
			<error>
				<message>Entry Last in Outline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>LastType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Last-Dictionary" testNumber="10"/>
			<description>Entry Last with type Dictionary in Outline shall be indirect</description>
			<test>LastHasTypeDictionary != true || isLastIndirect == true</test>
			<error>
				<message>Entry Last with type Dictionary in Outline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Type" testNumber="8"/>
			<description>Entry Type in Outline shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Outline has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_2" clause="Outline-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Outline shall have value Outlines</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Outlines"</test>
			<error>
				<message>Entry Type with type Name in Outline has incorrect value %1 instead of Outlines</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem" testNumber="1"/>
			<description>OutlineItem shall not contain entries except A, Dest, Last, Parent, Prev, Next, Title, Count, First</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'SE' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Title' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OutlineItem contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'SE' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Title' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem" testNumber="22"/>
			<description>OutlineItem shall not contain entries SE, C, F in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'SE' || elem == 'C' || elem == 'F').length == 0</test>
			<error>
				<message>OutlineItem contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'SE' || elem == 'C' || elem == 'F').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in OutlineItem shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in OutlineItem is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionNOP, ActionSetState, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-A" testNumber="8"/>
			<description>Entry A in OutlineItem shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-A-Dictionary" testNumber="9"/>
			<description>Entry A with type Dictionary in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(Dest))</description>
			<test>AHasTypeDictionary != true || (containsDest != true)</test>
			<error>
				<message>Entry A with type Dictionary in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(Dest))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Count" testNumber="8"/>
			<description>Entry Count in OutlineItem shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in OutlineItem has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Dest-Array" testNumber="17"/>
			<description>Entry Dest with type Array in OutlineItem shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DestHasTypeArray != true || Dest_size == 1</test>
			<error>
				<message>Entry Dest with type Array in OutlineItem is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Dest" testNumber="8"/>
			<description>Entry Dest in OutlineItem shall have one of types: Array, Name, StringByte</description>
			<test>containsDest == false || DestHasTypeArray == true || DestHasTypeName == true || DestHasTypeStringByte == true</test>
			<error>
				<message>Entry Dest in OutlineItem has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DestType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Dest-Array" testNumber="9"/>
			<description>Entry Dest with type Array in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeArray != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type Array in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Dest-Name" testNumber="9"/>
			<description>Entry Dest with type Name in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeName != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type Name in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Dest-StringByte" testNumber="9"/>
			<description>Entry Dest with type StringByte in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeStringByte != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type StringByte in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-First" testNumber="8"/>
			<description>Entry First in OutlineItem shall have type Dictionary</description>
			<test>containsFirst == false || FirstHasTypeDictionary == true</test>
			<error>
				<message>Entry First in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FirstType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-First-Dictionary" testNumber="10"/>
			<description>Entry First with type Dictionary in OutlineItem shall be indirect</description>
			<test>FirstHasTypeDictionary != true || isFirstIndirect == true</test>
			<error>
				<message>Entry First with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Last" testNumber="8"/>
			<description>Entry Last in OutlineItem shall have type Dictionary</description>
			<test>containsLast == false || LastHasTypeDictionary == true</test>
			<error>
				<message>Entry Last in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>LastType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Last-Dictionary" testNumber="10"/>
			<description>Entry Last with type Dictionary in OutlineItem shall be indirect</description>
			<test>LastHasTypeDictionary != true || isLastIndirect == true</test>
			<error>
				<message>Entry Last with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Next" testNumber="8"/>
			<description>Entry Next in OutlineItem shall have type Dictionary</description>
			<test>containsNext == false || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Next-Dictionary" testNumber="10"/>
			<description>Entry Next with type Dictionary in OutlineItem shall be indirect</description>
			<test>NextHasTypeDictionary != true || isNextIndirect == true</test>
			<error>
				<message>Entry Next with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in OutlineItem shall be one of objects OutlineItem, Outline</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in OutlineItem is not one of objects OutlineItem, Outline</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Parent" testNumber="8"/>
			<description>Entry Parent in OutlineItem shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Parent" testNumber="7"/>
			<description>Entry Parent in OutlineItem is required</description>
			<test>containsParent == true</test>
			<error>
				<message>Entry Parent in OutlineItem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in OutlineItem shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Prev" testNumber="8"/>
			<description>Entry Prev in OutlineItem shall have type Dictionary</description>
			<test>containsPrev == false || PrevHasTypeDictionary == true</test>
			<error>
				<message>Entry Prev in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PrevType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Prev-Dictionary" testNumber="10"/>
			<description>Entry Prev with type Dictionary in OutlineItem shall be indirect</description>
			<test>PrevHasTypeDictionary != true || isPrevIndirect == true</test>
			<error>
				<message>Entry Prev with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Title" testNumber="8"/>
			<description>Entry Title in OutlineItem shall have type StringText</description>
			<test>containsTitle == false || TitleHasTypeStringText == true</test>
			<error>
				<message>Entry Title in OutlineItem has type %1 instead of type StringText</message>
				<arguments>
					<argument>TitleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_2" clause="OutlineItem-Title" testNumber="7"/>
			<description>Entry Title in OutlineItem is required</description>
			<test>containsTitle == true</test>
			<error>
				<message>Entry Title in OutlineItem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject" testNumber="1"/>
			<description>PageObject shall not contain entries except B, Rotate, Parent, MediaBox, Trans, AA, Dur, Annots, CropBox, Hid, Thumb, Type, Contents, Resources</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Group' &amp;&amp; elem != 'B' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'TemplateInstantiated' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'PZ' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'SeparationInfo' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Trans' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Dur' &amp;&amp; elem != 'Annots' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Hid' &amp;&amp; elem != 'BoxColorInfo' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'TrimBox' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'ArtBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DPart' &amp;&amp; elem != 'PresSteps' &amp;&amp; elem != 'UserUnit' &amp;&amp; elem != 'Tabs' &amp;&amp; elem != 'VP' &amp;&amp; elem != 'Resources' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Group' &amp;&amp; elem != 'B' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'TemplateInstantiated' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'PZ' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'SeparationInfo' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Trans' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'Dur' &amp;&amp; elem != 'Annots' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Hid' &amp;&amp; elem != 'BoxColorInfo' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'TrimBox' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'ArtBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DPart' &amp;&amp; elem != 'PresSteps' &amp;&amp; elem != 'UserUnit' &amp;&amp; elem != 'Tabs' &amp;&amp; elem != 'VP' &amp;&amp; elem != 'Resources' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject" testNumber="22"/>
			<description>PageObject shall not contain entries Group, StructParents, TemplateInstantiated, Metadata, PZ, LastModified, BleedBox, SeparationInfo, ID, BoxColorInfo, AF, TrimBox, OutputIntents, PieceInfo, ArtBox, DPart, PresSteps, UserUnit, Tabs, VP in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Group' || elem == 'StructParents' || elem == 'TemplateInstantiated' || elem == 'Metadata' || elem == 'PZ' || elem == 'LastModified' || elem == 'BleedBox' || elem == 'SeparationInfo' || elem == 'ID' || elem == 'BoxColorInfo' || elem == 'AF' || elem == 'TrimBox' || elem == 'OutputIntents' || elem == 'PieceInfo' || elem == 'ArtBox' || elem == 'DPart' || elem == 'PresSteps' || elem == 'UserUnit' || elem == 'Tabs' || elem == 'VP').length == 0</test>
			<error>
				<message>PageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Group' || elem == 'StructParents' || elem == 'TemplateInstantiated' || elem == 'Metadata' || elem == 'PZ' || elem == 'LastModified' || elem == 'BleedBox' || elem == 'SeparationInfo' || elem == 'ID' || elem == 'BoxColorInfo' || elem == 'AF' || elem == 'TrimBox' || elem == 'OutputIntents' || elem == 'PieceInfo' || elem == 'ArtBox' || elem == 'DPart' || elem == 'PresSteps' || elem == 'UserUnit' || elem == 'Tabs' || elem == 'VP').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-AA" testNumber="8"/>
			<description>Entry AA in PageObject shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Annots" testNumber="8"/>
			<description>Entry Annots in PageObject shall have type Array</description>
			<test>containsAnnots == false || AnnotsHasTypeArray == true</test>
			<error>
				<message>Entry Annots in PageObject has type %1 instead of type Array</message>
				<arguments>
					<argument>AnnotsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-B" testNumber="8"/>
			<description>Entry B in PageObject shall have type Array</description>
			<test>containsB == false || BHasTypeArray == true</test>
			<error>
				<message>Entry B in PageObject has type %1 instead of type Array</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-B-Array" testNumber="9"/>
			<description>Entry B with type Array in PageObject shall satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</description>
			<test>BHasTypeArray != true || ((TypeNameValue != "Template") || containsB != true)</test>
			<error>
				<message>Entry B with type Array in PageObject does not satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Contents" testNumber="8"/>
			<description>Entry Contents in PageObject shall have one of types: Array, Stream</description>
			<test>containsContents == false || ContentsHasTypeArray == true || ContentsHasTypeStream == true</test>
			<error>
				<message>Entry Contents in PageObject has type %1 instead of one of types: Array, Stream</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Contents-Stream" testNumber="10"/>
			<description>Entry Contents with type Stream in PageObject shall be indirect</description>
			<test>ContentsHasTypeStream != true || isContentsIndirect == true</test>
			<error>
				<message>Entry Contents with type Stream in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageObject shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Dur" testNumber="8"/>
			<description>Entry Dur in PageObject shall have type Number</description>
			<test>containsDur == false || DurHasTypeNumber == true</test>
			<error>
				<message>Entry Dur in PageObject has type %1 instead of type Number</message>
				<arguments>
					<argument>DurType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Hid" testNumber="8"/>
			<description>Entry Hid in PageObject shall have type Boolean</description>
			<test>containsHid == false || HidHasTypeBoolean == true</test>
			<error>
				<message>Entry Hid in PageObject has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HidType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageObject shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-MediaBox" testNumber="7"/>
			<description>Entry MediaBox in PageObject is required</description>
			<test>containsMediaBox == true</test>
			<error>
				<message>Entry MediaBox in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in PageObject shall be one of objects PageTreeNode, PageTreeNodeRoot</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject is not one of objects PageTreeNode, PageTreeNodeRoot</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Parent" testNumber="8"/>
			<description>Entry Parent in PageObject shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Parent" testNumber="11"/>
			<description>Entry Parent in PageObject is required, when @Type != Template</description>
			<test>containsParent == true || (TypeNameValue == "Template")</test>
			<error>
				<message>Entry Parent in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in PageObject shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Parent-Dictionary" testNumber="9"/>
			<description>Entry Parent with type Dictionary in PageObject shall satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</description>
			<test>ParentHasTypeDictionary != true || ((TypeNameValue != "Template") || containsParent != true)</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject does not satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Resources" testNumber="8"/>
			<description>Entry Resources in PageObject shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Resources" testNumber="7"/>
			<description>Entry Resources in PageObject is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageObject shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageObject shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageObject does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Thumb" testNumber="8"/>
			<description>Entry Thumb in PageObject shall have type Stream</description>
			<test>containsThumb == false || ThumbHasTypeStream == true</test>
			<error>
				<message>Entry Thumb in PageObject has type %1 instead of type Stream</message>
				<arguments>
					<argument>ThumbType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Thumb-Stream" testNumber="10"/>
			<description>Entry Thumb with type Stream in PageObject shall be indirect</description>
			<test>ThumbHasTypeStream != true || isThumbIndirect == true</test>
			<error>
				<message>Entry Thumb with type Stream in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Trans" testNumber="8"/>
			<description>Entry Trans in PageObject shall have type Dictionary</description>
			<test>containsTrans == false || TransHasTypeDictionary == true</test>
			<error>
				<message>Entry Trans in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TransType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Type" testNumber="8"/>
			<description>Entry Type in PageObject shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageObject has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Type" testNumber="7"/>
			<description>Entry Type in PageObject is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_2" clause="PageObject-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageObject shall have one of values: Page, Template</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Page" || TypeNameValue == "Template"</test>
			<error>
				<message>Entry Type with type Name in PageObject has incorrect value %1 instead of Page, Template</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode" testNumber="1"/>
			<description>PageTreeNode shall not contain entries except CropBox, Type, Rotate, Parent, Count, Resources, Kids, MediaBox</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CropBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageTreeNode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CropBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Count" testNumber="8"/>
			<description>Entry Count in PageTreeNode shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in PageTreeNode has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Count" testNumber="7"/>
			<description>Entry Count in PageTreeNode is required</description>
			<test>containsCount == true</test>
			<error>
				<message>Entry Count in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in PageTreeNode shall satisfy possible value predicate: fn:Eval(@Count &gt; 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt; 0</test>
			<error>
				<message>Entry Count with type Integer in PageTreeNode does not satisfy possible value predicate: fn:Eval(@Count &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageTreeNode shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageTreeNode has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Kids" testNumber="8"/>
			<description>Entry Kids in PageTreeNode shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in PageTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Kids" testNumber="7"/>
			<description>Entry Kids in PageTreeNode is required</description>
			<test>containsKids == true</test>
			<error>
				<message>Entry Kids in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Kids-Array" testNumber="9"/>
			<description>Entry Kids with type Array in PageTreeNode shall satisfy special case: fn:Eval(fn:ArrayLength(Kids) &gt; 0)</description>
			<test>KidsHasTypeArray != true || (KidsArraySize &gt; 0)</test>
			<error>
				<message>Entry Kids with type Array in PageTreeNode does not satisfy special case: fn:Eval(fn:ArrayLength(Kids) &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageTreeNode shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageTreeNode has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in PageTreeNode shall be one of objects PageTreeNode, PageTreeNodeRoot</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in PageTreeNode is not one of objects PageTreeNode, PageTreeNodeRoot</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Parent" testNumber="8"/>
			<description>Entry Parent in PageTreeNode shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in PageTreeNode has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Parent" testNumber="7"/>
			<description>Entry Parent in PageTreeNode is required</description>
			<test>containsParent == true</test>
			<error>
				<message>Entry Parent in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in PageTreeNode shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in PageTreeNode is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Resources" testNumber="8"/>
			<description>Entry Resources in PageTreeNode shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageTreeNode has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageTreeNode shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageTreeNode has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageTreeNode shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageTreeNode does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Type" testNumber="8"/>
			<description>Entry Type in PageTreeNode shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageTreeNode has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Type" testNumber="7"/>
			<description>Entry Type in PageTreeNode is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_2" clause="PageTreeNode-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageTreeNode shall have value Pages</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pages"</test>
			<error>
				<message>Entry Type with type Name in PageTreeNode has incorrect value %1 instead of Pages</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot" testNumber="1"/>
			<description>PageTreeNodeRoot shall not contain entries except CropBox, Type, Rotate, Count, Resources, Kids, MediaBox</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CropBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageTreeNodeRoot contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CropBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Count" testNumber="8"/>
			<description>Entry Count in PageTreeNodeRoot shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in PageTreeNodeRoot has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Count" testNumber="7"/>
			<description>Entry Count in PageTreeNodeRoot is required</description>
			<test>containsCount == true</test>
			<error>
				<message>Entry Count in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in PageTreeNodeRoot shall satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Count with type Integer in PageTreeNodeRoot does not satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageTreeNodeRoot shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageTreeNodeRoot has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Kids" testNumber="8"/>
			<description>Entry Kids in PageTreeNodeRoot shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in PageTreeNodeRoot has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Kids" testNumber="7"/>
			<description>Entry Kids in PageTreeNodeRoot is required</description>
			<test>containsKids == true</test>
			<error>
				<message>Entry Kids in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageTreeNodeRoot shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageTreeNodeRoot has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Resources" testNumber="8"/>
			<description>Entry Resources in PageTreeNodeRoot shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageTreeNodeRoot has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageTreeNodeRoot shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageTreeNodeRoot has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageTreeNodeRoot shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageTreeNodeRoot does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Type" testNumber="8"/>
			<description>Entry Type in PageTreeNodeRoot shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageTreeNodeRoot has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Type" testNumber="7"/>
			<description>Entry Type in PageTreeNodeRoot is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_2" clause="PageTreeNodeRoot-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageTreeNodeRoot shall have value Pages</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pages"</test>
			<error>
				<message>Entry Type with type Name in PageTreeNodeRoot has incorrect value %1 instead of Pages</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace" testNumber="2"/>
			<description>PatternColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>PatternColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace-0" testNumber="8"/>
			<description>Entry 0 in PatternColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in PatternColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in PatternColorSpace shall have value Pattern</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Pattern"</test>
			<error>
				<message>Entry 0 with type Name in PatternColorSpace has incorrect value %1 instead of Pattern</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace-1-Array" testNumber="17"/>
			<description>Entry 1 with type Array in PatternColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace</description>
			<test>entry1HasTypeArray != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Array in PatternColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace-1" testNumber="8"/>
			<description>Entry 1 in PatternColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 1 || entry1HasTypeArray == true || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in PatternColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_2" clause="PatternColorSpace-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in PatternColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry1HasTypeName != true || entry1NameValue == "DeviceCMYK" || entry1NameValue == "DeviceRGB" || entry1NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 1 with type Name in PatternColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternMapEntry">
			<id specification="PDF_1_2" clause="PatternMapEntry" testNumber="8"/>
			<description>Entry in PatternMap shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in PatternMap has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternMapEntry">
			<id specification="PDF_1_2" clause="PatternMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in PatternMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in PatternMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1" testNumber="1"/>
			<description>PatternType1 shall not contain entries except PatternType, TilingType, F, YStep, DecodeParms, FDecodeParms, XUID, Type, Matrix, Filter, Length, BBox, PaintType, Resources, XStep, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'PatternType' &amp;&amp; elem != 'TilingType' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'YStep' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'PaintType' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'XStep' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PatternType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'PatternType' &amp;&amp; elem != 'TilingType' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'YStep' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'PaintType' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'XStep' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1" testNumber="22"/>
			<description>PatternType1 shall not contain entry DL in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL').length == 0</test>
			<error>
				<message>PatternType1 contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-BBox" testNumber="8"/>
			<description>Entry BBox in PatternType1 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in PatternType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-BBox" testNumber="7"/>
			<description>Entry BBox in PatternType1 is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in PatternType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in PatternType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in PatternType1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in PatternType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-F" testNumber="8"/>
			<description>Entry F in PatternType1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in PatternType1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in PatternType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in PatternType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in PatternType1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in PatternType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FFilter" testNumber="8"/>
			<description>Entry FFilter in PatternType1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in PatternType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in PatternType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in PatternType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Filter" testNumber="8"/>
			<description>Entry Filter in PatternType1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in PatternType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in PatternType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in PatternType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Length" testNumber="8"/>
			<description>Entry Length in PatternType1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Length" testNumber="7"/>
			<description>Entry Length in PatternType1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Matrix" testNumber="8"/>
			<description>Entry Matrix in PatternType1 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in PatternType1 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PaintType" testNumber="8"/>
			<description>Entry PaintType in PatternType1 shall have type Integer</description>
			<test>containsPaintType == false || PaintTypeHasTypeInteger == true</test>
			<error>
				<message>Entry PaintType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>PaintTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PaintType" testNumber="7"/>
			<description>Entry PaintType in PatternType1 is required</description>
			<test>containsPaintType == true</test>
			<error>
				<message>Entry PaintType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PaintType-Integer" testNumber="6"/>
			<description>Entry PaintType with type Integer in PatternType1 shall have one of values: 1, 2</description>
			<test>PaintTypeHasTypeInteger != true || PaintTypeIntegerValue == 1 || PaintTypeIntegerValue == 2</test>
			<error>
				<message>Entry PaintType with type Integer in PatternType1 has incorrect value %1 instead of 1, 2</message>
				<arguments>
					<argument>PaintTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PatternType" testNumber="8"/>
			<description>Entry PatternType in PatternType1 shall have type Integer</description>
			<test>containsPatternType == false || PatternTypeHasTypeInteger == true</test>
			<error>
				<message>Entry PatternType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>PatternTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PatternType" testNumber="7"/>
			<description>Entry PatternType in PatternType1 is required</description>
			<test>containsPatternType == true</test>
			<error>
				<message>Entry PatternType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-PatternType-Integer" testNumber="6"/>
			<description>Entry PatternType with type Integer in PatternType1 shall have value 1</description>
			<test>PatternTypeHasTypeInteger != true || PatternTypeIntegerValue == 1</test>
			<error>
				<message>Entry PatternType with type Integer in PatternType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>PatternTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Resources" testNumber="8"/>
			<description>Entry Resources in PatternType1 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PatternType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Resources" testNumber="7"/>
			<description>Entry Resources in PatternType1 is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-TilingType" testNumber="8"/>
			<description>Entry TilingType in PatternType1 shall have type Integer</description>
			<test>containsTilingType == false || TilingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry TilingType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>TilingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-TilingType" testNumber="7"/>
			<description>Entry TilingType in PatternType1 is required</description>
			<test>containsTilingType == true</test>
			<error>
				<message>Entry TilingType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-TilingType-Integer" testNumber="6"/>
			<description>Entry TilingType with type Integer in PatternType1 shall have one of values: 1, 2, 3</description>
			<test>TilingTypeHasTypeInteger != true || TilingTypeIntegerValue == 1 || TilingTypeIntegerValue == 2 || TilingTypeIntegerValue == 3</test>
			<error>
				<message>Entry TilingType with type Integer in PatternType1 has incorrect value %1 instead of 1, 2, 3</message>
				<arguments>
					<argument>TilingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Type" testNumber="8"/>
			<description>Entry Type in PatternType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PatternType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PatternType1 shall have value Pattern</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pattern"</test>
			<error>
				<message>Entry Type with type Name in PatternType1 has incorrect value %1 instead of Pattern</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-XStep" testNumber="8"/>
			<description>Entry XStep in PatternType1 shall have type Number</description>
			<test>containsXStep == false || XStepHasTypeNumber == true</test>
			<error>
				<message>Entry XStep in PatternType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>XStepType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-XStep" testNumber="7"/>
			<description>Entry XStep in PatternType1 is required</description>
			<test>containsXStep == true</test>
			<error>
				<message>Entry XStep in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-XUID" testNumber="8"/>
			<description>Entry XUID in PatternType1 shall have type Array</description>
			<test>containsXUID == false || XUIDHasTypeArray == true</test>
			<error>
				<message>Entry XUID in PatternType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>XUIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-YStep" testNumber="8"/>
			<description>Entry YStep in PatternType1 shall have type Number</description>
			<test>containsYStep == false || YStepHasTypeNumber == true</test>
			<error>
				<message>Entry YStep in PatternType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>YStepType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_2" clause="PatternType1-YStep" testNumber="7"/>
			<description>Entry YStep in PatternType1 is required</description>
			<test>containsYStep == true</test>
			<error>
				<message>Entry YStep in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource" testNumber="1"/>
			<description>Resource shall not contain entries except Pattern, ColorSpace, ProcSet, ExtGState, Properties, Font, XObject</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Pattern' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'ProcSet' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'ExtGState' &amp;&amp; elem != 'Properties' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'XObject' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Resource contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Pattern' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'ProcSet' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'ExtGState' &amp;&amp; elem != 'Properties' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'XObject' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource" testNumber="22"/>
			<description>Resource shall not contain entry Shading in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Shading').length == 0</test>
			<error>
				<message>Resource contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Shading').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in Resource shall have type Dictionary</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeDictionary == true</test>
			<error>
				<message>Entry ColorSpace in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-ExtGState" testNumber="8"/>
			<description>Entry ExtGState in Resource shall have type Dictionary</description>
			<test>containsExtGState == false || ExtGStateHasTypeDictionary == true</test>
			<error>
				<message>Entry ExtGState in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ExtGStateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-Font" testNumber="8"/>
			<description>Entry Font in Resource shall have type Dictionary</description>
			<test>containsFont == false || FontHasTypeDictionary == true</test>
			<error>
				<message>Entry Font in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-Pattern" testNumber="8"/>
			<description>Entry Pattern in Resource shall have type Dictionary</description>
			<test>containsPattern == false || PatternHasTypeDictionary == true</test>
			<error>
				<message>Entry Pattern in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PatternType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-ProcSet" testNumber="8"/>
			<description>Entry ProcSet in Resource shall have type Array</description>
			<test>containsProcSet == false || ProcSetHasTypeArray == true</test>
			<error>
				<message>Entry ProcSet in Resource has type %1 instead of type Array</message>
				<arguments>
					<argument>ProcSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-Properties" testNumber="8"/>
			<description>Entry Properties in Resource shall have type Dictionary</description>
			<test>containsProperties == false || entryPropertiesHasTypeDictionary == true</test>
			<error>
				<message>Entry Properties in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entryPropertiesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_2" clause="Resource-XObject" testNumber="8"/>
			<description>Entry XObject in Resource shall have type Dictionary</description>
			<test>containsXObject == false || XObjectHasTypeDictionary == true</test>
			<error>
				<message>Entry XObject in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>XObjectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace" testNumber="2"/>
			<description>SeparationColorSpace shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>SeparationColorSpace contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-0" testNumber="8"/>
			<description>Entry 0 in SeparationColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in SeparationColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in SeparationColorSpace shall have value Separation</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Separation"</test>
			<error>
				<message>Entry 0 with type Name in SeparationColorSpace has incorrect value %1 instead of Separation</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-1" testNumber="8"/>
			<description>Entry 1 in SeparationColorSpace shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in SeparationColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-2-Array" testNumber="17"/>
			<description>Entry 2 with type Array in SeparationColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace</description>
			<test>entry2HasTypeArray != true || entry2_size == 1</test>
			<error>
				<message>Entry 2 with type Array in SeparationColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-2" testNumber="8"/>
			<description>Entry 2 in SeparationColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 2 || entry2HasTypeArray == true || entry2HasTypeName == true</test>
			<error>
				<message>Entry 2 in SeparationColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-2-Name" testNumber="6"/>
			<description>Entry 2 with type Name in SeparationColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry2HasTypeName != true || entry2NameValue == "DeviceCMYK" || entry2NameValue == "DeviceRGB" || entry2NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 2 with type Name in SeparationColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry2NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-3" testNumber="8"/>
			<description>Entry 3 in SeparationColorSpace shall have type Stream</description>
			<test>size &lt;= 3 || entry3HasTypeStream == true</test>
			<error>
				<message>Entry 3 in SeparationColorSpace has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_2" clause="SeparationColorSpace-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in SeparationColorSpace shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in SeparationColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject" testNumber="1"/>
			<description>SoundObject shall not contain entries except B, C, E, F, DecodeParms, CO, CP, FDecodeParms, R, Type, Filter, Length, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SoundObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject" testNumber="22"/>
			<description>SoundObject shall not contain entry DL in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL').length == 0</test>
			<error>
				<message>SoundObject contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-B" testNumber="8"/>
			<description>Entry B in SoundObject shall have type Integer</description>
			<test>containsB == false || BHasTypeInteger == true</test>
			<error>
				<message>Entry B in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-B-Integer" testNumber="14"/>
			<description>Entry B with type Integer in SoundObject shall satisfy possible value predicate: fn:Eval(@B &gt; 0)</description>
			<test>BHasTypeInteger != true || BIntegerValue &gt; 0</test>
			<error>
				<message>Entry B with type Integer in SoundObject does not satisfy possible value predicate: fn:Eval(@B &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-C" testNumber="8"/>
			<description>Entry C in SoundObject shall have type Integer</description>
			<test>containsC == false || CHasTypeInteger == true</test>
			<error>
				<message>Entry C in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-C-Integer" testNumber="14"/>
			<description>Entry C with type Integer in SoundObject shall satisfy possible value predicate: fn:Eval(@C &gt; 0)</description>
			<test>CHasTypeInteger != true || CIntegerValue &gt; 0</test>
			<error>
				<message>Entry C with type Integer in SoundObject does not satisfy possible value predicate: fn:Eval(@C &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-CO" testNumber="8"/>
			<description>Entry CO in SoundObject shall have type Name</description>
			<test>containsCO == false || COHasTypeName == true</test>
			<error>
				<message>Entry CO in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>COType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-CP" testNumber="8"/>
			<description>Entry CP in SoundObject shall have one of types: Array, Dictionary, Stream</description>
			<test>containsCP == false || CPHasTypeArray == true || CPHasTypeDictionary == true || CPHasTypeStream == true</test>
			<error>
				<message>Entry CP in SoundObject has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>CPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-CP-Stream" testNumber="10"/>
			<description>Entry CP with type Stream in SoundObject shall be indirect</description>
			<test>CPHasTypeStream != true || isCPIndirect == true</test>
			<error>
				<message>Entry CP with type Stream in SoundObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in SoundObject shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in SoundObject is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in SoundObject shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in SoundObject has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-E" testNumber="8"/>
			<description>Entry E in SoundObject shall have type Name</description>
			<test>containsE == false || EHasTypeName == true</test>
			<error>
				<message>Entry E in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-E-Name" testNumber="6"/>
			<description>Entry E with type Name in SoundObject shall have one of values: Signed, Raw, muLaw, ALaw</description>
			<test>EHasTypeName != true || ENameValue == "Raw" || ENameValue == "Signed" || ENameValue == "muLaw" || ENameValue == "ALaw"</test>
			<error>
				<message>Entry E with type Name in SoundObject has incorrect value %1 instead of Signed, Raw, muLaw, ALaw</message>
				<arguments>
					<argument>ENameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-F" testNumber="8"/>
			<description>Entry F in SoundObject shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in SoundObject has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in SoundObject shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in SoundObject is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in SoundObject shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in SoundObject has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FFilter" testNumber="8"/>
			<description>Entry FFilter in SoundObject shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in SoundObject has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in SoundObject shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in SoundObject has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Filter" testNumber="8"/>
			<description>Entry Filter in SoundObject shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in SoundObject has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in SoundObject shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in SoundObject has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Length" testNumber="8"/>
			<description>Entry Length in SoundObject shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Length" testNumber="7"/>
			<description>Entry Length in SoundObject is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in SoundObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-R" testNumber="8"/>
			<description>Entry R in SoundObject shall have type Number</description>
			<test>containsR == false || RHasTypeNumber == true</test>
			<error>
				<message>Entry R in SoundObject has type %1 instead of type Number</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-R" testNumber="7"/>
			<description>Entry R in SoundObject is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in SoundObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-R-Number" testNumber="14"/>
			<description>Entry R with type Number in SoundObject shall satisfy possible value predicate: fn:Eval(@R &gt; 0)</description>
			<test>RHasTypeNumber != true || RNumberValue &gt; 0</test>
			<error>
				<message>Entry R with type Number in SoundObject does not satisfy possible value predicate: fn:Eval(@R &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Type" testNumber="8"/>
			<description>Entry Type in SoundObject shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_2" clause="SoundObject-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in SoundObject shall have value Sound</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Sound"</test>
			<error>
				<message>Entry Type with type Name in SoundObject has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in Stream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in Stream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in Stream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in Stream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-F" testNumber="8"/>
			<description>Entry F in Stream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Stream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in Stream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in Stream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in Stream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in Stream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FFilter" testNumber="8"/>
			<description>Entry FFilter in Stream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in Stream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in Stream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in Stream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-Filter" testNumber="8"/>
			<description>Entry Filter in Stream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in Stream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in Stream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in Stream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-Length" testNumber="8"/>
			<description>Entry Length in Stream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in Stream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_2" clause="Stream-Length" testNumber="7"/>
			<description>Entry Length in Stream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in Stream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_2" clause="StyleDict" testNumber="1"/>
			<description>StyleDict shall not contain entries except Panose</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Panose' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>StyleDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Panose' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_2" clause="StyleDict-Panose" testNumber="8"/>
			<description>Entry Panose in StyleDict shall have type StringByte</description>
			<test>containsPanose == false || PanoseHasTypeStringByte == true</test>
			<error>
				<message>Entry Panose in StyleDict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PanoseType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_2" clause="StyleDict-Panose-StringByte" testNumber="9"/>
			<description>Entry Panose with type StringByte in StyleDict shall satisfy special case: fn:Eval(fn:StringLength(Panose) == 12)</description>
			<test>PanoseHasTypeStringByte != true || (PanoseStringSize == 12)</test>
			<error>
				<message>Entry Panose with type StringByte in StyleDict does not satisfy special case: fn:Eval(fn:StringLength(Panose) == 12)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread" testNumber="1"/>
			<description>Thread shall not contain entries except Type, F, I</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'I' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Thread contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Type' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'I' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread" testNumber="22"/>
			<description>Thread shall not contain entry Metadata in PDF 1.2. This entry appears in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Metadata').length == 0</test>
			<error>
				<message>Thread contains entry %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Metadata').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-F" testNumber="8"/>
			<description>Entry F in Thread shall have type Dictionary</description>
			<test>containsF == false || FHasTypeDictionary == true</test>
			<error>
				<message>Entry F in Thread has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-F" testNumber="7"/>
			<description>Entry F in Thread is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in Thread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-F-Dictionary" testNumber="10"/>
			<description>Entry F with type Dictionary in Thread shall be indirect</description>
			<test>FHasTypeDictionary != true || isFIndirect == true</test>
			<error>
				<message>Entry F with type Dictionary in Thread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-I" testNumber="8"/>
			<description>Entry I in Thread shall have type Dictionary</description>
			<test>containsI == false || IHasTypeDictionary == true</test>
			<error>
				<message>Entry I in Thread has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-Type" testNumber="8"/>
			<description>Entry Type in Thread shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Thread has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_2" clause="Thread-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Thread shall have value Thread</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Thread"</test>
			<error>
				<message>Entry Type with type Name in Thread has incorrect value %1 instead of Thread</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail" testNumber="1"/>
			<description>Thumbnail shall not contain entries except ColorSpace, Decode, BitsPerComponent, Type, Height, Subtype, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Thumbnail contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail" testNumber="22"/>
			<description>Thumbnail shall not contain entries F, DL, DecodeParms, FDecodeParms, Filter, Length, FFilter in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').length == 0</test>
			<error>
				<message>Thumbnail contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'F' || elem == 'DL' || elem == 'DecodeParms' || elem == 'FDecodeParms' || elem == 'Filter' || elem == 'Length' || elem == 'FFilter').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in Thumbnail shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in Thumbnail is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in Thumbnail shall have one of values: 1, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in Thumbnail has incorrect value %1 instead of 1, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in Thumbnail shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in Thumbnail has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in Thumbnail is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in Thumbnail shall have one of values: DeviceGray, DeviceRGB</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in Thumbnail has incorrect value %1 instead of DeviceGray, DeviceRGB</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Decode" testNumber="8"/>
			<description>Entry Decode in Thumbnail shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in Thumbnail has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Height" testNumber="8"/>
			<description>Entry Height in Thumbnail shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Height" testNumber="7"/>
			<description>Entry Height in Thumbnail is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Subtype" testNumber="8"/>
			<description>Entry Subtype in Thumbnail shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in Thumbnail has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in Thumbnail shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in Thumbnail has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Type" testNumber="8"/>
			<description>Entry Type in Thumbnail shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Thumbnail has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Thumbnail shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in Thumbnail has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Width" testNumber="8"/>
			<description>Entry Width in Thumbnail shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_2" clause="Thumbnail-Width" testNumber="7"/>
			<description>Entry Width in Thumbnail is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_2" clause="TrailerIDArray" testNumber="2"/>
			<description>TrailerIDArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>TrailerIDArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_2" clause="TrailerIDArray-0" testNumber="8"/>
			<description>Entry 0 in TrailerIDArray shall have type StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in TrailerIDArray has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_2" clause="TrailerIDArray-0-StringByte" testNumber="16"/>
			<description>If entry 0 with type StringByte in TrailerIDArray satisfies condition fn:IsPresent(trailer::Encrypt), it shall be direct</description>
			<test>entry0HasTypeStringByte != true || (isentry0Indirect == false || (containstrailerEncrypt != true))</test>
			<error>
				<message>Entry 0 with type StringByte in TrailerIDArray is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_2" clause="TrailerIDArray-1" testNumber="8"/>
			<description>Entry 1 in TrailerIDArray shall have type StringByte</description>
			<test>size &lt;= 1 || entry1HasTypeStringByte == true</test>
			<error>
				<message>Entry 1 in TrailerIDArray has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_2" clause="TrailerIDArray-1-StringByte" testNumber="16"/>
			<description>If entry 1 with type StringByte in TrailerIDArray satisfies condition fn:IsPresent(trailer::Encrypt), it shall be direct</description>
			<test>entry1HasTypeStringByte != true || (isentry1Indirect == false || (containstrailerEncrypt != true))</test>
			<error>
				<message>Entry 1 with type StringByte in TrailerIDArray is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition" testNumber="1"/>
			<description>Transition shall not contain entries except Type, S, D, Di, Dm, M</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'SS' &amp;&amp; elem != 'B' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Di' &amp;&amp; elem != 'Dm' &amp;&amp; elem != 'M' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Transition contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'SS' &amp;&amp; elem != 'B' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'S' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Di' &amp;&amp; elem != 'Dm' &amp;&amp; elem != 'M' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition" testNumber="22"/>
			<description>Transition shall not contain entries SS, B in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'SS' || elem == 'B').length == 0</test>
			<error>
				<message>Transition contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'SS' || elem == 'B').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-D" testNumber="8"/>
			<description>Entry D in Transition shall have type Number</description>
			<test>containsD == false || DHasTypeNumber == true</test>
			<error>
				<message>Entry D in Transition has type %1 instead of type Number</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-D-Number" testNumber="14"/>
			<description>Entry D with type Number in Transition shall satisfy possible value predicate: fn:Eval(@D &gt;= 0)</description>
			<test>DHasTypeNumber != true || DNumberValue &gt;= 0</test>
			<error>
				<message>Entry D with type Number in Transition does not satisfy possible value predicate: fn:Eval(@D &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di" testNumber="8"/>
			<description>Entry Di in Transition shall have one of types: Integer, Name</description>
			<test>containsDi == false || DiHasTypeInteger == true || DiHasTypeName == true</test>
			<error>
				<message>Entry Di in Transition has type %1 instead of one of types: Integer, Name</message>
				<arguments>
					<argument>DiType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Integer-90" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 90, only if this object satisfies condition (@S == Wipe)</description>
			<test>(SNameValue == "Wipe") || DiIntegerValue != 90</test>
			<error>
				<message>Entry Di in Transition has value 90, but not satisfy condition (@S == Wipe)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Integer-180" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 180, only if this object satisfies condition (@S == Wipe)</description>
			<test>(SNameValue == "Wipe") || DiIntegerValue != 180</test>
			<error>
				<message>Entry Di in Transition has value 180, but not satisfy condition (@S == Wipe)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Integer-315" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 315, only if this object satisfies condition (@S == Glitter)</description>
			<test>(SNameValue == "Glitter") || DiIntegerValue != 315</test>
			<error>
				<message>Entry Di in Transition has value 315, but not satisfy condition (@S == Glitter)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Integer" testNumber="6"/>
			<description>Entry Di with type Integer in Transition shall have one of values: 0, 90, 315, 180, 270</description>
			<test>DiHasTypeInteger != true || DiIntegerValue == 0 || DiIntegerValue == 90 || DiIntegerValue == 180 || DiIntegerValue == 270 || DiIntegerValue == 315</test>
			<error>
				<message>Entry Di with type Integer in Transition has incorrect value %1 instead of 0, 90, 315, 180, 270</message>
				<arguments>
					<argument>DiIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Name" testNumber="6"/>
			<description>Entry Di with type Name in Transition shall have value None</description>
			<test>DiHasTypeName != true || DiNameValue == "None"</test>
			<error>
				<message>Entry Di with type Name in Transition has incorrect value %1 instead of None</message>
				<arguments>
					<argument>DiNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Di-Name" testNumber="9"/>
			<description>Entry Di with type Name in Transition shall satisfy special case: fn:Eval(((@Di == None) &amp;&amp; (@S == Fly)))</description>
			<test>DiHasTypeName != true || ((DiNameValue == "None") &amp;&amp; (SNameValue == "Fly"))</test>
			<error>
				<message>Entry Di with type Name in Transition does not satisfy special case: fn:Eval(((@Di == None) &amp;&amp; (@S == Fly)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Dm" testNumber="8"/>
			<description>Entry Dm in Transition shall have type Name</description>
			<test>containsDm == false || DmHasTypeName == true</test>
			<error>
				<message>Entry Dm in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>DmType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Dm-Name" testNumber="6"/>
			<description>Entry Dm with type Name in Transition shall have one of values: V, H</description>
			<test>DmHasTypeName != true || DmNameValue == "H" || DmNameValue == "V"</test>
			<error>
				<message>Entry Dm with type Name in Transition has incorrect value %1 instead of V, H</message>
				<arguments>
					<argument>DmNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-M" testNumber="8"/>
			<description>Entry M in Transition shall have type Name</description>
			<test>containsM == false || MHasTypeName == true</test>
			<error>
				<message>Entry M in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-M-Name" testNumber="6"/>
			<description>Entry M with type Name in Transition shall have one of values: I, O</description>
			<test>MHasTypeName != true || MNameValue == "I" || MNameValue == "O"</test>
			<error>
				<message>Entry M with type Name in Transition has incorrect value %1 instead of I, O</message>
				<arguments>
					<argument>MNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-S" testNumber="8"/>
			<description>Entry S in Transition shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-S-Name" testNumber="6"/>
			<description>Entry S with type Name in Transition shall have one of values: Uncover, Glitter, R, Fly, Cover, Dissolve, Box, Split, Push, Blinds, Fade, Wipe</description>
			<test>SHasTypeName != true || SNameValue == "Split" || SNameValue == "Blinds" || SNameValue == "Box" || SNameValue == "Wipe" || SNameValue == "Dissolve" || SNameValue == "Glitter" || SNameValue == "R" || SNameValue == "Fly" || SNameValue == "Push" || SNameValue == "Cover" || SNameValue == "Uncover" || SNameValue == "Fade"</test>
			<error>
				<message>Entry S with type Name in Transition has incorrect value %1 instead of Uncover, Glitter, R, Fly, Cover, Dissolve, Box, Split, Push, Blinds, Fade, Wipe</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Type" testNumber="8"/>
			<description>Entry Type in Transition shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_2" clause="Transition-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Transition shall have value Trans</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Trans"</test>
			<error>
				<message>Entry Type with type Name in Transition has incorrect value %1 instead of Trans</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURI">
			<id specification="PDF_1_2" clause="URI" testNumber="1"/>
			<description>URI shall not contain entries except Base</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Base' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>URI contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Base' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURI">
			<id specification="PDF_1_2" clause="URI-Base" testNumber="8"/>
			<description>Entry Base in URI shall have type StringAscii</description>
			<test>containsBase == false || BaseHasTypeStringAscii == true</test>
			<error>
				<message>Entry Base in URI has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>BaseType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences" testNumber="1"/>
			<description>ViewerPreferences shall not contain entries except NonFullScreenPageMode, CenterWindow, HideMenubar, FitWindow, HideWindowUI, HideToolbar</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'NonFullScreenPageMode' &amp;&amp; elem != 'DisplayDocTitle' &amp;&amp; elem != 'ViewArea' &amp;&amp; elem != 'ViewClip' &amp;&amp; elem != 'Direction' &amp;&amp; elem != 'Duplex' &amp;&amp; elem != 'CenterWindow' &amp;&amp; elem != 'HideMenubar' &amp;&amp; elem != 'PrintClip' &amp;&amp; elem != 'PrintPageRange' &amp;&amp; elem != 'PrintScaling' &amp;&amp; elem != 'FitWindow' &amp;&amp; elem != 'HideWindowUI' &amp;&amp; elem != 'Enforce' &amp;&amp; elem != 'NumCopies' &amp;&amp; elem != 'PrintArea' &amp;&amp; elem != 'PickTrayByPDFSize' &amp;&amp; elem != 'HideToolbar' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ViewerPreferences contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'NonFullScreenPageMode' &amp;&amp; elem != 'DisplayDocTitle' &amp;&amp; elem != 'ViewArea' &amp;&amp; elem != 'ViewClip' &amp;&amp; elem != 'Direction' &amp;&amp; elem != 'Duplex' &amp;&amp; elem != 'CenterWindow' &amp;&amp; elem != 'HideMenubar' &amp;&amp; elem != 'PrintClip' &amp;&amp; elem != 'PrintPageRange' &amp;&amp; elem != 'PrintScaling' &amp;&amp; elem != 'FitWindow' &amp;&amp; elem != 'HideWindowUI' &amp;&amp; elem != 'Enforce' &amp;&amp; elem != 'NumCopies' &amp;&amp; elem != 'PrintArea' &amp;&amp; elem != 'PickTrayByPDFSize' &amp;&amp; elem != 'HideToolbar' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences" testNumber="22"/>
			<description>ViewerPreferences shall not contain entries DisplayDocTitle, ViewArea, ViewClip, Direction, Duplex, PrintClip, PrintPageRange, PrintScaling, Enforce, NumCopies, PrintArea, PickTrayByPDFSize in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DisplayDocTitle' || elem == 'ViewArea' || elem == 'ViewClip' || elem == 'Direction' || elem == 'Duplex' || elem == 'PrintClip' || elem == 'PrintPageRange' || elem == 'PrintScaling' || elem == 'Enforce' || elem == 'NumCopies' || elem == 'PrintArea' || elem == 'PickTrayByPDFSize').length == 0</test>
			<error>
				<message>ViewerPreferences contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DisplayDocTitle' || elem == 'ViewArea' || elem == 'ViewClip' || elem == 'Direction' || elem == 'Duplex' || elem == 'PrintClip' || elem == 'PrintPageRange' || elem == 'PrintScaling' || elem == 'Enforce' || elem == 'NumCopies' || elem == 'PrintArea' || elem == 'PickTrayByPDFSize').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-CenterWindow" testNumber="8"/>
			<description>Entry CenterWindow in ViewerPreferences shall have type Boolean</description>
			<test>containsCenterWindow == false || CenterWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry CenterWindow in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>CenterWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-FitWindow" testNumber="8"/>
			<description>Entry FitWindow in ViewerPreferences shall have type Boolean</description>
			<test>containsFitWindow == false || FitWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry FitWindow in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>FitWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-HideMenubar" testNumber="8"/>
			<description>Entry HideMenubar in ViewerPreferences shall have type Boolean</description>
			<test>containsHideMenubar == false || HideMenubarHasTypeBoolean == true</test>
			<error>
				<message>Entry HideMenubar in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideMenubarType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-HideToolbar" testNumber="8"/>
			<description>Entry HideToolbar in ViewerPreferences shall have type Boolean</description>
			<test>containsHideToolbar == false || HideToolbarHasTypeBoolean == true</test>
			<error>
				<message>Entry HideToolbar in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideToolbarType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-HideWindowUI" testNumber="8"/>
			<description>Entry HideWindowUI in ViewerPreferences shall have type Boolean</description>
			<test>containsHideWindowUI == false || HideWindowUIHasTypeBoolean == true</test>
			<error>
				<message>Entry HideWindowUI in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideWindowUIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-NonFullScreenPageMode" testNumber="8"/>
			<description>Entry NonFullScreenPageMode in ViewerPreferences shall have type Name</description>
			<test>containsNonFullScreenPageMode == false || NonFullScreenPageModeHasTypeName == true</test>
			<error>
				<message>Entry NonFullScreenPageMode in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>NonFullScreenPageModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_2" clause="ViewerPreferences-NonFullScreenPageMode-Name" testNumber="6"/>
			<description>Entry NonFullScreenPageMode with type Name in ViewerPreferences shall have one of values: UseOutlines, UseThumbs, UseOC, UseNone</description>
			<test>NonFullScreenPageModeHasTypeName != true || NonFullScreenPageModeNameValue == "UseNone" || NonFullScreenPageModeNameValue == "UseOutlines" || NonFullScreenPageModeNameValue == "UseThumbs" || NonFullScreenPageModeNameValue == "UseOC"</test>
			<error>
				<message>Entry NonFullScreenPageMode with type Name in ViewerPreferences has incorrect value %1 instead of UseOutlines, UseThumbs, UseOC, UseNone</message>
				<arguments>
					<argument>NonFullScreenPageModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray" testNumber="2"/>
			<description>WhitepointArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>WhitepointArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-0" testNumber="8"/>
			<description>Entry 0 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in WhitepointArray shall satisfy possible value predicate: fn:Eval(@0 &gt; 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt; 0</test>
			<error>
				<message>Entry 0 with type Number in WhitepointArray does not satisfy possible value predicate: fn:Eval(@0 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-1" testNumber="8"/>
			<description>Entry 1 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-1-Number" testNumber="6"/>
			<description>Entry 1 with type Number in WhitepointArray shall have value 1</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue == 1</test>
			<error>
				<message>Entry 1 with type Number in WhitepointArray has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>entry1NumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-2" testNumber="8"/>
			<description>Entry 2 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_2" clause="WhitepointArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in WhitepointArray shall satisfy possible value predicate: fn:Eval(@2 &gt; 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt; 0</test>
			<error>
				<message>Entry 2 with type Number in WhitepointArray does not satisfy possible value predicate: fn:Eval(@2 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS" testNumber="1"/>
			<description>XObjectFormPS shall not contain entries except FDecodeParms, Type, Filter, Length, F, DecodeParms, Level1, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormPS contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormPS shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormPS is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormPS shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPS has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-F" testNumber="8"/>
			<description>Entry F in XObjectFormPS shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormPS has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormPS shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormPS is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormPS shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPS has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormPS shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormPS has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormPS shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormPS has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormPS shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormPS has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormPS shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormPS has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormPS shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormPS has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormPS is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormPS is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Level1" testNumber="8"/>
			<description>Entry Level1 in XObjectFormPS shall have type Stream</description>
			<test>containsLevel1 == false || Level1HasTypeStream == true</test>
			<error>
				<message>Entry Level1 in XObjectFormPS has type %1 instead of type Stream</message>
				<arguments>
					<argument>Level1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Level1-Stream" testNumber="10"/>
			<description>Entry Level1 with type Stream in XObjectFormPS shall be indirect</description>
			<test>Level1HasTypeStream != true || isLevel1Indirect == true</test>
			<error>
				<message>Entry Level1 with type Stream in XObjectFormPS is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormPS shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPS has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormPS is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPS is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormPS shall have value PS</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "PS"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormPS has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormPS shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormPS has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_2" clause="XObjectFormPS-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormPS shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormPS has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough" testNumber="1"/>
			<description>XObjectFormPSpassthrough shall not contain entries except PS, F, FormType, Subtype2, DecodeParms, FDecodeParms, Type, Matrix, Filter, Length, BBox, Level1, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'PS' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Subtype2' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormPSpassthrough contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'PS' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Subtype2' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormPSpassthrough shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormPSpassthrough has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormPSpassthrough is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormPSpassthrough shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormPSpassthrough is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormPSpassthrough shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-F" testNumber="8"/>
			<description>Entry F in XObjectFormPSpassthrough shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormPSpassthrough has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormPSpassthrough shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormPSpassthrough is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormPSpassthrough shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormPSpassthrough shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormPSpassthrough shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormPSpassthrough shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormPSpassthrough shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormPSpassthrough shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormPSpassthrough has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FormType" testNumber="7"/>
			<description>Entry FormType in XObjectFormPSpassthrough is required</description>
			<test>containsFormType == true</test>
			<error>
				<message>Entry FormType in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormPSpassthrough shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormPSpassthrough has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormPSpassthrough shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormPSpassthrough has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormPSpassthrough is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Level1" testNumber="8"/>
			<description>Entry Level1 in XObjectFormPSpassthrough shall have type Stream</description>
			<test>containsLevel1 == false || Level1HasTypeStream == true</test>
			<error>
				<message>Entry Level1 in XObjectFormPSpassthrough has type %1 instead of type Stream</message>
				<arguments>
					<argument>Level1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Level1-Stream" testNumber="10"/>
			<description>Entry Level1 with type Stream in XObjectFormPSpassthrough shall be indirect</description>
			<test>Level1HasTypeStream != true || isLevel1Indirect == true</test>
			<error>
				<message>Entry Level1 with type Stream in XObjectFormPSpassthrough is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormPSpassthrough shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormPSpassthrough has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Matrix" testNumber="7"/>
			<description>Entry Matrix in XObjectFormPSpassthrough is required</description>
			<test>containsMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-PS" testNumber="8"/>
			<description>Entry PS in XObjectFormPSpassthrough shall have type Stream</description>
			<test>containsPS == false || PSHasTypeStream == true</test>
			<error>
				<message>Entry PS in XObjectFormPSpassthrough has type %1 instead of type Stream</message>
				<arguments>
					<argument>PSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-PS" testNumber="7"/>
			<description>Entry PS in XObjectFormPSpassthrough is required</description>
			<test>containsPS == true</test>
			<error>
				<message>Entry PS in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-PS-Stream" testNumber="10"/>
			<description>Entry PS with type Stream in XObjectFormPSpassthrough shall be indirect</description>
			<test>PSHasTypeStream != true || isPSIndirect == true</test>
			<error>
				<message>Entry PS with type Stream in XObjectFormPSpassthrough is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormPSpassthrough is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormPSpassthrough shall have value PS</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "PS"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype2" testNumber="8"/>
			<description>Entry Subtype2 in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsSubtype2 == false || Subtype2HasTypeName == true</test>
			<error>
				<message>Entry Subtype2 in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>Subtype2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype2" testNumber="7"/>
			<description>Entry Subtype2 in XObjectFormPSpassthrough is required</description>
			<test>containsSubtype2 == true</test>
			<error>
				<message>Entry Subtype2 in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Subtype2-Name" testNumber="6"/>
			<description>Entry Subtype2 with type Name in XObjectFormPSpassthrough shall have value PS</description>
			<test>Subtype2HasTypeName != true || Subtype2NameValue == "PS"</test>
			<error>
				<message>Entry Subtype2 with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>Subtype2NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_2" clause="XObjectFormPSpassthrough-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormPSpassthrough shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1" testNumber="1"/>
			<description>XObjectFormType1 shall not contain entries except F, OPI, Name, FDecodeParms, Matrix, FormType, DecodeParms, XUID, Type, Filter, Length, BBox, Resources, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1" testNumber="22"/>
			<description>XObjectFormType1 shall not contain entries GTS_Encapsulated, Group, StructParents, DL, Metadata, LastModified, OC, StructParent, GTS_XID, Measure, GTS_Scope, AF, PtData, PieceInfo, Ref, GTS_Env in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'GTS_Encapsulated' || elem == 'Group' || elem == 'StructParents' || elem == 'DL' || elem == 'Metadata' || elem == 'LastModified' || elem == 'OC' || elem == 'StructParent' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'GTS_Scope' || elem == 'AF' || elem == 'PtData' || elem == 'PieceInfo' || elem == 'Ref' || elem == 'GTS_Env').length == 0</test>
			<error>
				<message>XObjectFormType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'GTS_Encapsulated' || elem == 'Group' || elem == 'StructParents' || elem == 'DL' || elem == 'Metadata' || elem == 'LastModified' || elem == 'OC' || elem == 'StructParent' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'GTS_Scope' || elem == 'AF' || elem == 'PtData' || elem == 'PieceInfo' || elem == 'Ref' || elem == 'GTS_Env').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormType1 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormType1 is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormType1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-F" testNumber="8"/>
			<description>Entry F in XObjectFormType1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormType1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormType1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormType1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormType1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormType1 shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FormType" testNumber="7"/>
			<description>Entry FormType in XObjectFormType1 is required</description>
			<test>containsFormType == true</test>
			<error>
				<message>Entry FormType in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormType1 shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormType1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormType1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormType1 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormType1 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Matrix" testNumber="7"/>
			<description>Entry Matrix in XObjectFormType1 is required</description>
			<test>containsMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Name" testNumber="8"/>
			<description>Entry Name in XObjectFormType1 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Name" testNumber="7"/>
			<description>Entry Name in XObjectFormType1 is required</description>
			<test>containsName == true</test>
			<error>
				<message>Entry Name in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectFormType1 shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectFormType1 is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectFormType1 shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Resources" testNumber="8"/>
			<description>Entry Resources in XObjectFormType1 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Resources" testNumber="7"/>
			<description>Entry Resources in XObjectFormType1 is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormType1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormType1 shall have value Form</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Form"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormType1 has incorrect value %1 instead of Form</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormType1 shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormType1 has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_2" clause="XObjectFormType1-XUID" testNumber="8"/>
			<description>Entry XUID in XObjectFormType1 shall have type Array</description>
			<test>containsXUID == false || XUIDHasTypeArray == true</test>
			<error>
				<message>Entry XUID in XObjectFormType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>XUIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage" testNumber="1"/>
			<description>XObjectImage shall not contain entries except ColorSpace, F, Decode, OPI, BitsPerComponent, Name, FDecodeParms, ImageMask, Height, Width, DecodeParms, Intent, Type, Interpolate, Filter, Length, Subtype, FFilter</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Mask' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectImage contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'F' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Mask' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'FFilter' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage" testNumber="22"/>
			<description>XObjectImage shall not contain entries GTS_Encapsulated, DL, Metadata, OC, StructParent, GTS_XID, Measure, ID, SMaskInData, GTS_Scope, AF, Mask, PtData, SMask, GTS_Env, Alternates in PDF 1.2. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'GTS_Encapsulated' || elem == 'DL' || elem == 'Metadata' || elem == 'OC' || elem == 'StructParent' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'ID' || elem == 'SMaskInData' || elem == 'GTS_Scope' || elem == 'AF' || elem == 'Mask' || elem == 'PtData' || elem == 'SMask' || elem == 'GTS_Env' || elem == 'Alternates').length == 0</test>
			<error>
				<message>XObjectImage contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'GTS_Encapsulated' || elem == 'DL' || elem == 'Metadata' || elem == 'OC' || elem == 'StructParent' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'ID' || elem == 'SMaskInData' || elem == 'GTS_Scope' || elem == 'AF' || elem == 'Mask' || elem == 'PtData' || elem == 'SMask' || elem == 'GTS_Env' || elem == 'Alternates').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in XObjectImage shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-BitsPerComponent" testNumber="11"/>
			<description>Entry BitsPerComponent in XObjectImage is required, when fn:Not(fn:Contains(@Filter, JPXDecode) || (@ImageMask == true))</description>
			<test>containsBitsPerComponent == true || (((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JPXDecode").length &gt; 0) || (ImageMaskBooleanValue == true)) != true) == false</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-BitsPerComponent-Integer-1" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImage shall have Integer value 1, if this object satisfies condition (@Filter == CCITTFaxDecode) || (@Filter == JBIG2Decode) || (@ImageMask == true)</description>
			<test>((FilterNameValue != "CCITTFaxDecode") &amp;&amp; (FilterNameValue != "JBIG2Decode") &amp;&amp; (ImageMaskBooleanValue != true)) || BitsPerComponentIntegerValue == 1</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage does not have value 1</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-BitsPerComponent-Integer-8" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImage shall have Integer value 8, if this object satisfies condition (@Filter == RunLengthDecode) || (@Filter == DCTDecode)</description>
			<test>((FilterNameValue != "RunLengthDecode") &amp;&amp; (FilterNameValue != "DCTDecode")) || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage does not have value 8</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in XObjectImage shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in XObjectImage has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in XObjectImage shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace, PatternColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in XObjectImage is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, IndexedColorSpace, SeparationColorSpace, PatternColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in XObjectImage shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace" testNumber="11"/>
			<description>Entry ColorSpace in XObjectImage is required, when fn:Not(fn:Contains(@Filter, JPXDecode) || (@ImageMask == true))</description>
			<test>containsColorSpace == true || (((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JPXDecode").length &gt; 0) || (ImageMaskBooleanValue == true)) != true) == false</test>
			<error>
				<message>Entry ColorSpace in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace-Array" testNumber="9"/>
			<description>Entry ColorSpace with type Array in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>ColorSpaceHasTypeArray != true || ((ImageMaskBooleanValue != true) || containsColorSpace != true)</test>
			<error>
				<message>Entry ColorSpace with type Array in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in XObjectImage shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in XObjectImage has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ColorSpace-Name" testNumber="9"/>
			<description>Entry ColorSpace with type Name in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>ColorSpaceHasTypeName != true || ((ImageMaskBooleanValue != true) || containsColorSpace != true)</test>
			<error>
				<message>Entry ColorSpace with type Name in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Decode" testNumber="8"/>
			<description>Entry Decode in XObjectImage shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in XObjectImage has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectImage shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectImage is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectImage shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectImage has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-F" testNumber="8"/>
			<description>Entry F in XObjectImage shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectImage has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectImage shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectImage is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectImage shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectImage has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectImage shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectImage shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectImage has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectImage shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectImage shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectImage has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Height" testNumber="8"/>
			<description>Entry Height in XObjectImage shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Height" testNumber="7"/>
			<description>Entry Height in XObjectImage is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ImageMask" testNumber="8"/>
			<description>Entry ImageMask in XObjectImage shall have type Boolean</description>
			<test>containsImageMask == false || ImageMaskHasTypeBoolean == true</test>
			<error>
				<message>Entry ImageMask in XObjectImage has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ImageMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-ImageMask-Boolean" testNumber="9"/>
			<description>Entry ImageMask with type Boolean in XObjectImage shall satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1) &amp;&amp; fn:Not(fn:IsPresent(ColorSpace))) || (@ImageMask == false))</description>
			<test>ImageMaskHasTypeBoolean != true || (((ImageMaskBooleanValue == true) &amp;&amp; (BitsPerComponentHasTypeInteger == false || (BitsPerComponentIntegerValue == 1)) &amp;&amp; (containsColorSpace != true)) || (ImageMaskBooleanValue == false))</test>
			<error>
				<message>Entry ImageMask with type Boolean in XObjectImage does not satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1) &amp;&amp; fn:Not(fn:IsPresent(ColorSpace))) || (@ImageMask == false))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Intent" testNumber="8"/>
			<description>Entry Intent in XObjectImage shall have type Name</description>
			<test>containsIntent == false || IntentHasTypeName == true</test>
			<error>
				<message>Entry Intent in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>IntentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Interpolate" testNumber="8"/>
			<description>Entry Interpolate in XObjectImage shall have type Boolean</description>
			<test>containsInterpolate == false || InterpolateHasTypeBoolean == true</test>
			<error>
				<message>Entry Interpolate in XObjectImage has type %1 instead of type Boolean</message>
				<arguments>
					<argument>InterpolateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Length" testNumber="8"/>
			<description>Entry Length in XObjectImage shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Length" testNumber="7"/>
			<description>Entry Length in XObjectImage is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Name" testNumber="8"/>
			<description>Entry Name in XObjectImage shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectImage shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectImage is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectImage shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectImage has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectImage shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectImage is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectImage shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectImage has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Type" testNumber="8"/>
			<description>Entry Type in XObjectImage shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectImage shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectImage has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Width" testNumber="8"/>
			<description>Entry Width in XObjectImage shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_2" clause="XObjectImage-Width" testNumber="7"/>
			<description>Entry Width in XObjectImage is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_2" clause="XObjectMapEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in XObjectMap shall be one of objects XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in XObjectMap is not one of objects XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_2" clause="XObjectMapEntry" testNumber="8"/>
			<description>Entry in XObjectMap shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in XObjectMap has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_2" clause="XObjectMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in XObjectMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in XObjectMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalArrayEntry">
			<id specification="PDF_1_2" clause="_UniversalArrayEntry" testNumber="8"/>
			<description>Entry in _UniversalArray shall have one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</description>
			<test>HasTypeArray == true || HasTypeBoolean == true || HasTypeDictionary == true || HasTypeName == true || HasTypeNull == true || HasTypeNumber == true || HasTypeStream == true || HasTypeString == true</test>
			<error>
				<message>Entry %keyName% in _UniversalArray has type %1 instead of one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalArrayEntry">
			<id specification="PDF_1_2" clause="_UniversalArrayEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in _UniversalArray shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in _UniversalArray is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalDictionaryEntry">
			<id specification="PDF_1_2" clause="_UniversalDictionaryEntry" testNumber="8"/>
			<description>Entry in _UniversalDictionary shall have one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</description>
			<test>HasTypeArray == true || HasTypeBoolean == true || HasTypeDictionary == true || HasTypeName == true || HasTypeNull == true || HasTypeNumber == true || HasTypeStream == true || HasTypeString == true</test>
			<error>
				<message>Entry %keyName% in _UniversalDictionary has type %1 instead of one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalDictionaryEntry">
			<id specification="PDF_1_2" clause="_UniversalDictionaryEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in _UniversalDictionary shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in _UniversalDictionary is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
	</rules>
	<variables/>
</profile>
