<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<profile xmlns="http://www.verapdf.org/ValidationProfile" flavour="ARLINGTON1_4">
	<details creator="veraPDF Consortium" created="2022-05-23T21:45:28.872+03:00">
		<name>Arlington PDF 1.4 profile</name>
		<description>Rules against PDF 1.4 Specification</description>
	</details>
	<hash></hash>
	<rules>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST" testNumber="1"/>
			<description>AAPL_ST shall not contain entries except Color, ColorSpace, Offset, Radius, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Color' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Offset' &amp;&amp; elem != 'Radius' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AAPL_ST contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Color' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Offset' &amp;&amp; elem != 'Radius' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Color" testNumber="8"/>
			<description>Entry Color in AAPL_ST shall have type Array</description>
			<test>containsColor == false || ColorHasTypeArray == true</test>
			<error>
				<message>Entry Color in AAPL_ST has type %1 instead of type Array</message>
				<arguments>
					<argument>ColorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Color" testNumber="23"/>
			<description>Entry Color in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsColor == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Color in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in AAPL_ST shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in AAPL_ST is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in AAPL_ST shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in AAPL_ST has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-ColorSpace" testNumber="23"/>
			<description>Entry ColorSpace in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsColorSpace == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry ColorSpace in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in AAPL_ST shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in AAPL_ST has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Offset" testNumber="8"/>
			<description>Entry Offset in AAPL_ST shall have type Array</description>
			<test>containsOffset == false || OffsetHasTypeArray == true</test>
			<error>
				<message>Entry Offset in AAPL_ST has type %1 instead of type Array</message>
				<arguments>
					<argument>OffsetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Offset" testNumber="23"/>
			<description>Entry Offset in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsOffset == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Offset in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Radius" testNumber="8"/>
			<description>Entry Radius in AAPL_ST shall have type Number</description>
			<test>containsRadius == false || RadiusHasTypeNumber == true</test>
			<error>
				<message>Entry Radius in AAPL_ST has type %1 instead of type Number</message>
				<arguments>
					<argument>RadiusType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Radius" testNumber="23"/>
			<description>Entry Radius in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsRadius == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Radius in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Radius-Number" testNumber="9"/>
			<description>Entry Radius with type Number in AAPL_ST shall satisfy special case: fn:Eval(@Radius &gt; 0)</description>
			<test>RadiusHasTypeNumber != true || (RadiusNumberValue &gt; 0)</test>
			<error>
				<message>Entry Radius with type Number in AAPL_ST does not satisfy special case: fn:Eval(@Radius &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Subtype" testNumber="8"/>
			<description>Entry Subtype in AAPL_ST shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AAPL_ST has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Subtype" testNumber="23"/>
			<description>Entry Subtype in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsSubtype == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Subtype in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AAPL_ST shall have value Shadow</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Shadow"</test>
			<error>
				<message>Entry Subtype with type Name in AAPL_ST has incorrect value %1 instead of Shadow</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Type" testNumber="8"/>
			<description>Entry Type in AAPL_ST shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AAPL_ST has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Type" testNumber="23"/>
			<description>Entry Type in AAPL_ST can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsType == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry Type in AAPL_ST is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAAPL_ST">
			<id specification="PDF_1_4" clause="AAPL_ST-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AAPL_ST shall have value Style</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Style"</test>
			<error>
				<message>Entry Type with type Name in AAPL_ST has incorrect value %1 instead of Style</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript" testNumber="1"/>
			<description>ActionECMAScript shall not contain entries except JS, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'JS' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionECMAScript contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'JS' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-JS" testNumber="8"/>
			<description>Entry JS in ActionECMAScript shall have one of types: Stream, StringText</description>
			<test>containsJS == false || JSHasTypeStream == true || JSHasTypeStringText == true</test>
			<error>
				<message>Entry JS in ActionECMAScript has type %1 instead of one of types: Stream, StringText</message>
				<arguments>
					<argument>JSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-JS" testNumber="7"/>
			<description>Entry JS in ActionECMAScript is required</description>
			<test>containsJS == true</test>
			<error>
				<message>Entry JS in ActionECMAScript is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-JS-Stream" testNumber="10"/>
			<description>Entry JS with type Stream in ActionECMAScript shall be indirect</description>
			<test>JSHasTypeStream != true || isJSIndirect == true</test>
			<error>
				<message>Entry JS with type Stream in ActionECMAScript is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionECMAScript shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionECMAScript is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-Next" testNumber="8"/>
			<description>Entry Next in ActionECMAScript shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionECMAScript has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-S" testNumber="8"/>
			<description>Entry S in ActionECMAScript shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionECMAScript has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-S" testNumber="7"/>
			<description>Entry S in ActionECMAScript is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionECMAScript is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionECMAScript shall have value JavaScript</description>
			<test>SHasTypeName != true || SNameValue == "JavaScript"</test>
			<error>
				<message>Entry S with type Name in ActionECMAScript has incorrect value %1 instead of JavaScript</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-Type" testNumber="8"/>
			<description>Entry Type in ActionECMAScript shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionECMAScript has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionECMAScript">
			<id specification="PDF_1_4" clause="ActionECMAScript-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionECMAScript shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionECMAScript has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo" testNumber="1"/>
			<description>ActionGoTo shall not contain entries except D, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionGoTo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo" testNumber="22"/>
			<description>ActionGoTo shall not contain entry SD in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsSD == false</test>
			<error>
				<message>ActionGoTo contains entry SD</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-D-Array" testNumber="17"/>
			<description>Entry D with type Array in ActionGoTo shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in ActionGoTo is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-D" testNumber="8"/>
			<description>Entry D in ActionGoTo shall have one of types: Array, Name, StringByte</description>
			<test>containsD == false || DHasTypeArray == true || DHasTypeName == true || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in ActionGoTo has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-D" testNumber="7"/>
			<description>Entry D in ActionGoTo is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionGoTo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-D-StringByte" testNumber="14"/>
			<description>Entry D with type StringByte in ActionGoTo shall satisfy possible value predicate: fn:Eval(fn:IsNameTreeIndex(trailer::Catalog::Names::Dests, @D))</description>
			<test>DHasTypeStringByte != true || DIsNameTreetrailerCatalogNamesDestsIndex == true</test>
			<error>
				<message>Entry D with type StringByte in ActionGoTo does not satisfy possible value predicate: fn:Eval(fn:IsNameTreeIndex(trailer::Catalog::Names::Dests, @D))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionGoTo shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionGoTo is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-Next" testNumber="8"/>
			<description>Entry Next in ActionGoTo shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionGoTo has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-S" testNumber="8"/>
			<description>Entry S in ActionGoTo shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionGoTo has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-S" testNumber="7"/>
			<description>Entry S in ActionGoTo is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionGoTo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionGoTo shall have value GoTo</description>
			<test>SHasTypeName != true || SNameValue == "GoTo"</test>
			<error>
				<message>Entry S with type Name in ActionGoTo has incorrect value %1 instead of GoTo</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-Type" testNumber="8"/>
			<description>Entry Type in ActionGoTo shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionGoTo has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoTo">
			<id specification="PDF_1_4" clause="ActionGoTo-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionGoTo shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionGoTo has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR" testNumber="1"/>
			<description>ActionGoToR shall not contain entries except D, F, NewWindow, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionGoToR contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SD' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR" testNumber="22"/>
			<description>ActionGoToR shall not contain entry SD in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsSD == false</test>
			<error>
				<message>ActionGoToR contains entry SD</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-D-Array" testNumber="17"/>
			<description>Entry D with type Array in ActionGoToR shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in ActionGoToR is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-D" testNumber="8"/>
			<description>Entry D in ActionGoToR shall have one of types: Array, Name, StringByte</description>
			<test>containsD == false || DHasTypeArray == true || DHasTypeName == true || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in ActionGoToR has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-D" testNumber="7"/>
			<description>Entry D in ActionGoToR is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-F" testNumber="8"/>
			<description>Entry F in ActionGoToR shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionGoToR has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-F" testNumber="7"/>
			<description>Entry F in ActionGoToR is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-NewWindow" testNumber="8"/>
			<description>Entry NewWindow in ActionGoToR shall have type Boolean</description>
			<test>containsNewWindow == false || NewWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry NewWindow in ActionGoToR has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NewWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionGoToR shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionGoToR is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-Next" testNumber="8"/>
			<description>Entry Next in ActionGoToR shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionGoToR has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-S" testNumber="8"/>
			<description>Entry S in ActionGoToR shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionGoToR has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-S" testNumber="7"/>
			<description>Entry S in ActionGoToR is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionGoToR is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionGoToR shall have value GoToR</description>
			<test>SHasTypeName != true || SNameValue == "GoToR"</test>
			<error>
				<message>Entry S with type Name in ActionGoToR has incorrect value %1 instead of GoToR</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-Type" testNumber="8"/>
			<description>Entry Type in ActionGoToR shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionGoToR has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionGoToR">
			<id specification="PDF_1_4" clause="ActionGoToR-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionGoToR shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionGoToR has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide" testNumber="1"/>
			<description>ActionHide shall not contain entries except H, Next, S, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'H' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionHide contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'H' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-H" testNumber="8"/>
			<description>Entry H in ActionHide shall have type Boolean</description>
			<test>containsH == false || HHasTypeBoolean == true</test>
			<error>
				<message>Entry H in ActionHide has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionHide shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionHide is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-Next" testNumber="8"/>
			<description>Entry Next in ActionHide shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionHide has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-S" testNumber="8"/>
			<description>Entry S in ActionHide shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionHide has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-S" testNumber="7"/>
			<description>Entry S in ActionHide is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionHide is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionHide shall have value Hide</description>
			<test>SHasTypeName != true || SNameValue == "Hide"</test>
			<error>
				<message>Entry S with type Name in ActionHide has incorrect value %1 instead of Hide</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-T-Dictionary" testNumber="17"/>
			<description>Entry T with type Dictionary in ActionHide shall be one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>THasTypeDictionary != true || T_size == 1</test>
			<error>
				<message>Entry T with type Dictionary in ActionHide is not one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-T" testNumber="8"/>
			<description>Entry T in ActionHide shall have one of types: Array, Dictionary, StringText</description>
			<test>containsT == false || THasTypeArray == true || THasTypeDictionary == true || THasTypeStringText == true</test>
			<error>
				<message>Entry T in ActionHide has type %1 instead of one of types: Array, Dictionary, StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-T" testNumber="7"/>
			<description>Entry T in ActionHide is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in ActionHide is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in ActionHide shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in ActionHide is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-T-StringText" testNumber="9"/>
			<description>Entry T with type StringText in ActionHide shall satisfy special case: fn:Eval(fn:IsFieldName(@T))</description>
			<test>THasTypeStringText != true || (TIsFieldName == true)</test>
			<error>
				<message>Entry T with type StringText in ActionHide does not satisfy special case: fn:Eval(fn:IsFieldName(@T))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-Type" testNumber="8"/>
			<description>Entry Type in ActionHide shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionHide has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionHide">
			<id specification="PDF_1_4" clause="ActionHide-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionHide shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionHide has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData" testNumber="1"/>
			<description>ActionImportData shall not contain entries except F, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionImportData contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-F" testNumber="8"/>
			<description>Entry F in ActionImportData shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionImportData has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-F" testNumber="7"/>
			<description>Entry F in ActionImportData is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionImportData is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionImportData shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionImportData is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-Next" testNumber="8"/>
			<description>Entry Next in ActionImportData shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionImportData has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-S" testNumber="8"/>
			<description>Entry S in ActionImportData shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionImportData has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-S" testNumber="7"/>
			<description>Entry S in ActionImportData is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionImportData is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionImportData shall have value ImportData</description>
			<test>SHasTypeName != true || SNameValue == "ImportData"</test>
			<error>
				<message>Entry S with type Name in ActionImportData has incorrect value %1 instead of ImportData</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-Type" testNumber="8"/>
			<description>Entry Type in ActionImportData shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionImportData has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionImportData">
			<id specification="PDF_1_4" clause="ActionImportData-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionImportData shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionImportData has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch" testNumber="1"/>
			<description>ActionLaunch shall not contain entries except F, Mac, NewWindow, Next, S, Type, Unix, Win</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Unix' &amp;&amp; elem != 'Win' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionLaunch contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'NewWindow' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Unix' &amp;&amp; elem != 'Win' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-F" testNumber="8"/>
			<description>Entry F in ActionLaunch shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionLaunch has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-F" testNumber="11"/>
			<description>Entry F in ActionLaunch is required, when fn:Not(fn:IsPresent(Win) || fn:IsPresent(Mac) || fn:IsPresent(Unix))</description>
			<test>containsF == true || ((containsWin == true) || (containsMac == true) || (containsUnix == true))</test>
			<error>
				<message>Entry F in ActionLaunch is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Mac" testNumber="8"/>
			<description>Entry Mac in ActionLaunch shall have type Null</description>
			<test>containsMac == false || MacHasTypeNull == true</test>
			<error>
				<message>Entry Mac in ActionLaunch has type %1 instead of type Null</message>
				<arguments>
					<argument>MacType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-NewWindow" testNumber="8"/>
			<description>Entry NewWindow in ActionLaunch shall have type Boolean</description>
			<test>containsNewWindow == false || NewWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry NewWindow in ActionLaunch has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NewWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionLaunch shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionLaunch is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Next" testNumber="8"/>
			<description>Entry Next in ActionLaunch shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionLaunch has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-S" testNumber="8"/>
			<description>Entry S in ActionLaunch shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionLaunch has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-S" testNumber="7"/>
			<description>Entry S in ActionLaunch is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionLaunch is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionLaunch shall have value Launch</description>
			<test>SHasTypeName != true || SNameValue == "Launch"</test>
			<error>
				<message>Entry S with type Name in ActionLaunch has incorrect value %1 instead of Launch</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Type" testNumber="8"/>
			<description>Entry Type in ActionLaunch shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionLaunch has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionLaunch shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionLaunch has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Unix" testNumber="8"/>
			<description>Entry Unix in ActionLaunch shall have type Null</description>
			<test>containsUnix == false || UnixHasTypeNull == true</test>
			<error>
				<message>Entry Unix in ActionLaunch has type %1 instead of type Null</message>
				<arguments>
					<argument>UnixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionLaunch">
			<id specification="PDF_1_4" clause="ActionLaunch-Win" testNumber="8"/>
			<description>Entry Win in ActionLaunch shall have type Dictionary</description>
			<test>containsWin == false || WinHasTypeDictionary == true</test>
			<error>
				<message>Entry Win in ActionLaunch has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>WinType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie" testNumber="1"/>
			<description>ActionMovie shall not contain entries except Annotation, Next, Operation, S, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Annotation' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Operation' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Annotation' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Operation' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Annotation" testNumber="8"/>
			<description>Entry Annotation in ActionMovie shall have type Dictionary</description>
			<test>containsAnnotation == false || AnnotationHasTypeDictionary == true</test>
			<error>
				<message>Entry Annotation in ActionMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AnnotationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionMovie shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionMovie is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Next" testNumber="8"/>
			<description>Entry Next in ActionMovie shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionMovie has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Operation" testNumber="8"/>
			<description>Entry Operation in ActionMovie shall have type Name</description>
			<test>containsOperation == false || OperationHasTypeName == true</test>
			<error>
				<message>Entry Operation in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>OperationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Operation-Name" testNumber="6"/>
			<description>Entry Operation with type Name in ActionMovie shall have one of values: Play, Pause, Stop, Resume</description>
			<test>OperationHasTypeName != true || OperationNameValue == "Play" || OperationNameValue == "Stop" || OperationNameValue == "Pause" || OperationNameValue == "Resume"</test>
			<error>
				<message>Entry Operation with type Name in ActionMovie has incorrect value %1 instead of Play, Pause, Stop, Resume</message>
				<arguments>
					<argument>OperationNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-S" testNumber="8"/>
			<description>Entry S in ActionMovie shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-S" testNumber="7"/>
			<description>Entry S in ActionMovie is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionMovie shall have value Movie</description>
			<test>SHasTypeName != true || SNameValue == "Movie"</test>
			<error>
				<message>Entry S with type Name in ActionMovie has incorrect value %1 instead of Movie</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-T" testNumber="8"/>
			<description>Entry T in ActionMovie shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in ActionMovie has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Type" testNumber="8"/>
			<description>Entry Type in ActionMovie shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionMovie">
			<id specification="PDF_1_4" clause="ActionMovie-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionMovie shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionMovie has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed" testNumber="1"/>
			<description>ActionNamed shall not contain entries except N, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionNamed contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-N" testNumber="8"/>
			<description>Entry N in ActionNamed shall have type Name</description>
			<test>containsN == false || NHasTypeName == true</test>
			<error>
				<message>Entry N in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-N" testNumber="7"/>
			<description>Entry N in ActionNamed is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in ActionNamed is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionNamed shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionNamed is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-Next" testNumber="8"/>
			<description>Entry Next in ActionNamed shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionNamed has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-S" testNumber="8"/>
			<description>Entry S in ActionNamed shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-S" testNumber="7"/>
			<description>Entry S in ActionNamed is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionNamed is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionNamed shall have value Named</description>
			<test>SHasTypeName != true || SNameValue == "Named"</test>
			<error>
				<message>Entry S with type Name in ActionNamed has incorrect value %1 instead of Named</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-Type" testNumber="8"/>
			<description>Entry Type in ActionNamed shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionNamed has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionNamed">
			<id specification="PDF_1_4" clause="ActionNamed-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionNamed shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionNamed has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm" testNumber="1"/>
			<description>ActionResetForm shall not contain entries except Fields, Flags, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Fields' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionResetForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Fields' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Fields" testNumber="8"/>
			<description>Entry Fields in ActionResetForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in ActionResetForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Flags" testNumber="8"/>
			<description>Entry Flags in ActionResetForm shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in ActionResetForm has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Flags-Bitmask" testNumber="6"/>
			<description>Entry Flags with type Bitmask in ActionResetForm shall have one of values: 0, 1</description>
			<test>FlagsHasTypeBitmask != true || FlagsBitmaskValue == 0 || FlagsBitmaskValue == 1</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionResetForm has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>FlagsBitmaskValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in ActionResetForm shall satisfy special case: fn:Eval(fn:BitsClear(2, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 1 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 2 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionResetForm does not satisfy special case: fn:Eval(fn:BitsClear(2, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionResetForm shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionResetForm is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Next" testNumber="8"/>
			<description>Entry Next in ActionResetForm shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionResetForm has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-S" testNumber="8"/>
			<description>Entry S in ActionResetForm shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionResetForm has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-S" testNumber="7"/>
			<description>Entry S in ActionResetForm is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionResetForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionResetForm shall have value ResetForm</description>
			<test>SHasTypeName != true || SNameValue == "ResetForm"</test>
			<error>
				<message>Entry S with type Name in ActionResetForm has incorrect value %1 instead of ResetForm</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Type" testNumber="8"/>
			<description>Entry Type in ActionResetForm shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionResetForm has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionResetForm">
			<id specification="PDF_1_4" clause="ActionResetForm-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionResetForm shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionResetForm has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound" testNumber="1"/>
			<description>ActionSound shall not contain entries except Mix, Next, Repeat, S, Sound, Synchronous, Type, Volume</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Mix' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Repeat' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Volume' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Mix' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Repeat' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Volume' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Mix" testNumber="8"/>
			<description>Entry Mix in ActionSound shall have type Boolean</description>
			<test>containsMix == false || MixHasTypeBoolean == true</test>
			<error>
				<message>Entry Mix in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>MixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionSound shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionSound is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Next" testNumber="8"/>
			<description>Entry Next in ActionSound shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionSound has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Repeat" testNumber="8"/>
			<description>Entry Repeat in ActionSound shall have type Boolean</description>
			<test>containsRepeat == false || RepeatHasTypeBoolean == true</test>
			<error>
				<message>Entry Repeat in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>RepeatType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-S" testNumber="8"/>
			<description>Entry S in ActionSound shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionSound has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-S" testNumber="7"/>
			<description>Entry S in ActionSound is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionSound shall have value Sound</description>
			<test>SHasTypeName != true || SNameValue == "Sound"</test>
			<error>
				<message>Entry S with type Name in ActionSound has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Sound" testNumber="8"/>
			<description>Entry Sound in ActionSound shall have type Stream</description>
			<test>containsSound == false || SoundHasTypeStream == true</test>
			<error>
				<message>Entry Sound in ActionSound has type %1 instead of type Stream</message>
				<arguments>
					<argument>SoundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Sound" testNumber="7"/>
			<description>Entry Sound in ActionSound is required</description>
			<test>containsSound == true</test>
			<error>
				<message>Entry Sound in ActionSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Sound-Stream" testNumber="10"/>
			<description>Entry Sound with type Stream in ActionSound shall be indirect</description>
			<test>SoundHasTypeStream != true || isSoundIndirect == true</test>
			<error>
				<message>Entry Sound with type Stream in ActionSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Synchronous" testNumber="8"/>
			<description>Entry Synchronous in ActionSound shall have type Boolean</description>
			<test>containsSynchronous == false || SynchronousHasTypeBoolean == true</test>
			<error>
				<message>Entry Synchronous in ActionSound has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SynchronousType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Type" testNumber="8"/>
			<description>Entry Type in ActionSound shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionSound has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionSound shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionSound has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Volume" testNumber="8"/>
			<description>Entry Volume in ActionSound shall have type Number</description>
			<test>containsVolume == false || VolumeHasTypeNumber == true</test>
			<error>
				<message>Entry Volume in ActionSound has type %1 instead of type Number</message>
				<arguments>
					<argument>VolumeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSound">
			<id specification="PDF_1_4" clause="ActionSound-Volume-Number" testNumber="14"/>
			<description>Entry Volume with type Number in ActionSound shall satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</description>
			<test>VolumeHasTypeNumber != true || (VolumeNumberValue &gt;= -1) &amp;&amp; (VolumeNumberValue &lt;= 1)</test>
			<error>
				<message>Entry Volume with type Number in ActionSound does not satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm" testNumber="1"/>
			<description>ActionSubmitForm shall not contain entries except CharSet, F, Fields, Flags, S</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CharSet' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'S' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionSubmitForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CharSet' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'S' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-CharSet" testNumber="8"/>
			<description>Entry CharSet in ActionSubmitForm shall have type String</description>
			<test>containsCharSet == false || CharSetHasTypeString == true</test>
			<error>
				<message>Entry CharSet in ActionSubmitForm has type %1 instead of type String</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-CharSet-String" testNumber="6"/>
			<description>Entry CharSet with type String in ActionSubmitForm shall have one of values: GBK, UHC, utf-16, utf-8, Shift-JIS, BigFive</description>
			<test>CharSetHasTypeString != true || CharSetStringValue == "utf-8" || CharSetStringValue == "utf-16" || CharSetStringValue == "Shift-JIS" || CharSetStringValue == "BigFive" || CharSetStringValue == "GBK" || CharSetStringValue == "UHC"</test>
			<error>
				<message>Entry CharSet with type String in ActionSubmitForm has incorrect value %1 instead of GBK, UHC, utf-16, utf-8, Shift-JIS, BigFive</message>
				<arguments>
					<argument>CharSetStringValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-F" testNumber="8"/>
			<description>Entry F in ActionSubmitForm shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionSubmitForm has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-F" testNumber="7"/>
			<description>Entry F in ActionSubmitForm is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in ActionSubmitForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-Fields" testNumber="8"/>
			<description>Entry Fields in ActionSubmitForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in ActionSubmitForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-Flags" testNumber="8"/>
			<description>Entry Flags in ActionSubmitForm shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in ActionSubmitForm has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in ActionSubmitForm shall satisfy special case: fn:Eval(fn:BitClear(13) &amp;&amp; fn:BitsClear(15, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in ActionSubmitForm does not satisfy special case: fn:Eval(fn:BitClear(13) &amp;&amp; fn:BitsClear(15, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-S" testNumber="8"/>
			<description>Entry S in ActionSubmitForm shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionSubmitForm has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-S" testNumber="7"/>
			<description>Entry S in ActionSubmitForm is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionSubmitForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionSubmitForm">
			<id specification="PDF_1_4" clause="ActionSubmitForm-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionSubmitForm shall have value SubmitForm</description>
			<test>SHasTypeName != true || SNameValue == "SubmitForm"</test>
			<error>
				<message>Entry S with type Name in ActionSubmitForm has incorrect value %1 instead of SubmitForm</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread" testNumber="1"/>
			<description>ActionThread shall not contain entries except B, D, F, Next, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionThread contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-B" testNumber="8"/>
			<description>Entry B in ActionThread shall have one of types: Dictionary, Integer</description>
			<test>containsB == false || BHasTypeDictionary == true || BHasTypeInteger == true</test>
			<error>
				<message>Entry B in ActionThread has type %1 instead of one of types: Dictionary, Integer</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-B-Dictionary" testNumber="10"/>
			<description>Entry B with type Dictionary in ActionThread shall be indirect</description>
			<test>BHasTypeDictionary != true || isBIndirect == true</test>
			<error>
				<message>Entry B with type Dictionary in ActionThread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-B-Integer" testNumber="14"/>
			<description>Entry B with type Integer in ActionThread shall satisfy possible value predicate: fn:Eval(@B &gt;= 0)</description>
			<test>BHasTypeInteger != true || BIntegerValue &gt;= 0</test>
			<error>
				<message>Entry B with type Integer in ActionThread does not satisfy possible value predicate: fn:Eval(@B &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-D" testNumber="8"/>
			<description>Entry D in ActionThread shall have one of types: Dictionary, Integer, StringText</description>
			<test>containsD == false || DHasTypeDictionary == true || DHasTypeInteger == true || DHasTypeStringText == true</test>
			<error>
				<message>Entry D in ActionThread has type %1 instead of one of types: Dictionary, Integer, StringText</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-D" testNumber="7"/>
			<description>Entry D in ActionThread is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in ActionThread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-D-Dictionary" testNumber="10"/>
			<description>Entry D with type Dictionary in ActionThread shall be indirect</description>
			<test>DHasTypeDictionary != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Dictionary in ActionThread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-D-Integer" testNumber="14"/>
			<description>Entry D with type Integer in ActionThread shall satisfy possible value predicate: fn:Eval((@D &gt;= 0) &amp;&amp; (@D &lt; fn:ArrayLength(trailer::Catalog::Threads)))</description>
			<test>DHasTypeInteger != true || (DIntegerValue &gt;= 0) &amp;&amp; (trailerCatalogThreadsHasTypeArray == false || (DIntegerValue &lt; trailerCatalogThreadsArraySize))</test>
			<error>
				<message>Entry D with type Integer in ActionThread does not satisfy possible value predicate: fn:Eval((@D &gt;= 0) &amp;&amp; (@D &lt; fn:ArrayLength(trailer::Catalog::Threads)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-F" testNumber="8"/>
			<description>Entry F in ActionThread shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ActionThread has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionThread shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionThread is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-Next" testNumber="8"/>
			<description>Entry Next in ActionThread shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionThread has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-S" testNumber="8"/>
			<description>Entry S in ActionThread shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionThread has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-S" testNumber="7"/>
			<description>Entry S in ActionThread is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionThread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionThread shall have value Thread</description>
			<test>SHasTypeName != true || SNameValue == "Thread"</test>
			<error>
				<message>Entry S with type Name in ActionThread has incorrect value %1 instead of Thread</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-Type" testNumber="8"/>
			<description>Entry Type in ActionThread shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionThread has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionThread">
			<id specification="PDF_1_4" clause="ActionThread-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionThread shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionThread has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI" testNumber="1"/>
			<description>ActionURI shall not contain entries except IsMap, Next, S, Type, URI</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'IsMap' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'URI' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ActionURI contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'IsMap' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'URI' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-IsMap" testNumber="8"/>
			<description>Entry IsMap in ActionURI shall have type Boolean</description>
			<test>containsIsMap == false || IsMapHasTypeBoolean == true</test>
			<error>
				<message>Entry IsMap in ActionURI has type %1 instead of type Boolean</message>
				<arguments>
					<argument>IsMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-Next-Dictionary" testNumber="17"/>
			<description>Entry Next with type Dictionary in ActionURI shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>NextHasTypeDictionary != true || Next_size == 1</test>
			<error>
				<message>Entry Next with type Dictionary in ActionURI is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-Next" testNumber="8"/>
			<description>Entry Next in ActionURI shall have one of types: Array, Dictionary</description>
			<test>containsNext == false || NextHasTypeArray == true || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in ActionURI has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-S" testNumber="8"/>
			<description>Entry S in ActionURI shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in ActionURI has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-S" testNumber="7"/>
			<description>Entry S in ActionURI is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in ActionURI is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-S-Name" testNumber="6"/>
			<description>Entry S with type Name in ActionURI shall have value URI</description>
			<test>SHasTypeName != true || SNameValue == "URI"</test>
			<error>
				<message>Entry S with type Name in ActionURI has incorrect value %1 instead of URI</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-Type" testNumber="8"/>
			<description>Entry Type in ActionURI shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ActionURI has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ActionURI shall have value Action</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Action"</test>
			<error>
				<message>Entry Type with type Name in ActionURI has incorrect value %1 instead of Action</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-URI" testNumber="8"/>
			<description>Entry URI in ActionURI shall have type StringAscii</description>
			<test>containsURI == false || URIHasTypeStringAscii == true</test>
			<error>
				<message>Entry URI in ActionURI has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>URIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AActionURI">
			<id specification="PDF_1_4" clause="ActionURI-URI" testNumber="7"/>
			<description>Entry URI in ActionURI is required</description>
			<test>containsURI == true</test>
			<error>
				<message>Entry URI in ActionURI is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog" testNumber="1"/>
			<description>AddActionCatalog shall not contain entries except DC, DP, DS, WP, WS</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DC' &amp;&amp; elem != 'DP' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'WP' &amp;&amp; elem != 'WS' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionCatalog contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DC' &amp;&amp; elem != 'DP' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'WP' &amp;&amp; elem != 'WS' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog-DC" testNumber="8"/>
			<description>Entry DC in AddActionCatalog shall have type Dictionary</description>
			<test>containsDC == false || DCHasTypeDictionary == true</test>
			<error>
				<message>Entry DC in AddActionCatalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog-DP" testNumber="8"/>
			<description>Entry DP in AddActionCatalog shall have type Dictionary</description>
			<test>containsDP == false || DPHasTypeDictionary == true</test>
			<error>
				<message>Entry DP in AddActionCatalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog-DS" testNumber="8"/>
			<description>Entry DS in AddActionCatalog shall have type Dictionary</description>
			<test>containsDS == false || DSHasTypeDictionary == true</test>
			<error>
				<message>Entry DS in AddActionCatalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog-WP" testNumber="8"/>
			<description>Entry WP in AddActionCatalog shall have type Dictionary</description>
			<test>containsWP == false || WPHasTypeDictionary == true</test>
			<error>
				<message>Entry WP in AddActionCatalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>WPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionCatalog">
			<id specification="PDF_1_4" clause="AddActionCatalog-WS" testNumber="8"/>
			<description>Entry WS in AddActionCatalog shall have type Dictionary</description>
			<test>containsWS == false || WSHasTypeDictionary == true</test>
			<error>
				<message>Entry WS in AddActionCatalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>WSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionFormField">
			<id specification="PDF_1_4" clause="AddActionFormField" testNumber="1"/>
			<description>AddActionFormField shall not contain entries except C, F, K, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'K' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionFormField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'F' &amp;&amp; elem != 'K' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionFormField">
			<id specification="PDF_1_4" clause="AddActionFormField-C" testNumber="8"/>
			<description>Entry C in AddActionFormField shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in AddActionFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionFormField">
			<id specification="PDF_1_4" clause="AddActionFormField-F" testNumber="8"/>
			<description>Entry F in AddActionFormField shall have type Dictionary</description>
			<test>containsF == false || FHasTypeDictionary == true</test>
			<error>
				<message>Entry F in AddActionFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionFormField">
			<id specification="PDF_1_4" clause="AddActionFormField-K" testNumber="8"/>
			<description>Entry K in AddActionFormField shall have type Dictionary</description>
			<test>containsK == false || KHasTypeDictionary == true</test>
			<error>
				<message>Entry K in AddActionFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionFormField">
			<id specification="PDF_1_4" clause="AddActionFormField-V" testNumber="8"/>
			<description>Entry V in AddActionFormField shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in AddActionFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_4" clause="AddActionPageObject" testNumber="1"/>
			<description>AddActionPageObject shall not contain entries except C, O</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionPageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'O' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_4" clause="AddActionPageObject-C-Dictionary" testNumber="17"/>
			<description>Entry C with type Dictionary in AddActionPageObject shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>CHasTypeDictionary != true || C_size == 1</test>
			<error>
				<message>Entry C with type Dictionary in AddActionPageObject is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_4" clause="AddActionPageObject-C" testNumber="8"/>
			<description>Entry C in AddActionPageObject shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in AddActionPageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_4" clause="AddActionPageObject-O-Dictionary" testNumber="17"/>
			<description>Entry O with type Dictionary in AddActionPageObject shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>OHasTypeDictionary != true || O_size == 1</test>
			<error>
				<message>Entry O with type Dictionary in AddActionPageObject is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionPageObject">
			<id specification="PDF_1_4" clause="AddActionPageObject-O" testNumber="8"/>
			<description>Entry O in AddActionPageObject shall have type Dictionary</description>
			<test>containsO == false || OHasTypeDictionary == true</test>
			<error>
				<message>Entry O in AddActionPageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation" testNumber="1"/>
			<description>AddActionWidgetAnnotation shall not contain entries except Bl, D, E, Fo, U, X</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Bl' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'PC' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'PO' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'U' &amp;&amp; elem != 'X' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionWidgetAnnotation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Bl' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'PC' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'PO' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'U' &amp;&amp; elem != 'X' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation" testNumber="22"/>
			<description>AddActionWidgetAnnotation shall not contain entries PC, PI, PO, PV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PI' || elem == 'PO' || elem == 'PV').length == 0</test>
			<error>
				<message>AddActionWidgetAnnotation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PI' || elem == 'PO' || elem == 'PV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-Bl-Dictionary" testNumber="17"/>
			<description>Entry Bl with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>BlHasTypeDictionary != true || Bl_size == 1</test>
			<error>
				<message>Entry Bl with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-Bl" testNumber="8"/>
			<description>Entry Bl in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsBl == false || BlHasTypeDictionary == true</test>
			<error>
				<message>Entry Bl in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BlType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-D-Dictionary" testNumber="17"/>
			<description>Entry D with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>DHasTypeDictionary != true || D_size == 1</test>
			<error>
				<message>Entry D with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-D" testNumber="8"/>
			<description>Entry D in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsD == false || DHasTypeDictionary == true</test>
			<error>
				<message>Entry D in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-E-Dictionary" testNumber="17"/>
			<description>Entry E with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>EHasTypeDictionary != true || E_size == 1</test>
			<error>
				<message>Entry E with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-E" testNumber="8"/>
			<description>Entry E in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsE == false || EHasTypeDictionary == true</test>
			<error>
				<message>Entry E in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-Fo-Dictionary" testNumber="17"/>
			<description>Entry Fo with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>FoHasTypeDictionary != true || Fo_size == 1</test>
			<error>
				<message>Entry Fo with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-Fo" testNumber="8"/>
			<description>Entry Fo in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsFo == false || FoHasTypeDictionary == true</test>
			<error>
				<message>Entry Fo in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-U-Dictionary" testNumber="17"/>
			<description>Entry U with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>UHasTypeDictionary != true || U_size == 1</test>
			<error>
				<message>Entry U with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-U" testNumber="8"/>
			<description>Entry U in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsU == false || UHasTypeDictionary == true</test>
			<error>
				<message>Entry U in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-X-Dictionary" testNumber="17"/>
			<description>Entry X with type Dictionary in AddActionWidgetAnnotation shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>XHasTypeDictionary != true || X_size == 1</test>
			<error>
				<message>Entry X with type Dictionary in AddActionWidgetAnnotation is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotation">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotation-X" testNumber="8"/>
			<description>Entry X in AddActionWidgetAnnotation shall have type Dictionary</description>
			<test>containsX == false || XHasTypeDictionary == true</test>
			<error>
				<message>Entry X in AddActionWidgetAnnotation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>XType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField" testNumber="1"/>
			<description>AddActionWidgetAnnotationFormField shall not contain entries except Bl, C, D, E, F, Fo, K, U, V, X</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Bl' &amp;&amp; elem != 'C' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'K' &amp;&amp; elem != 'PC' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'PO' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'U' &amp;&amp; elem != 'V' &amp;&amp; elem != 'X' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AddActionWidgetAnnotationFormField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Bl' &amp;&amp; elem != 'C' &amp;&amp; elem != 'D' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Fo' &amp;&amp; elem != 'K' &amp;&amp; elem != 'PC' &amp;&amp; elem != 'PI' &amp;&amp; elem != 'PO' &amp;&amp; elem != 'PV' &amp;&amp; elem != 'U' &amp;&amp; elem != 'V' &amp;&amp; elem != 'X' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField" testNumber="22"/>
			<description>AddActionWidgetAnnotationFormField shall not contain entries PC, PI, PO, PV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PI' || elem == 'PO' || elem == 'PV').length == 0</test>
			<error>
				<message>AddActionWidgetAnnotationFormField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'PC' || elem == 'PI' || elem == 'PO' || elem == 'PV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-Bl-Dictionary" testNumber="17"/>
			<description>Entry Bl with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>BlHasTypeDictionary != true || Bl_size == 1</test>
			<error>
				<message>Entry Bl with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-Bl" testNumber="8"/>
			<description>Entry Bl in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsBl == false || BlHasTypeDictionary == true</test>
			<error>
				<message>Entry Bl in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BlType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-C" testNumber="8"/>
			<description>Entry C in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-D-Dictionary" testNumber="17"/>
			<description>Entry D with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>DHasTypeDictionary != true || D_size == 1</test>
			<error>
				<message>Entry D with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-D" testNumber="8"/>
			<description>Entry D in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsD == false || DHasTypeDictionary == true</test>
			<error>
				<message>Entry D in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-E-Dictionary" testNumber="17"/>
			<description>Entry E with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>EHasTypeDictionary != true || E_size == 1</test>
			<error>
				<message>Entry E with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-E" testNumber="8"/>
			<description>Entry E in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsE == false || EHasTypeDictionary == true</test>
			<error>
				<message>Entry E in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-F" testNumber="8"/>
			<description>Entry F in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsF == false || FHasTypeDictionary == true</test>
			<error>
				<message>Entry F in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-Fo-Dictionary" testNumber="17"/>
			<description>Entry Fo with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>FoHasTypeDictionary != true || Fo_size == 1</test>
			<error>
				<message>Entry Fo with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-Fo" testNumber="8"/>
			<description>Entry Fo in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsFo == false || FoHasTypeDictionary == true</test>
			<error>
				<message>Entry Fo in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-K" testNumber="8"/>
			<description>Entry K in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsK == false || KHasTypeDictionary == true</test>
			<error>
				<message>Entry K in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-U-Dictionary" testNumber="17"/>
			<description>Entry U with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>UHasTypeDictionary != true || U_size == 1</test>
			<error>
				<message>Entry U with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-U" testNumber="8"/>
			<description>Entry U in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsU == false || UHasTypeDictionary == true</test>
			<error>
				<message>Entry U in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-V" testNumber="8"/>
			<description>Entry V in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-X-Dictionary" testNumber="17"/>
			<description>Entry X with type Dictionary in AddActionWidgetAnnotationFormField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>XHasTypeDictionary != true || X_size == 1</test>
			<error>
				<message>Entry X with type Dictionary in AddActionWidgetAnnotationFormField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAddActionWidgetAnnotationFormField">
			<id specification="PDF_1_4" clause="AddActionWidgetAnnotationFormField-X" testNumber="8"/>
			<description>Entry X in AddActionWidgetAnnotationFormField shall have type Dictionary</description>
			<test>containsX == false || XHasTypeDictionary == true</test>
			<error>
				<message>Entry X in AddActionWidgetAnnotationFormField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>XType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage" testNumber="1"/>
			<description>AlternateImage shall not contain entries except DefaultForPrinting, Image</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DefaultForPrinting' &amp;&amp; elem != 'Image' &amp;&amp; elem != 'OC' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AlternateImage contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DefaultForPrinting' &amp;&amp; elem != 'Image' &amp;&amp; elem != 'OC' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage" testNumber="22"/>
			<description>AlternateImage shall not contain entry OC in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsOC == false</test>
			<error>
				<message>AlternateImage contains entry OC</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage-DefaultForPrinting" testNumber="8"/>
			<description>Entry DefaultForPrinting in AlternateImage shall have type Boolean</description>
			<test>containsDefaultForPrinting == false || DefaultForPrintingHasTypeBoolean == true</test>
			<error>
				<message>Entry DefaultForPrinting in AlternateImage has type %1 instead of type Boolean</message>
				<arguments>
					<argument>DefaultForPrintingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage-Image" testNumber="8"/>
			<description>Entry Image in AlternateImage shall have type Stream</description>
			<test>containsImage == false || ImageHasTypeStream == true</test>
			<error>
				<message>Entry Image in AlternateImage has type %1 instead of type Stream</message>
				<arguments>
					<argument>ImageType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage-Image" testNumber="7"/>
			<description>Entry Image in AlternateImage is required</description>
			<test>containsImage == true</test>
			<error>
				<message>Entry Image in AlternateImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAlternateImage">
			<id specification="PDF_1_4" clause="AlternateImage-Image-Stream" testNumber="10"/>
			<description>Entry Image with type Stream in AlternateImage shall be indirect</description>
			<test>ImageHasTypeStream != true || isImageIndirect == true</test>
			<error>
				<message>Entry Image with type Stream in AlternateImage is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle" testNumber="1"/>
			<description>AnnotCircle shall not contain entries except AP, AS, BS, Border, C, CA, Contents, F, IC, M, NM, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotCircle contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle" testNumber="22"/>
			<description>AnnotCircle shall not contain entries AF, BE, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RD, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotCircle contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-AP" testNumber="8"/>
			<description>Entry AP in AnnotCircle shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotCircle has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-AS" testNumber="8"/>
			<description>Entry AS in AnnotCircle shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotCircle has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-AS" testNumber="11"/>
			<description>Entry AS in AnnotCircle is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotCircle is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-BS" testNumber="8"/>
			<description>Entry BS in AnnotCircle shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotCircle has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Border" testNumber="8"/>
			<description>Entry Border in AnnotCircle shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotCircle has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-C" testNumber="8"/>
			<description>Entry C in AnnotCircle shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotCircle has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-CA" testNumber="8"/>
			<description>Entry CA in AnnotCircle shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotCircle has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotCircle shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotCircle does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotCircle shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotCircle has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-F" testNumber="8"/>
			<description>Entry F in AnnotCircle shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotCircle has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotCircle shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotCircle does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-IC" testNumber="8"/>
			<description>Entry IC in AnnotCircle shall have type Array</description>
			<test>containsIC == false || ICHasTypeArray == true</test>
			<error>
				<message>Entry IC in AnnotCircle has type %1 instead of type Array</message>
				<arguments>
					<argument>ICType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-M" testNumber="8"/>
			<description>Entry M in AnnotCircle shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotCircle has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-NM" testNumber="8"/>
			<description>Entry NM in AnnotCircle shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotCircle has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-P" testNumber="8"/>
			<description>Entry P in AnnotCircle shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotCircle has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotCircle shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotCircle is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotCircle shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotCircle has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotCircle shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotCircle is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotCircle shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotCircle has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotCircle is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotCircle is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotCircle shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotCircle has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotCircle shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotCircle has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotCircle is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotCircle is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotCircle shall have value Circle</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Circle"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotCircle has incorrect value %1 instead of Circle</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-T" testNumber="8"/>
			<description>Entry T in AnnotCircle shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotCircle has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Type" testNumber="8"/>
			<description>Entry Type in AnnotCircle shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotCircle has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotCircle">
			<id specification="PDF_1_4" clause="AnnotCircle-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotCircle shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotCircle has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment" testNumber="1"/>
			<description>AnnotFileAttachment shall not contain entries except AP, AS, Border, C, CA, Contents, F, FS, M, NM, Name, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotFileAttachment contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment" testNumber="22"/>
			<description>AnnotFileAttachment shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotFileAttachment contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-AP" testNumber="8"/>
			<description>Entry AP in AnnotFileAttachment shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotFileAttachment has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-AS" testNumber="8"/>
			<description>Entry AS in AnnotFileAttachment shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotFileAttachment has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-AS" testNumber="11"/>
			<description>Entry AS in AnnotFileAttachment is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotFileAttachment is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Border" testNumber="8"/>
			<description>Entry Border in AnnotFileAttachment shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotFileAttachment has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-C" testNumber="8"/>
			<description>Entry C in AnnotFileAttachment shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotFileAttachment has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-CA" testNumber="8"/>
			<description>Entry CA in AnnotFileAttachment shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotFileAttachment has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotFileAttachment shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotFileAttachment does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotFileAttachment shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotFileAttachment has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-F" testNumber="8"/>
			<description>Entry F in AnnotFileAttachment shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotFileAttachment has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotFileAttachment shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotFileAttachment does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-FS" testNumber="8"/>
			<description>Entry FS in AnnotFileAttachment shall have one of types: Dictionary, String</description>
			<test>containsFS == false || FSHasTypeDictionary == true || FSHasTypeString == true</test>
			<error>
				<message>Entry FS in AnnotFileAttachment has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-FS" testNumber="7"/>
			<description>Entry FS in AnnotFileAttachment is required</description>
			<test>containsFS == true</test>
			<error>
				<message>Entry FS in AnnotFileAttachment is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-M" testNumber="8"/>
			<description>Entry M in AnnotFileAttachment shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotFileAttachment has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-NM" testNumber="8"/>
			<description>Entry NM in AnnotFileAttachment shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotFileAttachment has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Name" testNumber="8"/>
			<description>Entry Name in AnnotFileAttachment shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotFileAttachment has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-P" testNumber="8"/>
			<description>Entry P in AnnotFileAttachment shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotFileAttachment has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotFileAttachment shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotFileAttachment is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotFileAttachment shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotFileAttachment has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotFileAttachment shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotFileAttachment is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotFileAttachment shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotFileAttachment has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotFileAttachment is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotFileAttachment is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotFileAttachment shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotFileAttachment has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotFileAttachment shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotFileAttachment has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotFileAttachment is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotFileAttachment is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotFileAttachment shall have value FileAttachment</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "FileAttachment"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotFileAttachment has incorrect value %1 instead of FileAttachment</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-T" testNumber="8"/>
			<description>Entry T in AnnotFileAttachment shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotFileAttachment has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Type" testNumber="8"/>
			<description>Entry Type in AnnotFileAttachment shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotFileAttachment has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFileAttachment">
			<id specification="PDF_1_4" clause="AnnotFileAttachment-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotFileAttachment shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotFileAttachment has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText" testNumber="1"/>
			<description>AnnotFreeText shall not contain entries except AP, AS, BS, Border, C, CA, Contents, DA, F, M, NM, P, Popup, Q, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'CL' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'LE' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotFreeText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'CL' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'LE' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText" testNumber="22"/>
			<description>AnnotFreeText shall not contain entries AF, BE, BM, CL, CreationDate, DS, ExData, IRT, IT, LE, Lang, OC, RC, RD, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CL' || elem == 'CreationDate' || elem == 'DS' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'LE' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotFreeText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CL' || elem == 'CreationDate' || elem == 'DS' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'LE' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-AP" testNumber="8"/>
			<description>Entry AP in AnnotFreeText shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotFreeText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-AS" testNumber="8"/>
			<description>Entry AS in AnnotFreeText shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotFreeText has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-AS" testNumber="11"/>
			<description>Entry AS in AnnotFreeText is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotFreeText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-BS" testNumber="8"/>
			<description>Entry BS in AnnotFreeText shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotFreeText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Border" testNumber="8"/>
			<description>Entry Border in AnnotFreeText shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotFreeText has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-C" testNumber="8"/>
			<description>Entry C in AnnotFreeText shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotFreeText has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-CA" testNumber="8"/>
			<description>Entry CA in AnnotFreeText shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotFreeText has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotFreeText shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotFreeText does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotFreeText shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotFreeText has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-DA" testNumber="8"/>
			<description>Entry DA in AnnotFreeText shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotFreeText has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-DA" testNumber="7"/>
			<description>Entry DA in AnnotFreeText is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotFreeText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-F" testNumber="8"/>
			<description>Entry F in AnnotFreeText shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotFreeText has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotFreeText shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotFreeText does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-M" testNumber="8"/>
			<description>Entry M in AnnotFreeText shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotFreeText has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-NM" testNumber="8"/>
			<description>Entry NM in AnnotFreeText shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotFreeText has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-P" testNumber="8"/>
			<description>Entry P in AnnotFreeText shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotFreeText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotFreeText shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotFreeText is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotFreeText shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotFreeText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotFreeText shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotFreeText is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Q" testNumber="8"/>
			<description>Entry Q in AnnotFreeText shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotFreeText has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotFreeText shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotFreeText has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotFreeText shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotFreeText has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotFreeText is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotFreeText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotFreeText shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotFreeText has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotFreeText shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotFreeText has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotFreeText is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotFreeText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotFreeText shall have value FreeText</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "FreeText"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotFreeText has incorrect value %1 instead of FreeText</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-T" testNumber="8"/>
			<description>Entry T in AnnotFreeText shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotFreeText has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Type" testNumber="8"/>
			<description>Entry Type in AnnotFreeText shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotFreeText has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotFreeText">
			<id specification="PDF_1_4" clause="AnnotFreeText-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotFreeText shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotFreeText has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight" testNumber="1"/>
			<description>AnnotHighlight shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, P, Popup, QuadPoints, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotHighlight contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight" testNumber="22"/>
			<description>AnnotHighlight shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotHighlight contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-AP" testNumber="8"/>
			<description>Entry AP in AnnotHighlight shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotHighlight has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-AS" testNumber="8"/>
			<description>Entry AS in AnnotHighlight shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotHighlight has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-AS" testNumber="11"/>
			<description>Entry AS in AnnotHighlight is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotHighlight is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Border" testNumber="8"/>
			<description>Entry Border in AnnotHighlight shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotHighlight has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-C" testNumber="8"/>
			<description>Entry C in AnnotHighlight shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotHighlight has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-CA" testNumber="8"/>
			<description>Entry CA in AnnotHighlight shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotHighlight has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotHighlight shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotHighlight does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotHighlight shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotHighlight has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-F" testNumber="8"/>
			<description>Entry F in AnnotHighlight shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotHighlight has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotHighlight shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotHighlight does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-M" testNumber="8"/>
			<description>Entry M in AnnotHighlight shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotHighlight has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-NM" testNumber="8"/>
			<description>Entry NM in AnnotHighlight shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotHighlight has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-P" testNumber="8"/>
			<description>Entry P in AnnotHighlight shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotHighlight has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotHighlight shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotHighlight is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotHighlight shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotHighlight has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotHighlight shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotHighlight is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-QuadPoints" testNumber="8"/>
			<description>Entry QuadPoints in AnnotHighlight shall have type Array</description>
			<test>containsQuadPoints == false || QuadPointsHasTypeArray == true</test>
			<error>
				<message>Entry QuadPoints in AnnotHighlight has type %1 instead of type Array</message>
				<arguments>
					<argument>QuadPointsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-QuadPoints" testNumber="7"/>
			<description>Entry QuadPoints in AnnotHighlight is required</description>
			<test>containsQuadPoints == true</test>
			<error>
				<message>Entry QuadPoints in AnnotHighlight is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotHighlight shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotHighlight has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotHighlight is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotHighlight is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotHighlight shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotHighlight has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotHighlight shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotHighlight has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotHighlight is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotHighlight is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotHighlight shall have value Highlight</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Highlight"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotHighlight has incorrect value %1 instead of Highlight</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-T" testNumber="8"/>
			<description>Entry T in AnnotHighlight shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotHighlight has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Type" testNumber="8"/>
			<description>Entry Type in AnnotHighlight shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotHighlight has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotHighlight">
			<id specification="PDF_1_4" clause="AnnotHighlight-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotHighlight shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotHighlight has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk" testNumber="1"/>
			<description>AnnotInk shall not contain entries except AP, AS, BS, Border, C, CA, Contents, F, InkList, M, NM, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'InkList' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotInk contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'InkList' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk" testNumber="22"/>
			<description>AnnotInk shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, Path, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'Path' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotInk contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'Path' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-AP" testNumber="8"/>
			<description>Entry AP in AnnotInk shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotInk has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-AS" testNumber="8"/>
			<description>Entry AS in AnnotInk shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotInk has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-AS" testNumber="11"/>
			<description>Entry AS in AnnotInk is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotInk is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-BS" testNumber="8"/>
			<description>Entry BS in AnnotInk shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotInk has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Border" testNumber="8"/>
			<description>Entry Border in AnnotInk shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotInk has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-C" testNumber="8"/>
			<description>Entry C in AnnotInk shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotInk has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-CA" testNumber="8"/>
			<description>Entry CA in AnnotInk shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotInk has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotInk shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotInk does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotInk shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotInk has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-F" testNumber="8"/>
			<description>Entry F in AnnotInk shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotInk has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotInk shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotInk does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-InkList" testNumber="8"/>
			<description>Entry InkList in AnnotInk shall have type Array</description>
			<test>containsInkList == false || InkListHasTypeArray == true</test>
			<error>
				<message>Entry InkList in AnnotInk has type %1 instead of type Array</message>
				<arguments>
					<argument>InkListType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-InkList" testNumber="7"/>
			<description>Entry InkList in AnnotInk is required</description>
			<test>containsInkList == true</test>
			<error>
				<message>Entry InkList in AnnotInk is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-M" testNumber="8"/>
			<description>Entry M in AnnotInk shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotInk has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-NM" testNumber="8"/>
			<description>Entry NM in AnnotInk shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotInk has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-P" testNumber="8"/>
			<description>Entry P in AnnotInk shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotInk has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotInk shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotInk is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotInk shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotInk has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotInk shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotInk is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotInk shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotInk has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotInk is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotInk is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotInk shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotInk has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotInk shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotInk has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotInk is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotInk is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotInk shall have value Ink</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Ink"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotInk has incorrect value %1 instead of Ink</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-T" testNumber="8"/>
			<description>Entry T in AnnotInk shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotInk has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Type" testNumber="8"/>
			<description>Entry Type in AnnotInk shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotInk has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotInk">
			<id specification="PDF_1_4" clause="AnnotInk-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotInk shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotInk has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine" testNumber="1"/>
			<description>AnnotLine shall not contain entries except AP, AS, BS, Border, C, CA, Contents, F, IC, L, LE, M, NM, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'Cap' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'L' &amp;&amp; elem != 'LE' &amp;&amp; elem != 'LL' &amp;&amp; elem != 'LLE' &amp;&amp; elem != 'LLO' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotLine contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'Cap' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'L' &amp;&amp; elem != 'LE' &amp;&amp; elem != 'LL' &amp;&amp; elem != 'LLE' &amp;&amp; elem != 'LLO' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine" testNumber="22"/>
			<description>AnnotLine shall not contain entries AF, BM, CO, CP, Cap, CreationDate, ExData, IRT, IT, LL, LLE, LLO, Lang, Measure, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CO' || elem == 'CP' || elem == 'Cap' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'LL' || elem == 'LLE' || elem == 'LLO' || elem == 'Lang' || elem == 'Measure' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotLine contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CO' || elem == 'CP' || elem == 'Cap' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'LL' || elem == 'LLE' || elem == 'LLO' || elem == 'Lang' || elem == 'Measure' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-AP" testNumber="8"/>
			<description>Entry AP in AnnotLine shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotLine has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-AS" testNumber="8"/>
			<description>Entry AS in AnnotLine shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotLine has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-AS" testNumber="11"/>
			<description>Entry AS in AnnotLine is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotLine is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-BS" testNumber="8"/>
			<description>Entry BS in AnnotLine shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotLine has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Border" testNumber="8"/>
			<description>Entry Border in AnnotLine shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotLine has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-C" testNumber="8"/>
			<description>Entry C in AnnotLine shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotLine has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-CA" testNumber="8"/>
			<description>Entry CA in AnnotLine shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotLine has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotLine shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotLine does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotLine shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotLine has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-F" testNumber="8"/>
			<description>Entry F in AnnotLine shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotLine has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotLine shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotLine does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-IC" testNumber="8"/>
			<description>Entry IC in AnnotLine shall have type Array</description>
			<test>containsIC == false || ICHasTypeArray == true</test>
			<error>
				<message>Entry IC in AnnotLine has type %1 instead of type Array</message>
				<arguments>
					<argument>ICType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-L" testNumber="8"/>
			<description>Entry L in AnnotLine shall have type Array</description>
			<test>containsL == false || LHasTypeArray == true</test>
			<error>
				<message>Entry L in AnnotLine has type %1 instead of type Array</message>
				<arguments>
					<argument>LType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-L" testNumber="7"/>
			<description>Entry L in AnnotLine is required</description>
			<test>containsL == true</test>
			<error>
				<message>Entry L in AnnotLine is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-LE" testNumber="8"/>
			<description>Entry LE in AnnotLine shall have type Array</description>
			<test>containsLE == false || LEHasTypeArray == true</test>
			<error>
				<message>Entry LE in AnnotLine has type %1 instead of type Array</message>
				<arguments>
					<argument>LEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-M" testNumber="8"/>
			<description>Entry M in AnnotLine shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotLine has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-NM" testNumber="8"/>
			<description>Entry NM in AnnotLine shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotLine has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-P" testNumber="8"/>
			<description>Entry P in AnnotLine shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotLine has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotLine shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotLine is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotLine shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotLine has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotLine shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotLine is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotLine shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotLine has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotLine is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotLine is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotLine shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotLine has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotLine shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotLine has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotLine is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotLine is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotLine shall have value Line</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Line"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotLine has incorrect value %1 instead of Line</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-T" testNumber="8"/>
			<description>Entry T in AnnotLine shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotLine has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Type" testNumber="8"/>
			<description>Entry Type in AnnotLine shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotLine has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLine">
			<id specification="PDF_1_4" clause="AnnotLine-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotLine shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotLine has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink" testNumber="1"/>
			<description>AnnotLink shall not contain entries except A, AP, AS, BS, Border, C, Contents, Dest, F, H, M, NM, P, PA, Rect, StructParent, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PA' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotLink contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PA' &amp;&amp; elem != 'Path' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink" testNumber="22"/>
			<description>AnnotLink shall not contain entries AF, BM, CA, Lang, OC, Path, QuadPoints, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'Path' || elem == 'QuadPoints' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotLink contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'Path' || elem == 'QuadPoints' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotLink shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotLink is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-A" testNumber="8"/>
			<description>Entry A in AnnotLink shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-AP" testNumber="8"/>
			<description>Entry AP in AnnotLink shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-AS" testNumber="8"/>
			<description>Entry AS in AnnotLink shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-AS" testNumber="11"/>
			<description>Entry AS in AnnotLink is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-BS" testNumber="8"/>
			<description>Entry BS in AnnotLink shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Border" testNumber="8"/>
			<description>Entry Border in AnnotLink shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotLink has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-C" testNumber="8"/>
			<description>Entry C in AnnotLink shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotLink has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotLink shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotLink has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Dest-Array" testNumber="17"/>
			<description>Entry Dest with type Array in AnnotLink shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DestHasTypeArray != true || Dest_size == 1</test>
			<error>
				<message>Entry Dest with type Array in AnnotLink is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Dest" testNumber="8"/>
			<description>Entry Dest in AnnotLink shall have one of types: Array, Name, StringByte</description>
			<test>containsDest == false || DestHasTypeArray == true || DestHasTypeName == true || DestHasTypeStringByte == true</test>
			<error>
				<message>Entry Dest in AnnotLink has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DestType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-F" testNumber="8"/>
			<description>Entry F in AnnotLink shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotLink has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotLink shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotLink does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-H" testNumber="8"/>
			<description>Entry H in AnnotLink shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotLink shall have one of values: P, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P"</test>
			<error>
				<message>Entry H with type Name in AnnotLink has incorrect value %1 instead of P, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-M" testNumber="8"/>
			<description>Entry M in AnnotLink shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotLink has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-NM" testNumber="8"/>
			<description>Entry NM in AnnotLink shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotLink has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-P" testNumber="8"/>
			<description>Entry P in AnnotLink shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotLink shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotLink is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-PA" testNumber="8"/>
			<description>Entry PA in AnnotLink shall have type Dictionary</description>
			<test>containsPA == false || PAHasTypeDictionary == true</test>
			<error>
				<message>Entry PA in AnnotLink has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotLink shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotLink has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotLink is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotLink shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotLink has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotLink shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotLink is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotLink is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotLink shall have value Link</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Link"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotLink has incorrect value %1 instead of Link</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Type" testNumber="8"/>
			<description>Entry Type in AnnotLink shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotLink has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotLink">
			<id specification="PDF_1_4" clause="AnnotLink-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotLink shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotLink has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie" testNumber="1"/>
			<description>AnnotMovie shall not contain entries except A, AP, AS, Border, C, Contents, F, M, Movie, NM, P, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Movie' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Movie' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie" testNumber="22"/>
			<description>AnnotMovie shall not contain entries AF, BM, CA, Lang, OC, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotMovie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-A" testNumber="8"/>
			<description>Entry A in AnnotMovie shall have one of types: Boolean, Dictionary</description>
			<test>containsA == false || AHasTypeBoolean == true || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotMovie has type %1 instead of one of types: Boolean, Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-AP" testNumber="8"/>
			<description>Entry AP in AnnotMovie shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-AS" testNumber="8"/>
			<description>Entry AS in AnnotMovie shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-AS" testNumber="11"/>
			<description>Entry AS in AnnotMovie is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Border" testNumber="8"/>
			<description>Entry Border in AnnotMovie shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotMovie has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-C" testNumber="8"/>
			<description>Entry C in AnnotMovie shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotMovie has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotMovie shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotMovie has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-F" testNumber="8"/>
			<description>Entry F in AnnotMovie shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotMovie has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotMovie shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotMovie does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-M" testNumber="8"/>
			<description>Entry M in AnnotMovie shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotMovie has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Movie" testNumber="8"/>
			<description>Entry Movie in AnnotMovie shall have type Dictionary</description>
			<test>containsMovie == false || MovieHasTypeDictionary == true</test>
			<error>
				<message>Entry Movie in AnnotMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MovieType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Movie" testNumber="7"/>
			<description>Entry Movie in AnnotMovie is required</description>
			<test>containsMovie == true</test>
			<error>
				<message>Entry Movie in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-NM" testNumber="8"/>
			<description>Entry NM in AnnotMovie shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotMovie has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-P" testNumber="8"/>
			<description>Entry P in AnnotMovie shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotMovie has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotMovie shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotMovie is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotMovie shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotMovie has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotMovie is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotMovie shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotMovie has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotMovie shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotMovie is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotMovie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotMovie shall have value Movie</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Movie"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotMovie has incorrect value %1 instead of Movie</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-T" testNumber="8"/>
			<description>Entry T in AnnotMovie shall have type String</description>
			<test>containsT == false || THasTypeString == true</test>
			<error>
				<message>Entry T in AnnotMovie has type %1 instead of type String</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Type" testNumber="8"/>
			<description>Entry Type in AnnotMovie shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotMovie has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotMovie">
			<id specification="PDF_1_4" clause="AnnotMovie-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotMovie shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotMovie has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup" testNumber="1"/>
			<description>AnnotPopup shall not contain entries except AP, AS, Border, C, Contents, F, M, NM, Open, P, Parent, Rect, StructParent, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotPopup contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup" testNumber="22"/>
			<description>AnnotPopup shall not contain entries AF, BM, CA, Lang, OC, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotPopup contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-AP" testNumber="8"/>
			<description>Entry AP in AnnotPopup shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotPopup has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-AS" testNumber="8"/>
			<description>Entry AS in AnnotPopup shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotPopup has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-AS" testNumber="11"/>
			<description>Entry AS in AnnotPopup is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotPopup is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Border" testNumber="8"/>
			<description>Entry Border in AnnotPopup shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotPopup has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-C" testNumber="8"/>
			<description>Entry C in AnnotPopup shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotPopup has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotPopup shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotPopup has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-F" testNumber="8"/>
			<description>Entry F in AnnotPopup shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotPopup has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotPopup shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotPopup does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-M" testNumber="8"/>
			<description>Entry M in AnnotPopup shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotPopup has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-NM" testNumber="8"/>
			<description>Entry NM in AnnotPopup shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotPopup has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Open" testNumber="8"/>
			<description>Entry Open in AnnotPopup shall have type Boolean</description>
			<test>containsOpen == false || OpenHasTypeBoolean == true</test>
			<error>
				<message>Entry Open in AnnotPopup has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OpenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-P" testNumber="8"/>
			<description>Entry P in AnnotPopup shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotPopup has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotPopup shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotPopup is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotPopup shall be one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotPopup is not one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotPopup shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotPopup has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotPopup shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotPopup has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotPopup is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotPopup is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotPopup shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotPopup has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotPopup shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotPopup has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotPopup is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotPopup is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotPopup shall have value Popup</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Popup"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotPopup has incorrect value %1 instead of Popup</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Type" testNumber="8"/>
			<description>Entry Type in AnnotPopup shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotPopup has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPopup">
			<id specification="PDF_1_4" clause="AnnotPopup-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotPopup shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotPopup has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark" testNumber="1"/>
			<description>AnnotPrinterMark shall not contain entries except AP, AS, Border, C, Contents, F, M, MN, NM, P, Rect, StructParent, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MN' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotPrinterMark contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MN' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark" testNumber="22"/>
			<description>AnnotPrinterMark shall not contain entries AF, BM, CA, Lang, OC, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotPrinterMark contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-AP" testNumber="8"/>
			<description>Entry AP in AnnotPrinterMark shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-AS" testNumber="8"/>
			<description>Entry AS in AnnotPrinterMark shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-AS" testNumber="11"/>
			<description>Entry AS in AnnotPrinterMark is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Border" testNumber="8"/>
			<description>Entry Border in AnnotPrinterMark shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotPrinterMark has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-C" testNumber="8"/>
			<description>Entry C in AnnotPrinterMark shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotPrinterMark has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotPrinterMark shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotPrinterMark has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-F" testNumber="8"/>
			<description>Entry F in AnnotPrinterMark shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotPrinterMark has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-F" testNumber="7"/>
			<description>Entry F in AnnotPrinterMark is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in AnnotPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotPrinterMark shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotPrinterMark does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-M" testNumber="8"/>
			<description>Entry M in AnnotPrinterMark shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotPrinterMark has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-MN" testNumber="8"/>
			<description>Entry MN in AnnotPrinterMark shall have type Name</description>
			<test>containsMN == false || MNHasTypeName == true</test>
			<error>
				<message>Entry MN in AnnotPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>MNType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-NM" testNumber="8"/>
			<description>Entry NM in AnnotPrinterMark shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotPrinterMark has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-P" testNumber="8"/>
			<description>Entry P in AnnotPrinterMark shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotPrinterMark shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotPrinterMark is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotPrinterMark shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotPrinterMark has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotPrinterMark is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotPrinterMark shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotPrinterMark has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotPrinterMark shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotPrinterMark is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotPrinterMark shall have value PrinterMark</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "PrinterMark"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotPrinterMark has incorrect value %1 instead of PrinterMark</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Type" testNumber="8"/>
			<description>Entry Type in AnnotPrinterMark shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotPrinterMark">
			<id specification="PDF_1_4" clause="AnnotPrinterMark-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotPrinterMark shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotPrinterMark has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound" testNumber="1"/>
			<description>AnnotSound shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, Name, P, Popup, Rect, Sound, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'Sound' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound" testNumber="22"/>
			<description>AnnotSound shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotSound contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-AP" testNumber="8"/>
			<description>Entry AP in AnnotSound shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotSound has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-AS" testNumber="8"/>
			<description>Entry AS in AnnotSound shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-AS" testNumber="11"/>
			<description>Entry AS in AnnotSound is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Border" testNumber="8"/>
			<description>Entry Border in AnnotSound shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotSound has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-C" testNumber="8"/>
			<description>Entry C in AnnotSound shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotSound has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-CA" testNumber="8"/>
			<description>Entry CA in AnnotSound shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotSound has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotSound shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotSound does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotSound shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotSound has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-F" testNumber="8"/>
			<description>Entry F in AnnotSound shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotSound has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotSound shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotSound does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-M" testNumber="8"/>
			<description>Entry M in AnnotSound shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotSound has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-NM" testNumber="8"/>
			<description>Entry NM in AnnotSound shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotSound has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Name" testNumber="8"/>
			<description>Entry Name in AnnotSound shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-P" testNumber="8"/>
			<description>Entry P in AnnotSound shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotSound has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotSound shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotSound shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotSound has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotSound shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotSound shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotSound has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotSound is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Sound" testNumber="8"/>
			<description>Entry Sound in AnnotSound shall have type Stream</description>
			<test>containsSound == false || SoundHasTypeStream == true</test>
			<error>
				<message>Entry Sound in AnnotSound has type %1 instead of type Stream</message>
				<arguments>
					<argument>SoundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Sound" testNumber="7"/>
			<description>Entry Sound in AnnotSound is required</description>
			<test>containsSound == true</test>
			<error>
				<message>Entry Sound in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Sound-Stream" testNumber="10"/>
			<description>Entry Sound with type Stream in AnnotSound shall be indirect</description>
			<test>SoundHasTypeStream != true || isSoundIndirect == true</test>
			<error>
				<message>Entry Sound with type Stream in AnnotSound is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotSound shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotSound has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotSound shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotSound is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotSound is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotSound shall have value Sound</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Sound"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotSound has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-T" testNumber="8"/>
			<description>Entry T in AnnotSound shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotSound has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Type" testNumber="8"/>
			<description>Entry Type in AnnotSound shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotSound has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSound">
			<id specification="PDF_1_4" clause="AnnotSound-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotSound shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotSound has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare" testNumber="1"/>
			<description>AnnotSquare shall not contain entries except AP, AS, BS, Border, C, Contents, F, IC, M, NM, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotSquare contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BE' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IC' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RD' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare" testNumber="22"/>
			<description>AnnotSquare shall not contain entries AF, BE, BM, CA, CreationDate, ExData, IRT, IT, Lang, OC, RC, RD, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CA' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotSquare contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BE' || elem == 'BM' || elem == 'CA' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RD' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-AP" testNumber="8"/>
			<description>Entry AP in AnnotSquare shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotSquare has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-AS" testNumber="8"/>
			<description>Entry AS in AnnotSquare shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotSquare has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-AS" testNumber="11"/>
			<description>Entry AS in AnnotSquare is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotSquare is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-BS" testNumber="8"/>
			<description>Entry BS in AnnotSquare shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotSquare has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Border" testNumber="8"/>
			<description>Entry Border in AnnotSquare shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotSquare has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-C" testNumber="8"/>
			<description>Entry C in AnnotSquare shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotSquare has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotSquare shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotSquare has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-F" testNumber="8"/>
			<description>Entry F in AnnotSquare shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotSquare has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotSquare shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotSquare does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-IC" testNumber="8"/>
			<description>Entry IC in AnnotSquare shall have type Array</description>
			<test>containsIC == false || ICHasTypeArray == true</test>
			<error>
				<message>Entry IC in AnnotSquare has type %1 instead of type Array</message>
				<arguments>
					<argument>ICType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-M" testNumber="8"/>
			<description>Entry M in AnnotSquare shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotSquare has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-NM" testNumber="8"/>
			<description>Entry NM in AnnotSquare shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotSquare has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-P" testNumber="8"/>
			<description>Entry P in AnnotSquare shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotSquare has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotSquare shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotSquare is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotSquare shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotSquare has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotSquare shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotSquare is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotSquare shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotSquare has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotSquare is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotSquare is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotSquare shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotSquare has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotSquare shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotSquare has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotSquare is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotSquare is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotSquare shall have value Square</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Square"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotSquare has incorrect value %1 instead of Square</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-T" testNumber="8"/>
			<description>Entry T in AnnotSquare shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotSquare has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Type" testNumber="8"/>
			<description>Entry Type in AnnotSquare shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotSquare has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquare">
			<id specification="PDF_1_4" clause="AnnotSquare-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotSquare shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotSquare has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly" testNumber="1"/>
			<description>AnnotSquiggly shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, P, Popup, QuadPoints, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotSquiggly contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly" testNumber="22"/>
			<description>AnnotSquiggly shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotSquiggly contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-AP" testNumber="8"/>
			<description>Entry AP in AnnotSquiggly shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotSquiggly has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-AS" testNumber="8"/>
			<description>Entry AS in AnnotSquiggly shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotSquiggly has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-AS" testNumber="11"/>
			<description>Entry AS in AnnotSquiggly is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotSquiggly is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Border" testNumber="8"/>
			<description>Entry Border in AnnotSquiggly shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotSquiggly has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-C" testNumber="8"/>
			<description>Entry C in AnnotSquiggly shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotSquiggly has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-CA" testNumber="8"/>
			<description>Entry CA in AnnotSquiggly shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotSquiggly has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotSquiggly shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotSquiggly does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotSquiggly shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotSquiggly has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-F" testNumber="8"/>
			<description>Entry F in AnnotSquiggly shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotSquiggly has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotSquiggly shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotSquiggly does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-M" testNumber="8"/>
			<description>Entry M in AnnotSquiggly shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotSquiggly has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-NM" testNumber="8"/>
			<description>Entry NM in AnnotSquiggly shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotSquiggly has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-P" testNumber="8"/>
			<description>Entry P in AnnotSquiggly shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotSquiggly has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotSquiggly shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotSquiggly is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotSquiggly shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotSquiggly has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotSquiggly shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotSquiggly is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-QuadPoints" testNumber="8"/>
			<description>Entry QuadPoints in AnnotSquiggly shall have type Array</description>
			<test>containsQuadPoints == false || QuadPointsHasTypeArray == true</test>
			<error>
				<message>Entry QuadPoints in AnnotSquiggly has type %1 instead of type Array</message>
				<arguments>
					<argument>QuadPointsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-QuadPoints" testNumber="7"/>
			<description>Entry QuadPoints in AnnotSquiggly is required</description>
			<test>containsQuadPoints == true</test>
			<error>
				<message>Entry QuadPoints in AnnotSquiggly is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotSquiggly shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotSquiggly has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotSquiggly is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotSquiggly is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotSquiggly shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotSquiggly has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotSquiggly shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotSquiggly has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotSquiggly is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotSquiggly is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotSquiggly shall have value Squiggly</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Squiggly"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotSquiggly has incorrect value %1 instead of Squiggly</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-T" testNumber="8"/>
			<description>Entry T in AnnotSquiggly shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotSquiggly has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Type" testNumber="8"/>
			<description>Entry Type in AnnotSquiggly shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotSquiggly has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotSquiggly">
			<id specification="PDF_1_4" clause="AnnotSquiggly-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotSquiggly shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotSquiggly has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp" testNumber="1"/>
			<description>AnnotStamp shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, Name, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotStamp contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp" testNumber="22"/>
			<description>AnnotStamp shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotStamp contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-AP" testNumber="8"/>
			<description>Entry AP in AnnotStamp shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotStamp has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-AS" testNumber="8"/>
			<description>Entry AS in AnnotStamp shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotStamp has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-AS" testNumber="11"/>
			<description>Entry AS in AnnotStamp is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotStamp is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Border" testNumber="8"/>
			<description>Entry Border in AnnotStamp shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotStamp has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-C" testNumber="8"/>
			<description>Entry C in AnnotStamp shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotStamp has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-CA" testNumber="8"/>
			<description>Entry CA in AnnotStamp shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotStamp has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotStamp shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotStamp does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotStamp shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotStamp has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-F" testNumber="8"/>
			<description>Entry F in AnnotStamp shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotStamp has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotStamp shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotStamp does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-M" testNumber="8"/>
			<description>Entry M in AnnotStamp shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotStamp has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-NM" testNumber="8"/>
			<description>Entry NM in AnnotStamp shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotStamp has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Name" testNumber="8"/>
			<description>Entry Name in AnnotStamp shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotStamp has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-P" testNumber="8"/>
			<description>Entry P in AnnotStamp shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotStamp has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotStamp shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotStamp is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotStamp shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotStamp has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotStamp shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotStamp is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotStamp shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotStamp has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotStamp is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotStamp is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotStamp shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotStamp has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotStamp shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotStamp has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotStamp is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotStamp is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotStamp shall have value Stamp</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Stamp"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotStamp has incorrect value %1 instead of Stamp</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-T" testNumber="8"/>
			<description>Entry T in AnnotStamp shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotStamp has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Type" testNumber="8"/>
			<description>Entry Type in AnnotStamp shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotStamp has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStamp">
			<id specification="PDF_1_4" clause="AnnotStamp-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotStamp shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotStamp has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut" testNumber="1"/>
			<description>AnnotStrikeOut shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, P, Popup, QuadPoints, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotStrikeOut contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut" testNumber="22"/>
			<description>AnnotStrikeOut shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotStrikeOut contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-AP" testNumber="8"/>
			<description>Entry AP in AnnotStrikeOut shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotStrikeOut has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-AS" testNumber="8"/>
			<description>Entry AS in AnnotStrikeOut shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotStrikeOut has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-AS" testNumber="11"/>
			<description>Entry AS in AnnotStrikeOut is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotStrikeOut is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Border" testNumber="8"/>
			<description>Entry Border in AnnotStrikeOut shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotStrikeOut has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-C" testNumber="8"/>
			<description>Entry C in AnnotStrikeOut shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotStrikeOut has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-CA" testNumber="8"/>
			<description>Entry CA in AnnotStrikeOut shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotStrikeOut has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotStrikeOut shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotStrikeOut does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotStrikeOut shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotStrikeOut has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-F" testNumber="8"/>
			<description>Entry F in AnnotStrikeOut shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotStrikeOut has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotStrikeOut shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotStrikeOut does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-M" testNumber="8"/>
			<description>Entry M in AnnotStrikeOut shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotStrikeOut has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-NM" testNumber="8"/>
			<description>Entry NM in AnnotStrikeOut shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotStrikeOut has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-P" testNumber="8"/>
			<description>Entry P in AnnotStrikeOut shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotStrikeOut has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotStrikeOut shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotStrikeOut is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotStrikeOut shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotStrikeOut has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotStrikeOut shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotStrikeOut is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-QuadPoints" testNumber="8"/>
			<description>Entry QuadPoints in AnnotStrikeOut shall have type Array</description>
			<test>containsQuadPoints == false || QuadPointsHasTypeArray == true</test>
			<error>
				<message>Entry QuadPoints in AnnotStrikeOut has type %1 instead of type Array</message>
				<arguments>
					<argument>QuadPointsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-QuadPoints" testNumber="7"/>
			<description>Entry QuadPoints in AnnotStrikeOut is required</description>
			<test>containsQuadPoints == true</test>
			<error>
				<message>Entry QuadPoints in AnnotStrikeOut is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotStrikeOut shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotStrikeOut has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotStrikeOut is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotStrikeOut is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotStrikeOut shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotStrikeOut has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotStrikeOut shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotStrikeOut has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotStrikeOut is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotStrikeOut is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotStrikeOut shall have value StrikeOut</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "StrikeOut"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotStrikeOut has incorrect value %1 instead of StrikeOut</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-T" testNumber="8"/>
			<description>Entry T in AnnotStrikeOut shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotStrikeOut has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Type" testNumber="8"/>
			<description>Entry Type in AnnotStrikeOut shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotStrikeOut has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotStrikeOut">
			<id specification="PDF_1_4" clause="AnnotStrikeOut-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotStrikeOut shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotStrikeOut has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText" testNumber="1"/>
			<description>AnnotText shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, Name, Open, P, Popup, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'State' &amp;&amp; elem != 'StateModel' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Open' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'State' &amp;&amp; elem != 'StateModel' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText" testNumber="22"/>
			<description>AnnotText shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, State, StateModel, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'State' || elem == 'StateModel' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotText contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'State' || elem == 'StateModel' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-AP" testNumber="8"/>
			<description>Entry AP in AnnotText shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-AS" testNumber="8"/>
			<description>Entry AS in AnnotText shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-AS" testNumber="11"/>
			<description>Entry AS in AnnotText is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Border" testNumber="8"/>
			<description>Entry Border in AnnotText shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotText has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-C" testNumber="8"/>
			<description>Entry C in AnnotText shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotText has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-CA" testNumber="8"/>
			<description>Entry CA in AnnotText shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotText has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotText shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotText does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotText shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotText has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-F" testNumber="8"/>
			<description>Entry F in AnnotText shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotText has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotText shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotText does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-M" testNumber="8"/>
			<description>Entry M in AnnotText shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotText has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-NM" testNumber="8"/>
			<description>Entry NM in AnnotText shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotText has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Name" testNumber="8"/>
			<description>Entry Name in AnnotText shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Name-Name" testNumber="6"/>
			<description>Entry Name with type Name in AnnotText shall have one of values: Comment, Help, Note, Insert, Key, NewParagraph, Paragraph</description>
			<test>NameHasTypeName != true || NameNameValue == "Comment" || NameNameValue == "Key" || NameNameValue == "Note" || NameNameValue == "Help" || NameNameValue == "NewParagraph" || NameNameValue == "Paragraph" || NameNameValue == "Insert"</test>
			<error>
				<message>Entry Name with type Name in AnnotText has incorrect value %1 instead of Comment, Help, Note, Insert, Key, NewParagraph, Paragraph</message>
				<arguments>
					<argument>NameNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Open" testNumber="8"/>
			<description>Entry Open in AnnotText shall have type Boolean</description>
			<test>containsOpen == false || OpenHasTypeBoolean == true</test>
			<error>
				<message>Entry Open in AnnotText has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OpenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-P" testNumber="8"/>
			<description>Entry P in AnnotText shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotText shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotText is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotText shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotText has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotText shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotText is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotText shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotText has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotText is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotText shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotText has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotText shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotText is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotText is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotText shall have value Text</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Text"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotText has incorrect value %1 instead of Text</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-T" testNumber="8"/>
			<description>Entry T in AnnotText shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotText has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Type" testNumber="8"/>
			<description>Entry Type in AnnotText shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotText has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotText">
			<id specification="PDF_1_4" clause="AnnotText-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotText shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotText has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork" testNumber="1"/>
			<description>AnnotTrapNetwork shall not contain entries except AP, AS, AnnotStates, Border, C, Contents, F, FontFauxing, LastModified, M, NM, P, Rect, StructParent, Subtype, Type, Version</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'AnnotStates' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FontFauxing' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotTrapNetwork contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'AnnotStates' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FontFauxing' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork" testNumber="22"/>
			<description>AnnotTrapNetwork shall not contain entries AF, BM, CA, Lang, OC, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotTrapNetwork contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AP" testNumber="8"/>
			<description>Entry AP in AnnotTrapNetwork shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotTrapNetwork has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AP" testNumber="7"/>
			<description>Entry AP in AnnotTrapNetwork is required</description>
			<test>containsAP == true</test>
			<error>
				<message>Entry AP in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AS" testNumber="8"/>
			<description>Entry AS in AnnotTrapNetwork shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotTrapNetwork has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AS" testNumber="7"/>
			<description>Entry AS in AnnotTrapNetwork is required</description>
			<test>containsAS == true</test>
			<error>
				<message>Entry AS in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AnnotStates" testNumber="8"/>
			<description>Entry AnnotStates in AnnotTrapNetwork shall have type Array</description>
			<test>containsAnnotStates == false || AnnotStatesHasTypeArray == true</test>
			<error>
				<message>Entry AnnotStates in AnnotTrapNetwork has type %1 instead of type Array</message>
				<arguments>
					<argument>AnnotStatesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-AnnotStates" testNumber="11"/>
			<description>Entry AnnotStates in AnnotTrapNetwork is required, when (fn:IsPresent(Version) &amp;&amp; fn:Not(fn:IsPresent(LastModified)))</description>
			<test>containsAnnotStates == true || ((containsVersion != true) || (containsLastModified == true))</test>
			<error>
				<message>Entry AnnotStates in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Border" testNumber="8"/>
			<description>Entry Border in AnnotTrapNetwork shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotTrapNetwork has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-C" testNumber="8"/>
			<description>Entry C in AnnotTrapNetwork shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotTrapNetwork has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotTrapNetwork shall have type String</description>
			<test>containsContents == false || ContentsHasTypeString == true</test>
			<error>
				<message>Entry Contents in AnnotTrapNetwork has type %1 instead of type String</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-F" testNumber="8"/>
			<description>Entry F in AnnotTrapNetwork shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotTrapNetwork has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-F" testNumber="7"/>
			<description>Entry F in AnnotTrapNetwork is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotTrapNetwork shall satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitSet(3) &amp;&amp; fn:BitsClear(4, 6) &amp;&amp; fn:BitSet(7) &amp;&amp; fn:BitsClear(8, 32))</description>
			<test>FHasTypeBitmask != true || (((FBitmaskValue &gt;&gt; 0 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 1 &amp; 1) == 0) &amp;&amp; (FBitmaskValue &gt;&gt; 2 &amp; 1) == 1 &amp;&amp; ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0) &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 1 &amp;&amp; ((FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry F with type Bitmask in AnnotTrapNetwork does not satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitSet(3) &amp;&amp; fn:BitsClear(4, 6) &amp;&amp; fn:BitSet(7) &amp;&amp; fn:BitsClear(8, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-FontFauxing" testNumber="8"/>
			<description>Entry FontFauxing in AnnotTrapNetwork shall have type Array</description>
			<test>containsFontFauxing == false || FontFauxingHasTypeArray == true</test>
			<error>
				<message>Entry FontFauxing in AnnotTrapNetwork has type %1 instead of type Array</message>
				<arguments>
					<argument>FontFauxingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-LastModified" testNumber="8"/>
			<description>Entry LastModified in AnnotTrapNetwork shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in AnnotTrapNetwork has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-LastModified" testNumber="11"/>
			<description>Entry LastModified in AnnotTrapNetwork is required, when fn:Not(fn:IsPresent(Version)) &amp;&amp; fn:Not(fn:IsPresent(AnnotStates))</description>
			<test>containsLastModified == true || ((containsVersion == true) || (containsAnnotStates == true))</test>
			<error>
				<message>Entry LastModified in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-M" testNumber="8"/>
			<description>Entry M in AnnotTrapNetwork shall have one of types: Date, String</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeString == true</test>
			<error>
				<message>Entry M in AnnotTrapNetwork has type %1 instead of one of types: Date, String</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-NM" testNumber="8"/>
			<description>Entry NM in AnnotTrapNetwork shall have type String</description>
			<test>containsNM == false || NMHasTypeString == true</test>
			<error>
				<message>Entry NM in AnnotTrapNetwork has type %1 instead of type String</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-P" testNumber="8"/>
			<description>Entry P in AnnotTrapNetwork shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotTrapNetwork has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotTrapNetwork shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotTrapNetwork is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotTrapNetwork shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotTrapNetwork has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotTrapNetwork is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotTrapNetwork shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotTrapNetwork has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotTrapNetwork shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotTrapNetwork has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotTrapNetwork is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotTrapNetwork shall have value TrapNet</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "TrapNet"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotTrapNetwork has incorrect value %1 instead of TrapNet</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Type" testNumber="8"/>
			<description>Entry Type in AnnotTrapNetwork shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotTrapNetwork has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotTrapNetwork shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotTrapNetwork has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Version" testNumber="8"/>
			<description>Entry Version in AnnotTrapNetwork shall have type Array</description>
			<test>containsVersion == false || VersionHasTypeArray == true</test>
			<error>
				<message>Entry Version in AnnotTrapNetwork has type %1 instead of type Array</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotTrapNetwork">
			<id specification="PDF_1_4" clause="AnnotTrapNetwork-Version" testNumber="11"/>
			<description>Entry Version in AnnotTrapNetwork is required, when (fn:IsPresent(AnnotStates) &amp;&amp; fn:Not(fn:IsPresent(LastModified)))</description>
			<test>containsVersion == true || ((containsAnnotStates != true) || (containsLastModified == true))</test>
			<error>
				<message>Entry Version in AnnotTrapNetwork is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline" testNumber="1"/>
			<description>AnnotUnderline shall not contain entries except AP, AS, Border, C, CA, Contents, F, M, NM, P, Popup, QuadPoints, Rect, StructParent, Subtype, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotUnderline contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'ExData' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IRT' &amp;&amp; elem != 'IT' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Popup' &amp;&amp; elem != 'QuadPoints' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RT' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subj' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline" testNumber="22"/>
			<description>AnnotUnderline shall not contain entries AF, BM, CreationDate, ExData, IRT, IT, Lang, OC, RC, RT, Subj, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotUnderline contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CreationDate' || elem == 'ExData' || elem == 'IRT' || elem == 'IT' || elem == 'Lang' || elem == 'OC' || elem == 'RC' || elem == 'RT' || elem == 'Subj' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-AP" testNumber="8"/>
			<description>Entry AP in AnnotUnderline shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotUnderline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-AS" testNumber="8"/>
			<description>Entry AS in AnnotUnderline shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotUnderline has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-AS" testNumber="11"/>
			<description>Entry AS in AnnotUnderline is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotUnderline is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Border" testNumber="8"/>
			<description>Entry Border in AnnotUnderline shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotUnderline has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-C" testNumber="8"/>
			<description>Entry C in AnnotUnderline shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotUnderline has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-CA" testNumber="8"/>
			<description>Entry CA in AnnotUnderline shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in AnnotUnderline has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in AnnotUnderline shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0.0) &amp;&amp; (CANumberValue &lt;= 1.0)</test>
			<error>
				<message>Entry CA with type Number in AnnotUnderline does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0.0) &amp;&amp; (@CA &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotUnderline shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotUnderline has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-F" testNumber="8"/>
			<description>Entry F in AnnotUnderline shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotUnderline has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotUnderline shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotUnderline does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-M" testNumber="8"/>
			<description>Entry M in AnnotUnderline shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotUnderline has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-NM" testNumber="8"/>
			<description>Entry NM in AnnotUnderline shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotUnderline has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-P" testNumber="8"/>
			<description>Entry P in AnnotUnderline shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotUnderline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotUnderline shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotUnderline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Popup" testNumber="8"/>
			<description>Entry Popup in AnnotUnderline shall have type Dictionary</description>
			<test>containsPopup == false || PopupHasTypeDictionary == true</test>
			<error>
				<message>Entry Popup in AnnotUnderline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PopupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Popup-Dictionary" testNumber="10"/>
			<description>Entry Popup with type Dictionary in AnnotUnderline shall be indirect</description>
			<test>PopupHasTypeDictionary != true || isPopupIndirect == true</test>
			<error>
				<message>Entry Popup with type Dictionary in AnnotUnderline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-QuadPoints" testNumber="8"/>
			<description>Entry QuadPoints in AnnotUnderline shall have type Array</description>
			<test>containsQuadPoints == false || QuadPointsHasTypeArray == true</test>
			<error>
				<message>Entry QuadPoints in AnnotUnderline has type %1 instead of type Array</message>
				<arguments>
					<argument>QuadPointsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-QuadPoints" testNumber="7"/>
			<description>Entry QuadPoints in AnnotUnderline is required</description>
			<test>containsQuadPoints == true</test>
			<error>
				<message>Entry QuadPoints in AnnotUnderline is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotUnderline shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotUnderline has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotUnderline is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotUnderline is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotUnderline shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotUnderline has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotUnderline shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotUnderline has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotUnderline is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotUnderline is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotUnderline shall have value Underline</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Underline"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotUnderline has incorrect value %1 instead of Underline</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-T" testNumber="8"/>
			<description>Entry T in AnnotUnderline shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotUnderline has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Type" testNumber="8"/>
			<description>Entry Type in AnnotUnderline shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotUnderline has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotUnderline">
			<id specification="PDF_1_4" clause="AnnotUnderline-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotUnderline shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotUnderline has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget" testNumber="1"/>
			<description>AnnotWidget shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, F, Ff, H, Kids, M, MK, NM, P, Parent, Rect, StructParent, Subtype, T, TM, TU, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidget contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget" testNumber="22"/>
			<description>AnnotWidget shall not contain entries AF, BM, CA, Lang, OC, PMD, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidget contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidget shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidget is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-A" testNumber="8"/>
			<description>Entry A in AnnotWidget shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidget shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidget shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidget shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidget is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidget shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidget shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-C" testNumber="8"/>
			<description>Entry C in AnnotWidget shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidget shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-F" testNumber="8"/>
			<description>Entry F in AnnotWidget shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidget has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidget shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidget does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidget shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidget has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-H" testNumber="8"/>
			<description>Entry H in AnnotWidget shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidget shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidget has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Kids" testNumber="8"/>
			<description>Entry Kids in AnnotWidget shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in AnnotWidget has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-M" testNumber="8"/>
			<description>Entry M in AnnotWidget shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidget has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidget shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidget shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-P" testNumber="8"/>
			<description>Entry P in AnnotWidget shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidget shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidget is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidget shall be one of objects Field, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidget is not one of objects Field, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidget shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidget has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidget shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidget has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidget is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidget shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidget has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidget shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidget is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidget is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidget shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidget has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-T" testNumber="8"/>
			<description>Entry T in AnnotWidget shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidget shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidget shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidget has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidget shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidget has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidget">
			<id specification="PDF_1_4" clause="AnnotWidget-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidget shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidget has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField" testNumber="1"/>
			<description>AnnotWidgetField shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, F, Ff, H, M, MK, NM, P, Parent, Rect, StructParent, Subtype, T, TM, TU, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField" testNumber="22"/>
			<description>AnnotWidgetField shall not contain entries AF, BM, CA, Lang, OC, PMD, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetField contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetField shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetField is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetField shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetField shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetField shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetField shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetField is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetField shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetField shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetField has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetField shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetField has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetField shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetField shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetField has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetField shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetField does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetField shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetField has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetField shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetField does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetField shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetField shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetField has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetField shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetField has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetField shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetField shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetField shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetField shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetField is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetField shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetField is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetField shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetField has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetField shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetField has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetField is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetField shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetField has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetField shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetField is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetField is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetField shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetField has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetField shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetField shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetField shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetField has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetField shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetField has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetField">
			<id specification="PDF_1_4" clause="AnnotWidgetField-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetField shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetField has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox" testNumber="1"/>
			<description>AnnotWidgetFieldBtnCheckbox shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, M, MK, NM, Opt, P, Parent, Q, Rect, StructParent, Subtype, T, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox" testNumber="22"/>
			<description>AnnotWidgetFieldBtnCheckbox shall not contain entries AF, BM, CA, DS, Lang, OC, PMD, RV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnCheckbox shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnCheckbox is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnCheckbox is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnCheckbox shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnCheckbox shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnCheckbox shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnCheckbox shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnCheckbox shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnCheckbox shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnCheckbox has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Opt" testNumber="8"/>
			<description>Entry Opt in AnnotWidgetFieldBtnCheckbox shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldBtnCheckbox shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldBtnCheckbox is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnCheckbox shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnCheckbox is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnCheckbox shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnCheckbox shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnCheckbox shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnCheckbox shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldBtnCheckbox shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnCheckbox is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnCheckbox shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldBtnCheckbox shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnCheckbox shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnCheckbox has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnCheckbox-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnCheckbox shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush" testNumber="1"/>
			<description>AnnotWidgetFieldBtnPush shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, M, MK, NM, P, Parent, Q, Rect, StructParent, Subtype, T, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush" testNumber="22"/>
			<description>AnnotWidgetFieldBtnPush shall not contain entries AF, BM, CA, DS, Lang, OC, PMD, RV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnPush shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnPush is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnPush is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnPush shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnPush shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnPush shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnPush has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnPush is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnPush shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnPush is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnPush shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnPush shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnPush shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnPush shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnPush has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldBtnPush shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldBtnPush is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnPush shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnPush is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnPush shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnPush shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnPush has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnPush shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnPush has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnPush shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnPush has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnPush is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldBtnPush shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldBtnPush has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnPush is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnPush shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldBtnPush shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnPush shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnPush has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnPush">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnPush-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnPush shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio" testNumber="1"/>
			<description>AnnotWidgetFieldBtnRadio shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, M, MK, NM, Opt, P, Parent, Q, Rect, StructParent, Subtype, T, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio" testNumber="22"/>
			<description>AnnotWidgetFieldBtnRadio shall not contain entries AF, BM, CA, DS, Lang, OC, PMD, RV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldBtnRadio shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldBtnRadio is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldBtnRadio is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldBtnRadio shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnRadio has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldBtnRadio shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldBtnRadio shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldBtnRadio shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldBtnRadio shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldBtnRadio shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldBtnRadio has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Opt" testNumber="8"/>
			<description>Entry Opt in AnnotWidgetFieldBtnRadio shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in AnnotWidgetFieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldBtnRadio shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldBtnRadio is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldBtnRadio shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldBtnRadio is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldBtnRadio shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldBtnRadio shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldBtnRadio has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldBtnRadio shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldBtnRadio shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnRadio has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldBtnRadio shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldBtnRadio has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldBtnRadio is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldBtnRadio shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldBtnRadio shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldBtnRadio shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldBtnRadio has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldBtnRadio">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldBtnRadio-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldBtnRadio shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice" testNumber="1"/>
			<description>AnnotWidgetFieldChoice shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, I, M, MK, NM, Opt, P, Parent, Q, Rect, StructParent, Subtype, T, TI, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice" testNumber="22"/>
			<description>AnnotWidgetFieldChoice shall not contain entries AF, BM, CA, DS, Lang, OC, PMD, RV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldChoice shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldChoice is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldChoice is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldChoice shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldChoice has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldChoice is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldChoice shall have one of types: Array, StringText</description>
			<test>containsDV == false || DVHasTypeArray == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldChoice shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldChoice is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldChoice shall have value Ch</description>
			<test>FTHasTypeName != true || FTNameValue == "Ch"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Ch</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldChoice shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldChoice shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-I" testNumber="8"/>
			<description>Entry I in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsI == false || IHasTypeArray == true</test>
			<error>
				<message>Entry I in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-I-Array" testNumber="9"/>
			<description>Entry I with type Array in AnnotWidgetFieldChoice shall satisfy special case: fn:Eval(fn:ArraySortAscending(I, 1))</description>
			<test>IHasTypeArray != true || (isIArraySortAscending1 == true)</test>
			<error>
				<message>Entry I with type Array in AnnotWidgetFieldChoice does not satisfy special case: fn:Eval(fn:ArraySortAscending(I, 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldChoice shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldChoice has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Opt" testNumber="8"/>
			<description>Entry Opt in AnnotWidgetFieldChoice shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in AnnotWidgetFieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldChoice shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldChoice is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldChoice shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldChoice is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldChoice shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldChoice shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldChoice shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldChoice has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldChoice shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldChoice has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldChoice is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldChoice shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldChoice is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldChoice shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-TI" testNumber="8"/>
			<description>Entry TI in AnnotWidgetFieldChoice shall have type Integer</description>
			<test>containsTI == false || TIHasTypeInteger == true</test>
			<error>
				<message>Entry TI in AnnotWidgetFieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>TIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-TI-Integer" testNumber="14"/>
			<description>Entry TI with type Integer in AnnotWidgetFieldChoice shall satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</description>
			<test>TIHasTypeInteger != true || (TIIntegerValue &gt;= 0) &amp;&amp; (OptHasTypeArray == false || (TIIntegerValue &lt; OptArraySize))</test>
			<error>
				<message>Entry TI with type Integer in AnnotWidgetFieldChoice does not satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldChoice shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldChoice shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldChoice shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldChoice has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldChoice">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldChoice-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldChoice shall have one of types: Array, StringText</description>
			<test>containsV == false || VHasTypeArray == true || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig" testNumber="1"/>
			<description>AnnotWidgetFieldSig shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, M, MK, NM, P, Parent, Q, Rect, StructParent, Subtype, T, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Lock' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'SV' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldSig contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Lock' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'SV' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig" testNumber="22"/>
			<description>AnnotWidgetFieldSig shall not contain entries AF, BM, CA, DS, Lang, Lock, OC, PMD, RV, SV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'Lock' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'SV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldSig contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'Lock' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'SV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldSig shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldSig is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldSig shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldSig is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldSig is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldSig shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldSig has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldSig shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldSig has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldSig shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldSig shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldSig has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-DV-Dictionary" testNumber="17"/>
			<description>Entry DV with type Dictionary in AnnotWidgetFieldSig shall be one of objects Signature, DocTimeStamp</description>
			<test>DVHasTypeDictionary != true || DV_size == 1</test>
			<error>
				<message>Entry DV with type Dictionary in AnnotWidgetFieldSig is not one of objects Signature, DocTimeStamp</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsDV == false || DVHasTypeDictionary == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldSig shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldSig has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldSig shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldSig does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldSig shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldSig is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldSig is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldSig shall have value Sig</description>
			<test>FTHasTypeName != true || FTNameValue == "Sig"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldSig has incorrect value %1 instead of Sig</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldSig shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldSig has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldSig shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldSig does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldSig shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldSig shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldSig has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldSig shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldSig has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldSig shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldSig shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldSig is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldSig shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldSig is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldSig shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldSig has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldSig shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldSig has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldSig shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldSig has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldSig is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldSig is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldSig shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldSig has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldSig shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldSig is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldSig is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldSig shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldSig has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldSig shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldSig shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldSig shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldSig shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldSig shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldSig has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in AnnotWidgetFieldSig shall be one of objects Signature, DocTimeStamp</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in AnnotWidgetFieldSig is not one of objects Signature, DocTimeStamp</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldSig">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldSig-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldSig shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx" testNumber="1"/>
			<description>AnnotWidgetFieldTx shall not contain entries except A, AA, AP, AS, BS, Border, C, Contents, DA, DV, F, FT, Ff, H, M, MK, MaxLen, NM, P, Parent, Q, Rect, StructParent, Subtype, T, TM, TU, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AnnotWidgetFieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AP' &amp;&amp; elem != 'AS' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'BS' &amp;&amp; elem != 'Border' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'H' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'M' &amp;&amp; elem != 'MK' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'NM' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'P' &amp;&amp; elem != 'PMD' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'Rect' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; elem != 'ca' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx" testNumber="22"/>
			<description>AnnotWidgetFieldTx shall not contain entries AF, BM, CA, DS, Lang, OC, PMD, RV, ca in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').length == 0</test>
			<error>
				<message>AnnotWidgetFieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'BM' || elem == 'CA' || elem == 'DS' || elem == 'Lang' || elem == 'OC' || elem == 'PMD' || elem == 'RV' || elem == 'ca').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in AnnotWidgetFieldTx shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in AnnotWidgetFieldTx is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-A" testNumber="8"/>
			<description>Entry A in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-AA" testNumber="8"/>
			<description>Entry AA in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-AP" testNumber="8"/>
			<description>Entry AP in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsAP == false || APHasTypeDictionary == true</test>
			<error>
				<message>Entry AP in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-AS" testNumber="8"/>
			<description>Entry AS in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsAS == false || ASHasTypeName == true</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>ASType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-AS" testNumber="11"/>
			<description>Entry AS in AnnotWidgetFieldTx is required, when fn:IsDictionary(AP::N) || fn:IsDictionary(AP::R) || fn:IsDictionary(AP::D)</description>
			<test>containsAS == true || (APNHasTypeDictionary != true &amp;&amp; APRHasTypeDictionary != true &amp;&amp; APDHasTypeDictionary != true)</test>
			<error>
				<message>Entry AS in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-BS" testNumber="8"/>
			<description>Entry BS in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsBS == false || BSHasTypeDictionary == true</test>
			<error>
				<message>Entry BS in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Border" testNumber="8"/>
			<description>Entry Border in AnnotWidgetFieldTx shall have type Array</description>
			<test>containsBorder == false || BorderHasTypeArray == true</test>
			<error>
				<message>Entry Border in AnnotWidgetFieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>BorderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-C" testNumber="8"/>
			<description>Entry C in AnnotWidgetFieldTx shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in AnnotWidgetFieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Contents" testNumber="8"/>
			<description>Entry Contents in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsContents == false || ContentsHasTypeStringText == true</test>
			<error>
				<message>Entry Contents in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-DA" testNumber="8"/>
			<description>Entry DA in AnnotWidgetFieldTx shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldTx has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-DA" testNumber="7"/>
			<description>Entry DA in AnnotWidgetFieldTx is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-DV" testNumber="8"/>
			<description>Entry DV in AnnotWidgetFieldTx shall have one of types: Stream, StringText</description>
			<test>containsDV == false || DVHasTypeStream == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in AnnotWidgetFieldTx has type %1 instead of one of types: Stream, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-DV-Stream" testNumber="10"/>
			<description>Entry DV with type Stream in AnnotWidgetFieldTx shall be indirect</description>
			<test>DVHasTypeStream != true || isDVIndirect == true</test>
			<error>
				<message>Entry DV with type Stream in AnnotWidgetFieldTx is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-F" testNumber="8"/>
			<description>Entry F in AnnotWidgetFieldTx shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in AnnotWidgetFieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(fn:BitsClear(9, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(fn:BitsClear(9, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-FT" testNumber="8"/>
			<description>Entry FT in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-FT" testNumber="7"/>
			<description>Entry FT in AnnotWidgetFieldTx is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in AnnotWidgetFieldTx shall have value Tx</description>
			<test>FTHasTypeName != true || FTNameValue == "Tx"</test>
			<error>
				<message>Entry FT with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Tx</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Ff" testNumber="8"/>
			<description>Entry Ff in AnnotWidgetFieldTx shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in AnnotWidgetFieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-H" testNumber="8"/>
			<description>Entry H in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsH == false || HHasTypeName == true</test>
			<error>
				<message>Entry H in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-H-Name" testNumber="6"/>
			<description>Entry H with type Name in AnnotWidgetFieldTx shall have one of values: P, T, I, N, O</description>
			<test>HHasTypeName != true || HNameValue == "N" || HNameValue == "I" || HNameValue == "O" || HNameValue == "P" || HNameValue == "T"</test>
			<error>
				<message>Entry H with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of P, T, I, N, O</message>
				<arguments>
					<argument>HNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-M" testNumber="8"/>
			<description>Entry M in AnnotWidgetFieldTx shall have one of types: Date, StringText</description>
			<test>containsM == false || MHasTypeDate == true || MHasTypeStringText == true</test>
			<error>
				<message>Entry M in AnnotWidgetFieldTx has type %1 instead of one of types: Date, StringText</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-MK" testNumber="8"/>
			<description>Entry MK in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsMK == false || MKHasTypeDictionary == true</test>
			<error>
				<message>Entry MK in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-MaxLen" testNumber="8"/>
			<description>Entry MaxLen in AnnotWidgetFieldTx shall have type Integer</description>
			<test>containsMaxLen == false || MaxLenHasTypeInteger == true</test>
			<error>
				<message>Entry MaxLen in AnnotWidgetFieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>MaxLenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-MaxLen-Integer" testNumber="9"/>
			<description>Entry MaxLen with type Integer in AnnotWidgetFieldTx shall satisfy special case: fn:Eval(@MaxLen &gt;= 0)</description>
			<test>MaxLenHasTypeInteger != true || (MaxLenIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry MaxLen with type Integer in AnnotWidgetFieldTx does not satisfy special case: fn:Eval(@MaxLen &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-NM" testNumber="8"/>
			<description>Entry NM in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsNM == false || NMHasTypeStringText == true</test>
			<error>
				<message>Entry NM in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>NMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-P" testNumber="8"/>
			<description>Entry P in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in AnnotWidgetFieldTx shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in AnnotWidgetFieldTx is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in AnnotWidgetFieldTx shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in AnnotWidgetFieldTx is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Parent" testNumber="8"/>
			<description>Entry Parent in AnnotWidgetFieldTx shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in AnnotWidgetFieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Q" testNumber="8"/>
			<description>Entry Q in AnnotWidgetFieldTx shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in AnnotWidgetFieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in AnnotWidgetFieldTx shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in AnnotWidgetFieldTx has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Rect" testNumber="8"/>
			<description>Entry Rect in AnnotWidgetFieldTx shall have type Rectangle</description>
			<test>containsRect == false || RectHasTypeRectangle == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldTx has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Rect" testNumber="7"/>
			<description>Entry Rect in AnnotWidgetFieldTx is required</description>
			<test>containsRect == true</test>
			<error>
				<message>Entry Rect in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-StructParent" testNumber="8"/>
			<description>Entry StructParent in AnnotWidgetFieldTx shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in AnnotWidgetFieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Subtype" testNumber="8"/>
			<description>Entry Subtype in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Subtype" testNumber="7"/>
			<description>Entry Subtype in AnnotWidgetFieldTx is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in AnnotWidgetFieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in AnnotWidgetFieldTx shall have value Widget</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Widget"</test>
			<error>
				<message>Entry Subtype with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Widget</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-T" testNumber="8"/>
			<description>Entry T in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-TM" testNumber="8"/>
			<description>Entry TM in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-TU" testNumber="8"/>
			<description>Entry TU in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Type" testNumber="8"/>
			<description>Entry Type in AnnotWidgetFieldTx shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in AnnotWidgetFieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in AnnotWidgetFieldTx shall have value Annot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Annot"</test>
			<error>
				<message>Entry Type with type Name in AnnotWidgetFieldTx has incorrect value %1 instead of Annot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAnnotWidgetFieldTx">
			<id specification="PDF_1_4" clause="AnnotWidgetFieldTx-V" testNumber="8"/>
			<description>Entry V in AnnotWidgetFieldTx shall have type StringText</description>
			<test>containsV == false || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in AnnotWidgetFieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance" testNumber="1"/>
			<description>Appearance shall not contain entries except D, N, R</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Appearance contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-D-Stream" testNumber="17"/>
			<description>Entry D with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>DHasTypeStream != true || D_size == 1</test>
			<error>
				<message>Entry D with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-D" testNumber="8"/>
			<description>Entry D in Appearance shall have one of types: Dictionary, Stream</description>
			<test>containsD == false || DHasTypeDictionary == true || DHasTypeStream == true</test>
			<error>
				<message>Entry D in Appearance has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-D-Stream" testNumber="10"/>
			<description>Entry D with type Stream in Appearance shall be indirect</description>
			<test>DHasTypeStream != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-N-Stream" testNumber="17"/>
			<description>Entry N with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>NHasTypeStream != true || N_size == 1</test>
			<error>
				<message>Entry N with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-N" testNumber="8"/>
			<description>Entry N in Appearance shall have one of types: Dictionary, Stream</description>
			<test>containsN == false || NHasTypeDictionary == true || NHasTypeStream == true</test>
			<error>
				<message>Entry N in Appearance has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-N" testNumber="7"/>
			<description>Entry N in Appearance is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in Appearance is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-N-Stream" testNumber="10"/>
			<description>Entry N with type Stream in Appearance shall be indirect</description>
			<test>NHasTypeStream != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-R-Stream" testNumber="17"/>
			<description>Entry R with type Stream in Appearance shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>RHasTypeStream != true || R_size == 1</test>
			<error>
				<message>Entry R with type Stream in Appearance is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-R" testNumber="8"/>
			<description>Entry R in Appearance shall have one of types: Dictionary, Stream</description>
			<test>containsR == false || RHasTypeDictionary == true || RHasTypeStream == true</test>
			<error>
				<message>Entry R in Appearance has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearance">
			<id specification="PDF_1_4" clause="Appearance-R-Stream" testNumber="10"/>
			<description>Entry R with type Stream in Appearance shall be indirect</description>
			<test>RHasTypeStream != true || isRIndirect == true</test>
			<error>
				<message>Entry R with type Stream in Appearance is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics" testNumber="1"/>
			<description>AppearanceCharacteristics shall not contain entries except AC, BC, BG, CA, I, IF, IX, R, RC, RI, TP</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AC' &amp;&amp; elem != 'BC' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'I' &amp;&amp; elem != 'IF' &amp;&amp; elem != 'IX' &amp;&amp; elem != 'R' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'TP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AppearanceCharacteristics contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AC' &amp;&amp; elem != 'BC' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'I' &amp;&amp; elem != 'IF' &amp;&amp; elem != 'IX' &amp;&amp; elem != 'R' &amp;&amp; elem != 'RC' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'TP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-AC" testNumber="8"/>
			<description>Entry AC in AppearanceCharacteristics shall have type StringText</description>
			<test>containsAC == false || ACHasTypeStringText == true</test>
			<error>
				<message>Entry AC in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>ACType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-BC" testNumber="8"/>
			<description>Entry BC in AppearanceCharacteristics shall have type Array</description>
			<test>containsBC == false || BCHasTypeArray == true</test>
			<error>
				<message>Entry BC in AppearanceCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>BCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-BG" testNumber="8"/>
			<description>Entry BG in AppearanceCharacteristics shall have type Array</description>
			<test>containsBG == false || BGHasTypeArray == true</test>
			<error>
				<message>Entry BG in AppearanceCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>BGType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-CA" testNumber="8"/>
			<description>Entry CA in AppearanceCharacteristics shall have type StringText</description>
			<test>containsCA == false || CAHasTypeStringText == true</test>
			<error>
				<message>Entry CA in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-I-Stream" testNumber="17"/>
			<description>Entry I with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>IHasTypeStream != true || I_size == 1</test>
			<error>
				<message>Entry I with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-I" testNumber="8"/>
			<description>Entry I in AppearanceCharacteristics shall have type Stream</description>
			<test>containsI == false || IHasTypeStream == true</test>
			<error>
				<message>Entry I in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-I-Stream" testNumber="10"/>
			<description>Entry I with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>IHasTypeStream != true || isIIndirect == true</test>
			<error>
				<message>Entry I with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-IF" testNumber="8"/>
			<description>Entry IF in AppearanceCharacteristics shall have type Dictionary</description>
			<test>containsIF == false || IFHasTypeDictionary == true</test>
			<error>
				<message>Entry IF in AppearanceCharacteristics has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>IFType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-IX-Stream" testNumber="17"/>
			<description>Entry IX with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>IXHasTypeStream != true || IX_size == 1</test>
			<error>
				<message>Entry IX with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-IX" testNumber="8"/>
			<description>Entry IX in AppearanceCharacteristics shall have type Stream</description>
			<test>containsIX == false || IXHasTypeStream == true</test>
			<error>
				<message>Entry IX in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>IXType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-IX-Stream" testNumber="10"/>
			<description>Entry IX with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>IXHasTypeStream != true || isIXIndirect == true</test>
			<error>
				<message>Entry IX with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-R" testNumber="8"/>
			<description>Entry R in AppearanceCharacteristics shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in AppearanceCharacteristics has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-RC" testNumber="8"/>
			<description>Entry RC in AppearanceCharacteristics shall have type StringText</description>
			<test>containsRC == false || RCHasTypeStringText == true</test>
			<error>
				<message>Entry RC in AppearanceCharacteristics has type %1 instead of type StringText</message>
				<arguments>
					<argument>RCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-RI-Stream" testNumber="17"/>
			<description>Entry RI with type Stream in AppearanceCharacteristics shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>RIHasTypeStream != true || RI_size == 1</test>
			<error>
				<message>Entry RI with type Stream in AppearanceCharacteristics is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-RI" testNumber="8"/>
			<description>Entry RI in AppearanceCharacteristics shall have type Stream</description>
			<test>containsRI == false || RIHasTypeStream == true</test>
			<error>
				<message>Entry RI in AppearanceCharacteristics has type %1 instead of type Stream</message>
				<arguments>
					<argument>RIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-RI-Stream" testNumber="10"/>
			<description>Entry RI with type Stream in AppearanceCharacteristics shall be indirect</description>
			<test>RIHasTypeStream != true || isRIIndirect == true</test>
			<error>
				<message>Entry RI with type Stream in AppearanceCharacteristics is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-TP" testNumber="8"/>
			<description>Entry TP in AppearanceCharacteristics shall have type Integer</description>
			<test>containsTP == false || TPHasTypeInteger == true</test>
			<error>
				<message>Entry TP in AppearanceCharacteristics has type %1 instead of type Integer</message>
				<arguments>
					<argument>TPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceCharacteristics">
			<id specification="PDF_1_4" clause="AppearanceCharacteristics-TP-Integer" testNumber="6"/>
			<description>Entry TP with type Integer in AppearanceCharacteristics shall have one of values: 0, 1, 2, 3, 4, 5, 6</description>
			<test>TPHasTypeInteger != true || TPIntegerValue == 0 || TPIntegerValue == 1 || TPIntegerValue == 2 || TPIntegerValue == 3 || TPIntegerValue == 4 || TPIntegerValue == 5 || TPIntegerValue == 6</test>
			<error>
				<message>Entry TP with type Integer in AppearanceCharacteristics has incorrect value %1 instead of 0, 1, 2, 3, 4, 5, 6</message>
				<arguments>
					<argument>TPIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark" testNumber="1"/>
			<description>AppearancePrinterMark shall not contain entries except D, N, R</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AppearancePrinterMark contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-D" testNumber="8"/>
			<description>Entry D in AppearancePrinterMark shall have one of types: Dictionary, Stream</description>
			<test>containsD == false || DHasTypeDictionary == true || DHasTypeStream == true</test>
			<error>
				<message>Entry D in AppearancePrinterMark has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-D-Stream" testNumber="10"/>
			<description>Entry D with type Stream in AppearancePrinterMark shall be indirect</description>
			<test>DHasTypeStream != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Stream in AppearancePrinterMark is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-N" testNumber="8"/>
			<description>Entry N in AppearancePrinterMark shall have one of types: Dictionary, Stream</description>
			<test>containsN == false || NHasTypeDictionary == true || NHasTypeStream == true</test>
			<error>
				<message>Entry N in AppearancePrinterMark has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-N" testNumber="7"/>
			<description>Entry N in AppearancePrinterMark is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in AppearancePrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-N-Stream" testNumber="10"/>
			<description>Entry N with type Stream in AppearancePrinterMark shall be indirect</description>
			<test>NHasTypeStream != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Stream in AppearancePrinterMark is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-R" testNumber="8"/>
			<description>Entry R in AppearancePrinterMark shall have one of types: Dictionary, Stream</description>
			<test>containsR == false || RHasTypeDictionary == true || RHasTypeStream == true</test>
			<error>
				<message>Entry R in AppearancePrinterMark has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMark">
			<id specification="PDF_1_4" clause="AppearancePrinterMark-R-Stream" testNumber="10"/>
			<description>Entry R with type Stream in AppearancePrinterMark shall be indirect</description>
			<test>RHasTypeStream != true || isRIndirect == true</test>
			<error>
				<message>Entry R with type Stream in AppearancePrinterMark is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMarkSubDictEntry">
			<id specification="PDF_1_4" clause="AppearancePrinterMarkSubDictEntry" testNumber="8"/>
			<description>Entry in AppearancePrinterMarkSubDict shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in AppearancePrinterMarkSubDict has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearancePrinterMarkSubDictEntry">
			<id specification="PDF_1_4" clause="AppearancePrinterMarkSubDictEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in AppearancePrinterMarkSubDict shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in AppearancePrinterMarkSubDict is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceSubDictEntry">
			<id specification="PDF_1_4" clause="AppearanceSubDictEntry" testNumber="8"/>
			<description>Entry in AppearanceSubDict shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in AppearanceSubDict has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceSubDictEntry">
			<id specification="PDF_1_4" clause="AppearanceSubDictEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in AppearanceSubDict shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in AppearanceSubDict is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet" testNumber="1"/>
			<description>AppearanceTrapNet shall not contain entries except D, N, R</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>AppearanceTrapNet contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'N' &amp;&amp; elem != 'R' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-D" testNumber="8"/>
			<description>Entry D in AppearanceTrapNet shall have one of types: Dictionary, Stream</description>
			<test>containsD == false || DHasTypeDictionary == true || DHasTypeStream == true</test>
			<error>
				<message>Entry D in AppearanceTrapNet has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-D-Stream" testNumber="10"/>
			<description>Entry D with type Stream in AppearanceTrapNet shall be indirect</description>
			<test>DHasTypeStream != true || isDIndirect == true</test>
			<error>
				<message>Entry D with type Stream in AppearanceTrapNet is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-N" testNumber="8"/>
			<description>Entry N in AppearanceTrapNet shall have one of types: Dictionary, Stream</description>
			<test>containsN == false || NHasTypeDictionary == true || NHasTypeStream == true</test>
			<error>
				<message>Entry N in AppearanceTrapNet has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-N" testNumber="7"/>
			<description>Entry N in AppearanceTrapNet is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in AppearanceTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-N-Stream" testNumber="10"/>
			<description>Entry N with type Stream in AppearanceTrapNet shall be indirect</description>
			<test>NHasTypeStream != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Stream in AppearanceTrapNet is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-R" testNumber="8"/>
			<description>Entry R in AppearanceTrapNet shall have one of types: Dictionary, Stream</description>
			<test>containsR == false || RHasTypeDictionary == true || RHasTypeStream == true</test>
			<error>
				<message>Entry R in AppearanceTrapNet has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNet">
			<id specification="PDF_1_4" clause="AppearanceTrapNet-R-Stream" testNumber="10"/>
			<description>Entry R with type Stream in AppearanceTrapNet shall be indirect</description>
			<test>RHasTypeStream != true || isRIndirect == true</test>
			<error>
				<message>Entry R with type Stream in AppearanceTrapNet is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNetSubDictEntry">
			<id specification="PDF_1_4" clause="AppearanceTrapNetSubDictEntry" testNumber="8"/>
			<description>Entry in AppearanceTrapNetSubDict shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in AppearanceTrapNetSubDict has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AAppearanceTrapNetSubDictEntry">
			<id specification="PDF_1_4" clause="AppearanceTrapNetSubDictEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in AppearanceTrapNetSubDict shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in AppearanceTrapNetSubDict is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions" testNumber="2"/>
			<description>ArrayOf4Functions shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf4Functions contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-0-Dictionary" testNumber="17"/>
			<description>Entry 0 with type Dictionary in ArrayOf4Functions shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry0HasTypeDictionary != true || entry0_size == 1</test>
			<error>
				<message>Entry 0 with type Dictionary in ArrayOf4Functions is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-0-Stream" testNumber="17"/>
			<description>Entry 0 with type Stream in ArrayOf4Functions shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry0HasTypeStream != true || entry0_size == 1</test>
			<error>
				<message>Entry 0 with type Stream in ArrayOf4Functions is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf4Functions shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeStream == true</test>
			<error>
				<message>Entry 0 in ArrayOf4Functions has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-0-Stream" testNumber="10"/>
			<description>Entry 0 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry0HasTypeStream != true || isentry0Indirect == true</test>
			<error>
				<message>Entry 0 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-1-Dictionary" testNumber="17"/>
			<description>Entry 1 with type Dictionary in ArrayOf4Functions shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry1HasTypeDictionary != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Dictionary in ArrayOf4Functions is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-1-Stream" testNumber="17"/>
			<description>Entry 1 with type Stream in ArrayOf4Functions shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry1HasTypeStream != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Stream in ArrayOf4Functions is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf4Functions shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true || entry1HasTypeStream == true</test>
			<error>
				<message>Entry 1 in ArrayOf4Functions has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-1-Stream" testNumber="10"/>
			<description>Entry 1 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry1HasTypeStream != true || isentry1Indirect == true</test>
			<error>
				<message>Entry 1 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-2-Dictionary" testNumber="17"/>
			<description>Entry 2 with type Dictionary in ArrayOf4Functions shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry2HasTypeDictionary != true || entry2_size == 1</test>
			<error>
				<message>Entry 2 with type Dictionary in ArrayOf4Functions is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-2-Stream" testNumber="17"/>
			<description>Entry 2 with type Stream in ArrayOf4Functions shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry2HasTypeStream != true || entry2_size == 1</test>
			<error>
				<message>Entry 2 with type Stream in ArrayOf4Functions is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf4Functions shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 2 || entry2HasTypeDictionary == true || entry2HasTypeStream == true</test>
			<error>
				<message>Entry 2 in ArrayOf4Functions has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-2-Stream" testNumber="10"/>
			<description>Entry 2 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry2HasTypeStream != true || isentry2Indirect == true</test>
			<error>
				<message>Entry 2 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-3-Dictionary" testNumber="17"/>
			<description>Entry 3 with type Dictionary in ArrayOf4Functions shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry3HasTypeDictionary != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Dictionary in ArrayOf4Functions is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-3-Stream" testNumber="17"/>
			<description>Entry 3 with type Stream in ArrayOf4Functions shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry3HasTypeStream != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Stream in ArrayOf4Functions is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf4Functions shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 3 || entry3HasTypeDictionary == true || entry3HasTypeStream == true</test>
			<error>
				<message>Entry 3 in ArrayOf4Functions has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf4Functions">
			<id specification="PDF_1_4" clause="ArrayOf4Functions-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in ArrayOf4Functions shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in ArrayOf4Functions is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionHideAnnotsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfActionHideAnnots shall be one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActionHideAnnots is not one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionHideAnnotsEntry" testNumber="8"/>
			<description>Entry in ArrayOfActionHideAnnots shall have one of types: Dictionary, StringText</description>
			<test>HasTypeDictionary == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfActionHideAnnots has type %1 instead of one of types: Dictionary, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionHideAnnotsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfActionHideAnnots shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActionHideAnnots is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionHideAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionHideAnnotsEntry-StringText" testNumber="9"/>
			<description>Entry with type StringText in ArrayOfActionHideAnnots shall satisfy special case: fn:Eval(fn:IsFieldName(@*))</description>
			<test>HasTypeStringText != true || (IsFieldName == true)</test>
			<error>
				<message>Entry %keyName% with type StringText in ArrayOfActionHideAnnots does not satisfy special case: fn:Eval(fn:IsFieldName(@*))</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfActions shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfActions is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfActionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfActionsEntry" testNumber="8"/>
			<description>Entry in ArrayOfActions shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfActions has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAnnotStatesEntry">
			<id specification="PDF_1_4" clause="ArrayOfAnnotStatesEntry" testNumber="8"/>
			<description>Entry in ArrayOfAnnotStates shall have one of types: Name, Null</description>
			<test>HasTypeName == true || HasTypeNull == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfAnnotStates has type %1 instead of one of types: Name, Null</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfAnnotsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfAnnots shall be one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfAnnots is not one of objects AnnotText, AnnotLink, AnnotFreeText, AnnotLine, AnnotSquare, AnnotCircle, AnnotHighlight, AnnotUnderline, AnnotSquiggly, AnnotStrikeOut, AnnotStamp, AnnotInk, AnnotPopup, AnnotFileAttachment, AnnotSound, AnnotMovie, AnnotWidget, AnnotPrinterMark, AnnotTrapNetwork, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAnnotsEntry">
			<id specification="PDF_1_4" clause="ArrayOfAnnotsEntry" testNumber="8"/>
			<description>Entry in ArrayOfAnnots shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfAnnots has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfArraysInkListEntry">
			<id specification="PDF_1_4" clause="ArrayOfArraysInkListEntry" testNumber="8"/>
			<description>Entry in ArrayOfArraysInkList shall have type Array</description>
			<test>HasTypeArray == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfArraysInkList has type %1 instead of type Array</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfArraysURLStringsEntry">
			<id specification="PDF_1_4" clause="ArrayOfArraysURLStringsEntry" testNumber="8"/>
			<description>Entry in ArrayOfArraysURLStrings shall have type Array</description>
			<test>HasTypeArray == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfArraysURLStrings has type %1 instead of type Array</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfAttributeObjectsEntry" testNumber="8"/>
			<description>Entry in ArrayOfAttributeObjects shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfAttributeObjects has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfAttributeRevisionsSubArray" testNumber="24"/>
			<description>ArrayOfAttributeRevisionsSubArray shall contain 1 to 2 elements</description>
			<test>size &gt;= 1 &amp;&amp; size &lt;= 2</test>
			<error>
				<message>ArrayOfAttributeRevisionsSubArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfAttributeRevisionsSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfAttributeRevisionsSubArray shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeStream == true</test>
			<error>
				<message>Entry 0 in ArrayOfAttributeRevisionsSubArray has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfAttributeRevisionsSubArray-0-Stream" testNumber="10"/>
			<description>Entry 0 with type Stream in ArrayOfAttributeRevisionsSubArray shall be indirect</description>
			<test>entry0HasTypeStream != true || isentry0Indirect == true</test>
			<error>
				<message>Entry 0 with type Stream in ArrayOfAttributeRevisionsSubArray is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfAttributeRevisionsSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfAttributeRevisionsSubArray shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOfAttributeRevisionsSubArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfAttributeRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfAttributeRevisionsSubArray-1-Integer" testNumber="14"/>
			<description>Entry 1 with type Integer in ArrayOfAttributeRevisionsSubArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeInteger != true || entry1IntegerValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Integer in ArrayOfAttributeRevisionsSubArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_4" clause="ArrayOfBeadsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfBeads shall be one of objects BeadFirst, Bead</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfBeads is not one of objects BeadFirst, Bead</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_4" clause="ArrayOfBeadsEntry" testNumber="8"/>
			<description>Entry in ArrayOfBeads shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfBeads has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBeadsEntry">
			<id specification="PDF_1_4" clause="ArrayOfBeadsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfBeads shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfBeads is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBlendModesEntry">
			<id specification="PDF_1_4" clause="ArrayOfBlendModesEntry" testNumber="8"/>
			<description>Entry in ArrayOfBlendModes shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfBlendModes has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBlendModesEntry">
			<id specification="PDF_1_4" clause="ArrayOfBlendModesEntry-Name" testNumber="19"/>
			<description>Entry with type Name in ArrayOfBlendModes should not have deprecated value Compatible</description>
			<test>NameValue != "Compatible"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfBlendModes has deprecated value Compatible</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfBlendModesEntry">
			<id specification="PDF_1_4" clause="ArrayOfBlendModesEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfBlendModes shall have one of values: Screen, ColorDodge, Saturation, Color, Luminosity, Darken, Difference, Compatible, Normal, SoftLight, ColorBurn, Multiply, Exclusion, HardLight, Hue, Overlay, Lighten</description>
			<test>HasTypeName != true || NameValue == "Compatible" || NameValue == "Normal" || NameValue == "Multiply" || NameValue == "Screen" || NameValue == "Difference" || NameValue == "Darken" || NameValue == "Lighten" || NameValue == "ColorDodge" || NameValue == "ColorBurn" || NameValue == "Exclusion" || NameValue == "HardLight" || NameValue == "Overlay" || NameValue == "SoftLight" || NameValue == "Luminosity" || NameValue == "Hue" || NameValue == "Saturation" || NameValue == "Color"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfBlendModes has incorrect value %1 instead of Screen, ColorDodge, Saturation, Color, Luminosity, Darken, Difference, Compatible, Normal, SoftLight, ColorBurn, Multiply, Exclusion, HardLight, Hue, Overlay, Lighten</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsW2Entry">
			<id specification="PDF_1_4" clause="ArrayOfCIDGlyphMetricsW2Entry" testNumber="8"/>
			<description>Entry in ArrayOfCIDGlyphMetricsW2 shall have one of types: Array, Integer, Number</description>
			<test>HasTypeArray == true || HasTypeInteger == true || HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCIDGlyphMetricsW2 has type %1 instead of one of types: Array, Integer, Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsW2Entry">
			<id specification="PDF_1_4" clause="ArrayOfCIDGlyphMetricsW2Entry-Array" testNumber="9"/>
			<description>Entry with type Array in ArrayOfCIDGlyphMetricsW2 shall satisfy special case: fn:Eval((fn:ArrayLength(*) mod 3) == 0)</description>
			<test>HasTypeArray != true || ((ArraySize % 3) == 0)</test>
			<error>
				<message>Entry %keyName% with type Array in ArrayOfCIDGlyphMetricsW2 does not satisfy special case: fn:Eval((fn:ArrayLength(*) mod 3) == 0)</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCIDGlyphMetricsWEntry">
			<id specification="PDF_1_4" clause="ArrayOfCIDGlyphMetricsWEntry" testNumber="8"/>
			<description>Entry in ArrayOfCIDGlyphMetricsW shall have one of types: Array, Integer, Number</description>
			<test>HasTypeArray == true || HasTypeInteger == true || HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCIDGlyphMetricsW has type %1 instead of one of types: Array, Integer, Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfClassNamesRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfClassNamesRevisionsSubArray" testNumber="24"/>
			<description>ArrayOfClassNamesRevisionsSubArray shall contain 1 to 2 elements</description>
			<test>size &gt;= 1 &amp;&amp; size &lt;= 2</test>
			<error>
				<message>ArrayOfClassNamesRevisionsSubArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfClassNamesRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfClassNamesRevisionsSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfClassNamesRevisionsSubArray shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in ArrayOfClassNamesRevisionsSubArray has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfClassNamesRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfClassNamesRevisionsSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfClassNamesRevisionsSubArray shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOfClassNamesRevisionsSubArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfClassNamesRevisionsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfClassNamesRevisionsSubArray-1-Integer" testNumber="14"/>
			<description>Entry 1 with type Integer in ArrayOfClassNamesRevisionsSubArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeInteger != true || entry1IntegerValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Integer in ArrayOfClassNamesRevisionsSubArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCompressionFilterNamesEntry">
			<id specification="PDF_1_4" clause="ArrayOfCompressionFilterNamesEntry" testNumber="8"/>
			<description>Entry in ArrayOfCompressionFilterNames shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfCompressionFilterNames has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfCompressionFilterNamesEntry">
			<id specification="PDF_1_4" clause="ArrayOfCompressionFilterNamesEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfCompressionFilterNames shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>HasTypeName != true || NameValue == "ASCIIHexDecode" || NameValue == "ASCII85Decode" || NameValue == "LZWDecode" || NameValue == "FlateDecode" || NameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfCompressionFilterNames has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDashPatternsEntry">
			<id specification="PDF_1_4" clause="ArrayOfDashPatternsEntry" testNumber="8"/>
			<description>Entry in ArrayOfDashPatterns shall have type Number</description>
			<test>HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDashPatterns has type %1 instead of type Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDecodeParamsEntry">
			<id specification="PDF_1_4" clause="ArrayOfDecodeParamsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfDecodeParams shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfDecodeParams is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDecodeParamsEntry">
			<id specification="PDF_1_4" clause="ArrayOfDecodeParamsEntry" testNumber="8"/>
			<description>Entry in ArrayOfDecodeParams shall have one of types: Dictionary, Null</description>
			<test>HasTypeDictionary == true || HasTypeNull == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDecodeParams has type %1 instead of one of types: Dictionary, Null</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_4" clause="ArrayOfDescendantFonts" testNumber="2"/>
			<description>ArrayOfDescendantFonts shall contain exactly 1 element</description>
			<test>size == 1</test>
			<error>
				<message>ArrayOfDescendantFonts contains %1 element(s) instead of 1</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_4" clause="ArrayOfDescendantFonts-0-Dictionary" testNumber="17"/>
			<description>Entry 0 with type Dictionary in ArrayOfDescendantFonts shall be one of objects FontCIDType0, FontCIDType2</description>
			<test>entry0HasTypeDictionary != true || entry0_size == 1</test>
			<error>
				<message>Entry 0 with type Dictionary in ArrayOfDescendantFonts is not one of objects FontCIDType0, FontCIDType2</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDescendantFonts">
			<id specification="PDF_1_4" clause="ArrayOfDescendantFonts-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfDescendantFonts shall have type Dictionary</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true</test>
			<error>
				<message>Entry 0 in ArrayOfDescendantFonts has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDifferencesEntry">
			<id specification="PDF_1_4" clause="ArrayOfDifferencesEntry" testNumber="8"/>
			<description>Entry in ArrayOfDifferences shall have one of types: Integer, Name</description>
			<test>HasTypeInteger == true || HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfDifferences has type %1 instead of one of types: Integer, Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration" testNumber="2"/>
			<description>ArrayOfDuration shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfDuration contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfDuration shall have one of types: Integer, StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in ArrayOfDuration has type %1 instead of one of types: Integer, StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration-0-Integer" testNumber="14"/>
			<description>Entry 0 with type Integer in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(@0 &gt; 0)</description>
			<test>entry0HasTypeInteger != true || entry0IntegerValue &gt; 0</test>
			<error>
				<message>Entry 0 with type Integer in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(@0 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration-0-StringByte" testNumber="14"/>
			<description>Entry 0 with type StringByte in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(fn:StringLength(0) == 8)</description>
			<test>entry0HasTypeStringByte != true || entry0StringSize == 8</test>
			<error>
				<message>Entry 0 with type StringByte in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(fn:StringLength(0) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfDuration shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOfDuration has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfDuration">
			<id specification="PDF_1_4" clause="ArrayOfDuration-1-Integer" testNumber="14"/>
			<description>Entry 1 with type Integer in ArrayOfDuration shall satisfy possible value predicate: fn:Eval(@1 &gt; 0)</description>
			<test>entry1HasTypeInteger != true || entry1IntegerValue &gt; 0</test>
			<error>
				<message>Entry 1 with type Integer in ArrayOfDuration does not satisfy possible value predicate: fn:Eval(@1 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldChoiceOptEntry">
			<id specification="PDF_1_4" clause="ArrayOfFieldChoiceOptEntry" testNumber="8"/>
			<description>Entry in ArrayOfFieldChoiceOpt shall have one of types: Array, StringText</description>
			<test>HasTypeArray == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFieldChoiceOpt has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldIDEntry">
			<id specification="PDF_1_4" clause="ArrayOfFieldIDEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFieldID shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFieldID is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldIDEntry">
			<id specification="PDF_1_4" clause="ArrayOfFieldIDEntry" testNumber="8"/>
			<description>Entry in ArrayOfFieldID shall have one of types: Dictionary, StringText</description>
			<test>HasTypeDictionary == true || HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFieldID has type %1 instead of one of types: Dictionary, StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFieldsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFields shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidget, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFields is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidget, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField, AnnotWidgetFieldSig, AnnotWidgetFieldChoice, AnnotWidgetField, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldTx, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnPush</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFieldsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFieldsEntry" testNumber="8"/>
			<description>Entry in ArrayOfFields shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFields has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFilterNamesEntry">
			<id specification="PDF_1_4" clause="ArrayOfFilterNamesEntry" testNumber="8"/>
			<description>Entry in ArrayOfFilterNames shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFilterNames has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFilterNamesEntry">
			<id specification="PDF_1_4" clause="ArrayOfFilterNamesEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfFilterNames shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>HasTypeName != true || NameValue == "ASCIIHexDecode" || NameValue == "ASCII85Decode" || NameValue == "LZWDecode" || NameValue == "FlateDecode" || NameValue == "RunLengthDecode" || NameValue == "CCITTFaxDecode" || NameValue == "JBIG2Decode" || NameValue == "DCTDecode"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfFilterNames has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontAndSize">
			<id specification="PDF_1_4" clause="ArrayOfFontAndSize" testNumber="2"/>
			<description>ArrayOfFontAndSize shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfFontAndSize contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontAndSize">
			<id specification="PDF_1_4" clause="ArrayOfFontAndSize-0-Dictionary" testNumber="17"/>
			<description>Entry 0 with type Dictionary in ArrayOfFontAndSize shall be one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</description>
			<test>entry0HasTypeDictionary != true || entry0_size == 1</test>
			<error>
				<message>Entry 0 with type Dictionary in ArrayOfFontAndSize is not one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontAndSize">
			<id specification="PDF_1_4" clause="ArrayOfFontAndSize-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfFontAndSize shall have type Dictionary</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true</test>
			<error>
				<message>Entry 0 in ArrayOfFontAndSize has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontAndSize">
			<id specification="PDF_1_4" clause="ArrayOfFontAndSize-0-Dictionary" testNumber="10"/>
			<description>Entry 0 with type Dictionary in ArrayOfFontAndSize shall be indirect</description>
			<test>entry0HasTypeDictionary != true || isentry0Indirect == true</test>
			<error>
				<message>Entry 0 with type Dictionary in ArrayOfFontAndSize is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontAndSize">
			<id specification="PDF_1_4" clause="ArrayOfFontAndSize-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfFontAndSize shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfFontAndSize has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFontsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFonts shall be one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFonts is not one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFontsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFontsEntry" testNumber="8"/>
			<description>Entry in ArrayOfFonts shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFonts has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFunctionsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfFunctions shall be one of objects FunctionType2, FunctionType3</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfFunctions is not one of objects FunctionType2, FunctionType3</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFunctionsEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in ArrayOfFunctions shall be one of objects FunctionType0, FunctionType4</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfFunctions is not one of objects FunctionType0, FunctionType4</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFunctionsEntry" testNumber="8"/>
			<description>Entry in ArrayOfFunctions shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfFunctions has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfFunctionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfFunctionsEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfFunctions shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfFunctions is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfGSPDashPatterns">
			<id specification="PDF_1_4" clause="ArrayOfGSPDashPatterns" testNumber="2"/>
			<description>ArrayOfGSPDashPatterns shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfGSPDashPatterns contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfGSPDashPatterns">
			<id specification="PDF_1_4" clause="ArrayOfGSPDashPatterns-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfGSPDashPatterns shall have type Array</description>
			<test>size &lt;= 0 || entry0HasTypeArray == true</test>
			<error>
				<message>Entry 0 in ArrayOfGSPDashPatterns has type %1 instead of type Array</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfGSPDashPatterns">
			<id specification="PDF_1_4" clause="ArrayOfGSPDashPatterns-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfGSPDashPatterns shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfGSPDashPatterns has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfImageAlternatesEntry">
			<id specification="PDF_1_4" clause="ArrayOfImageAlternatesEntry" testNumber="8"/>
			<description>Entry in ArrayOfImageAlternates shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfImageAlternates has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfIntegersGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfIntegersGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfIntegersGeneral shall have type Integer</description>
			<test>HasTypeInteger == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfIntegersGeneral has type %1 instead of type Integer</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNamesForProcSetEntry">
			<id specification="PDF_1_4" clause="ArrayOfNamesForProcSetEntry" testNumber="8"/>
			<description>Entry in ArrayOfNamesForProcSet shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNamesForProcSet has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNamesForProcSetEntry">
			<id specification="PDF_1_4" clause="ArrayOfNamesForProcSetEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ArrayOfNamesForProcSet shall have one of values: ImageI, PDF, ImageC, ImageB, Text</description>
			<test>HasTypeName != true || NameValue == "PDF" || NameValue == "Text" || NameValue == "ImageB" || NameValue == "ImageC" || NameValue == "ImageI"</test>
			<error>
				<message>Entry %keyName% with type Name in ArrayOfNamesForProcSet has incorrect value %1 instead of ImageI, PDF, ImageC, ImageB, Text</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNamesGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfNamesGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfNamesGeneral shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNamesGeneral has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNonNegativeIntegersGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfNonNegativeIntegersGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfNonNegativeIntegersGeneral shall have type Integer</description>
			<test>HasTypeInteger == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNonNegativeIntegersGeneral has type %1 instead of type Integer</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNonNegativeIntegersGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfNonNegativeIntegersGeneralEntry-Integer" testNumber="9"/>
			<description>Entry with type Integer in ArrayOfNonNegativeIntegersGeneral shall satisfy special case: fn:Eval(@* &gt;= 0)</description>
			<test>HasTypeInteger != true || (IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry %keyName% with type Integer in ArrayOfNonNegativeIntegersGeneral does not satisfy special case: fn:Eval(@* &gt;= 0)</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfNumbersGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfNumbersGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfNumbersGeneral shall have type Number</description>
			<test>HasTypeNumber == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfNumbersGeneral has type %1 instead of type Number</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color" testNumber="2"/>
			<description>ArrayOfOPI13Color shall contain exactly 5 elements</description>
			<test>size == 5</test>
			<error>
				<message>ArrayOfOPI13Color contains %1 element(s) instead of 5</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</description>
			<test>entry0HasTypeNumber != true || (entry0NumberValue &gt;= 0) &amp;&amp; (entry0NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 0 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-2" testNumber="8"/>
			<description>Entry 2 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</description>
			<test>entry2HasTypeNumber != true || (entry2NumberValue &gt;= 0) &amp;&amp; (entry2NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 2 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-3" testNumber="8"/>
			<description>Entry 3 in ArrayOfOPI13Color shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOfOPI13Color has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in ArrayOfOPI13Color shall satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</description>
			<test>entry3HasTypeNumber != true || (entry3NumberValue &gt;= 0) &amp;&amp; (entry3NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 3 with type Number in ArrayOfOPI13Color does not satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI13Color">
			<id specification="PDF_1_4" clause="ArrayOfOPI13Color-4" testNumber="8"/>
			<description>Entry 4 in ArrayOfOPI13Color shall have type StringByte</description>
			<test>size &lt;= 4 || entry4HasTypeStringByte == true</test>
			<error>
				<message>Entry 4 in ArrayOfOPI13Color has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_4" clause="ArrayOfOPI2Inks" testNumber="3"/>
			<description>ArrayOfOPI2Inks shall contain 2 * n + 1 elements</description>
			<test>size % 2 == 1</test>
			<error>
				<message>ArrayOfOPI2Inks contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_4" clause="ArrayOfOPI2Inks-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI2Inks shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI2Inks has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2Inks">
			<id specification="PDF_1_4" clause="ArrayOfOPI2Inks-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in ArrayOfOPI2Inks shall have value monochrome</description>
			<test>entry0HasTypeName != true || entry0NameValue == "monochrome"</test>
			<error>
				<message>Entry 0 with type Name in ArrayOfOPI2Inks has incorrect value %1 instead of monochrome</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_4" clause="ArrayOfOPI2InksSubArray" testNumber="2"/>
			<description>ArrayOfOPI2InksSubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfOPI2InksSubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_4" clause="ArrayOfOPI2InksSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfOPI2InksSubArray shall have type String</description>
			<test>size &lt;= 0 || entry0HasTypeString == true</test>
			<error>
				<message>Entry 0 in ArrayOfOPI2InksSubArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_4" clause="ArrayOfOPI2InksSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfOPI2InksSubArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfOPI2InksSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOPI2InksSubArray">
			<id specification="PDF_1_4" clause="ArrayOfOPI2InksSubArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOfOPI2InksSubArray shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOfOPI2InksSubArray does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfOutputIntentsEntry">
			<id specification="PDF_1_4" clause="ArrayOfOutputIntentsEntry" testNumber="8"/>
			<description>Entry in ArrayOfOutputIntents shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfOutputIntents has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_4" clause="ArrayOfPageTreeNodeKidsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfPageTreeNodeKids shall be one of objects PageTreeNode, PageObject</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPageTreeNodeKids is not one of objects PageTreeNode, PageObject</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_4" clause="ArrayOfPageTreeNodeKidsEntry" testNumber="8"/>
			<description>Entry in ArrayOfPageTreeNodeKids shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfPageTreeNodeKids has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPageTreeNodeKidsEntry">
			<id specification="PDF_1_4" clause="ArrayOfPageTreeNodeKidsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfPageTreeNodeKids shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPageTreeNodeKids is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfPagesEntry" testNumber="8"/>
			<description>Entry in ArrayOfPages shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfPages has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfPagesEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfPages shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPages is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfPagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfPagesEntry-Dictionary" testNumber="9"/>
			<description>Entry with type Dictionary in ArrayOfPages shall satisfy special case: fn:Eval(fn:IsPresent(*::SeparationInfo))</description>
			<test>HasTypeDictionary != true || (containsEntrySeparationInfo == true)</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfPages does not satisfy special case: fn:Eval(fn:IsPresent(*::SeparationInfo))</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPoints">
			<id specification="PDF_1_4" clause="ArrayOfQuadPoints" testNumber="3"/>
			<description>ArrayOfQuadPoints shall contain 8 * n elements</description>
			<test>size % 8 == 0</test>
			<error>
				<message>ArrayOfQuadPoints contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray" testNumber="2"/>
			<description>ArrayOfQuadPointsSubArray shall contain exactly 8 elements</description>
			<test>size == 8</test>
			<error>
				<message>ArrayOfQuadPointsSubArray contains %1 element(s) instead of 8</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-2" testNumber="8"/>
			<description>Entry 2 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-3" testNumber="8"/>
			<description>Entry 3 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-4" testNumber="8"/>
			<description>Entry 4 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-5" testNumber="8"/>
			<description>Entry 5 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-6" testNumber="8"/>
			<description>Entry 6 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 6 || entry6HasTypeNumber == true</test>
			<error>
				<message>Entry 6 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry6Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfQuadPointsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfQuadPointsSubArray-7" testNumber="8"/>
			<description>Entry 7 in ArrayOfQuadPointsSubArray shall have type Number</description>
			<test>size &lt;= 7 || entry7HasTypeNumber == true</test>
			<error>
				<message>Entry 7 in ArrayOfQuadPointsSubArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry7Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfSourceInformationEntry">
			<id specification="PDF_1_4" clause="ArrayOfSourceInformationEntry" testNumber="8"/>
			<description>Entry in ArrayOfSourceInformation shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfSourceInformation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStreamsGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfStreamsGeneralEntry" testNumber="8"/>
			<description>Entry in ArrayOfStreamsGeneral shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStreamsGeneral has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStreamsGeneralEntry">
			<id specification="PDF_1_4" clause="ArrayOfStreamsGeneralEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfStreamsGeneral shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfStreamsGeneral is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStringsByteEntry">
			<id specification="PDF_1_4" clause="ArrayOfStringsByteEntry" testNumber="8"/>
			<description>Entry in ArrayOfStringsByte shall have type StringByte</description>
			<test>HasTypeStringByte == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStringsByte has type %1 instead of type StringByte</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStringsTextEntry">
			<id specification="PDF_1_4" clause="ArrayOfStringsTextEntry" testNumber="8"/>
			<description>Entry in ArrayOfStringsText shall have type StringText</description>
			<test>HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStringsText has type %1 instead of type StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemEntry" testNumber="8"/>
			<description>Entry in ArrayOfStructElem shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStructElem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfStructElem shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfStructElem is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemKidsEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemKidsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfStructElemKids shall be one of objects StructElem, MarkedContentReference, ObjectReference</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfStructElemKids is not one of objects StructElem, MarkedContentReference, ObjectReference</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemKidsEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemKidsEntry" testNumber="8"/>
			<description>Entry in ArrayOfStructElemKids shall have one of types: Dictionary, Integer</description>
			<test>HasTypeDictionary == true || HasTypeInteger == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStructElemKids has type %1 instead of one of types: Dictionary, Integer</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemParentTreeEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemParentTreeEntry" testNumber="8"/>
			<description>Entry in ArrayOfStructElemParentTree shall have one of types: Dictionary, Null</description>
			<test>HasTypeDictionary == true || HasTypeNull == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfStructElemParentTree has type %1 instead of one of types: Dictionary, Null</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfStructElemParentTreeEntry">
			<id specification="PDF_1_4" clause="ArrayOfStructElemParentTreeEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfStructElemParentTree shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfStructElemParentTree is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTags">
			<id specification="PDF_1_4" clause="ArrayOfTags" testNumber="3"/>
			<description>ArrayOfTags shall contain 2 * n elements</description>
			<test>size % 2 == 0</test>
			<error>
				<message>ArrayOfTags contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfTagsSubArray" testNumber="2"/>
			<description>ArrayOfTagsSubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOfTagsSubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfTagsSubArray-0" testNumber="8"/>
			<description>Entry 0 in ArrayOfTagsSubArray shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOfTagsSubArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTagsSubArray">
			<id specification="PDF_1_4" clause="ArrayOfTagsSubArray-1" testNumber="8"/>
			<description>Entry 1 in ArrayOfTagsSubArray shall have type StringAscii</description>
			<test>size &lt;= 1 || entry1HasTypeStringAscii == true</test>
			<error>
				<message>Entry 1 in ArrayOfTagsSubArray has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfThreadsEntry">
			<id specification="PDF_1_4" clause="ArrayOfThreadsEntry" testNumber="8"/>
			<description>Entry in ArrayOfThreads shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfThreads has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Array" testNumber="17"/>
			<description>Entry with type Array in ArrayOfTrapNetVersionObjects shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in ArrayOfTrapNetVersionObjects is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ArrayOfTrapNetVersionObjects shall be one of objects OPIVersion13Dict, OPIVersion20Dict, GraphicsStateParameter, PatternType2, ShadingType1, ShadingType2, ShadingType3, XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough, FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfTrapNetVersionObjects is not one of objects OPIVersion13Dict, OPIVersion20Dict, GraphicsStateParameter, PatternType2, ShadingType1, ShadingType2, ShadingType3, XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough, FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in ArrayOfTrapNetVersionObjects shall be one of objects PatternType1, ShadingType4, ShadingType5, ShadingType6, ShadingType7, Stream</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfTrapNetVersionObjects is not one of objects PatternType1, ShadingType4, ShadingType5, ShadingType6, ShadingType7, Stream</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry" testNumber="8"/>
			<description>Entry in ArrayOfTrapNetVersionObjects shall have one of types: Array, Dictionary, Stream</description>
			<test>HasTypeArray == true || HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfTrapNetVersionObjects has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Array" testNumber="10"/>
			<description>Entry with type Array in ArrayOfTrapNetVersionObjects shall be indirect</description>
			<test>HasTypeArray != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Array in ArrayOfTrapNetVersionObjects is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfTrapNetVersionObjects shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfTrapNetVersionObjects is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapNetVersionObjectsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapNetVersionObjectsEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfTrapNetVersionObjects shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfTrapNetVersionObjects is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapRegionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapRegionsEntry" testNumber="8"/>
			<description>Entry in ArrayOfTrapRegions shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfTrapRegions has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfTrapRegionsEntry">
			<id specification="PDF_1_4" clause="ArrayOfTrapRegionsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfTrapRegions shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfTrapRegions is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfURLStringsEntry">
			<id specification="PDF_1_4" clause="ArrayOfURLStringsEntry" testNumber="8"/>
			<description>Entry in ArrayOfURLStrings shall have type StringText</description>
			<test>HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfURLStrings has type %1 instead of type StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCaptureCommandsEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCaptureCommandsEntry" testNumber="8"/>
			<description>Entry in ArrayOfWebCaptureCommands shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfWebCaptureCommands has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCaptureCommandsEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCaptureCommandsEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfWebCaptureCommands shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfWebCaptureCommands is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCaptureImagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCaptureImagesEntry" testNumber="8"/>
			<description>Entry in ArrayOfWebCaptureImages shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfWebCaptureImages has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCaptureImagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCaptureImagesEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ArrayOfWebCaptureImages shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ArrayOfWebCaptureImages is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCapturePagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCapturePagesEntry" testNumber="8"/>
			<description>Entry in ArrayOfWebCapturePages shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ArrayOfWebCapturePages has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOfWebCapturePagesEntry">
			<id specification="PDF_1_4" clause="ArrayOfWebCapturePagesEntry-Dictionary" testNumber="10"/>
			<description>Entry with type Dictionary in ArrayOfWebCapturePages shall be indirect</description>
			<test>HasTypeDictionary != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ArrayOfWebCapturePages is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Booleans">
			<id specification="PDF_1_4" clause="ArrayOf_2Booleans" testNumber="2"/>
			<description>ArrayOf_2Booleans shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2Booleans contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Booleans">
			<id specification="PDF_1_4" clause="ArrayOf_2Booleans-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2Booleans shall have type Boolean</description>
			<test>size &lt;= 0 || entry0HasTypeBoolean == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2Booleans has type %1 instead of type Boolean</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Booleans">
			<id specification="PDF_1_4" clause="ArrayOf_2Booleans-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2Booleans shall have type Boolean</description>
			<test>size &lt;= 1 || entry1HasTypeBoolean == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2Booleans has type %1 instead of type Boolean</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_2DashNumbers" testNumber="2"/>
			<description>ArrayOf_2DashNumbers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2DashNumbers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_2DashNumbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2DashNumbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2DashNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2DashNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_2DashNumbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2DashNumbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2DashNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_4" clause="ArrayOf_2Integers" testNumber="2"/>
			<description>ArrayOf_2Integers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2Integers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_4" clause="ArrayOf_2Integers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2Integers shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Integers">
			<id specification="PDF_1_4" clause="ArrayOf_2Integers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2Integers shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2LineEndingsNames">
			<id specification="PDF_1_4" clause="ArrayOf_2LineEndingsNames" testNumber="2"/>
			<description>ArrayOf_2LineEndingsNames shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2LineEndingsNames contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2LineEndingsNames">
			<id specification="PDF_1_4" clause="ArrayOf_2LineEndingsNames-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2LineEndingsNames shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2LineEndingsNames has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2LineEndingsNames">
			<id specification="PDF_1_4" clause="ArrayOf_2LineEndingsNames-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in ArrayOf_2LineEndingsNames shall have one of values: ClosedArrow, Circle, ROpenArrow, Slash, Diamond, OpenArrow, Square, Butt, None, RClosedArrow</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Square" || entry0NameValue == "Circle" || entry0NameValue == "Diamond" || entry0NameValue == "OpenArrow" || entry0NameValue == "ClosedArrow" || entry0NameValue == "None" || entry0NameValue == "Butt" || entry0NameValue == "ROpenArrow" || entry0NameValue == "RClosedArrow" || entry0NameValue == "Slash"</test>
			<error>
				<message>Entry 0 with type Name in ArrayOf_2LineEndingsNames has incorrect value %1 instead of ClosedArrow, Circle, ROpenArrow, Slash, Diamond, OpenArrow, Square, Butt, None, RClosedArrow</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2LineEndingsNames">
			<id specification="PDF_1_4" clause="ArrayOf_2LineEndingsNames-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2LineEndingsNames shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2LineEndingsNames has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2LineEndingsNames">
			<id specification="PDF_1_4" clause="ArrayOf_2LineEndingsNames-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in ArrayOf_2LineEndingsNames shall have one of values: ClosedArrow, Circle, ROpenArrow, Slash, Diamond, OpenArrow, Square, Butt, None, RClosedArrow</description>
			<test>entry1HasTypeName != true || entry1NameValue == "Square" || entry1NameValue == "Circle" || entry1NameValue == "Diamond" || entry1NameValue == "OpenArrow" || entry1NameValue == "ClosedArrow" || entry1NameValue == "None" || entry1NameValue == "Butt" || entry1NameValue == "ROpenArrow" || entry1NameValue == "RClosedArrow" || entry1NameValue == "Slash"</test>
			<error>
				<message>Entry 1 with type Name in ArrayOf_2LineEndingsNames has incorrect value %1 instead of ClosedArrow, Circle, ROpenArrow, Slash, Diamond, OpenArrow, Square, Butt, None, RClosedArrow</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_2Numbers" testNumber="2"/>
			<description>ArrayOf_2Numbers shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2Numbers contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_2Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_2Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsByte" testNumber="2"/>
			<description>ArrayOf_2StringsByte shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2StringsByte contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsByte-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2StringsByte shall have type StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2StringsByte has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsByte">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsByte-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2StringsByte shall have type StringByte</description>
			<test>size &lt;= 1 || entry1HasTypeStringByte == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2StringsByte has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsText">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsText" testNumber="2"/>
			<description>ArrayOf_2StringsText shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ArrayOf_2StringsText contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsText">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsText-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_2StringsText shall have type StringText</description>
			<test>size &lt;= 0 || entry0HasTypeStringText == true</test>
			<error>
				<message>Entry 0 in ArrayOf_2StringsText has type %1 instead of type StringText</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_2StringsText">
			<id specification="PDF_1_4" clause="ArrayOf_2StringsText-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_2StringsText shall have type StringText</description>
			<test>size &lt;= 1 || entry1HasTypeStringText == true</test>
			<error>
				<message>Entry 1 in ArrayOf_2StringsText has type %1 instead of type StringText</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers" testNumber="2"/>
			<description>ArrayOf_3NonNegativeIntegers shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>ArrayOf_3NonNegativeIntegers contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_3NonNegativeIntegers shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOf_3NonNegativeIntegers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-0-Integer" testNumber="14"/>
			<description>Entry 0 with type Integer in ArrayOf_3NonNegativeIntegers shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeInteger != true || entry0IntegerValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Integer in ArrayOf_3NonNegativeIntegers does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_3NonNegativeIntegers shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOf_3NonNegativeIntegers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-1-Integer" testNumber="14"/>
			<description>Entry 1 with type Integer in ArrayOf_3NonNegativeIntegers shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeInteger != true || entry1IntegerValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Integer in ArrayOf_3NonNegativeIntegers does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_3NonNegativeIntegers shall have type Integer</description>
			<test>size &lt;= 2 || entry2HasTypeInteger == true</test>
			<error>
				<message>Entry 2 in ArrayOf_3NonNegativeIntegers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3NonNegativeIntegers">
			<id specification="PDF_1_4" clause="ArrayOf_3NonNegativeIntegers-2-Integer" testNumber="14"/>
			<description>Entry 2 with type Integer in ArrayOf_3NonNegativeIntegers shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeInteger != true || entry2IntegerValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Integer in ArrayOf_3NonNegativeIntegers does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers" testNumber="2"/>
			<description>ArrayOf_3RGBNumbers shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>ArrayOf_3RGBNumbers contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_3RGBNumbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_3RGBNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOf_3RGBNumbers shall satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</description>
			<test>entry0HasTypeNumber != true || (entry0NumberValue &gt;= 0) &amp;&amp; (entry0NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 0 with type Number in ArrayOf_3RGBNumbers does not satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_3RGBNumbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_3RGBNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOf_3RGBNumbers shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_3RGBNumbers does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_3RGBNumbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_3RGBNumbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_3RGBNumbers">
			<id specification="PDF_1_4" clause="ArrayOf_3RGBNumbers-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOf_3RGBNumbers shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</description>
			<test>entry2HasTypeNumber != true || (entry2NumberValue &gt;= 0) &amp;&amp; (entry2NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 2 with type Number in ArrayOf_3RGBNumbers does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics" testNumber="24"/>
			<description>ArrayOf_4AnnotBorderCharacteristics shall contain 3 to 4 elements</description>
			<test>size &gt;= 3 &amp;&amp; size &lt;= 4</test>
			<error>
				<message>ArrayOf_4AnnotBorderCharacteristics contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4AnnotBorderCharacteristics shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOf_4AnnotBorderCharacteristics shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in ArrayOf_4AnnotBorderCharacteristics does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4AnnotBorderCharacteristics">
			<id specification="PDF_1_4" clause="ArrayOf_4AnnotBorderCharacteristics-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4AnnotBorderCharacteristics shall have type Array</description>
			<test>size &lt;= 3 || entry3HasTypeArray == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4AnnotBorderCharacteristics has type %1 instead of type Array</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_4" clause="ArrayOf_4Integers" testNumber="2"/>
			<description>ArrayOf_4Integers shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf_4Integers contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_4" clause="ArrayOf_4Integers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_4" clause="ArrayOf_4Integers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_4" clause="ArrayOf_4Integers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 2 || entry2HasTypeInteger == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Integers">
			<id specification="PDF_1_4" clause="ArrayOf_4Integers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4Integers shall have type Integer</description>
			<test>size &lt;= 3 || entry3HasTypeInteger == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4Integers has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_4Numbers" testNumber="2"/>
			<description>ArrayOf_4Numbers shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>ArrayOf_4Numbers contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_4Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_4Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_4Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_4Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation" testNumber="24"/>
			<description>ArrayOf_4NumbersColorAnnotation shall contain 0 to 4 elements</description>
			<test>size &gt;= 0 &amp;&amp; size &lt;= 4</test>
			<error>
				<message>ArrayOf_4NumbersColorAnnotation contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</description>
			<test>entry0HasTypeNumber != true || (entry0NumberValue &gt;= 0) &amp;&amp; (entry0NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 0 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@0 &gt;= 0) &amp;&amp; (@0 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</description>
			<test>entry1HasTypeNumber != true || (entry1NumberValue &gt;= 0) &amp;&amp; (entry1NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@1 &gt;= 0) &amp;&amp; (@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-1-Number" testNumber="9"/>
			<description>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy special case: fn:Eval(fn:IsPresent(2))</description>
			<test>entry1HasTypeNumber != true || (contains2 == true)</test>
			<error>
				<message>Entry 1 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy special case: fn:Eval(fn:IsPresent(2))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</description>
			<test>entry2HasTypeNumber != true || (entry2NumberValue &gt;= 0) &amp;&amp; (entry2NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 2 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_4NumbersColorAnnotation shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_4NumbersColorAnnotation has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_4NumbersColorAnnotation">
			<id specification="PDF_1_4" clause="ArrayOf_4NumbersColorAnnotation-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in ArrayOf_4NumbersColorAnnotation shall satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</description>
			<test>entry3HasTypeNumber != true || (entry3NumberValue &gt;= 0) &amp;&amp; (entry3NumberValue &lt;= 1)</test>
			<error>
				<message>Entry 3 with type Number in ArrayOf_4NumbersColorAnnotation does not satisfy possible value predicate: fn:Eval((@3 &gt;= 0) &amp;&amp; (@3 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers" testNumber="2"/>
			<description>ArrayOf_6Numbers shall contain exactly 6 elements</description>
			<test>size == 6</test>
			<error>
				<message>ArrayOf_6Numbers contains %1 element(s) instead of 6</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-4" testNumber="8"/>
			<description>Entry 4 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_6Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_6Numbers-5" testNumber="8"/>
			<description>Entry 5 in ArrayOf_6Numbers shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOf_6Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers" testNumber="2"/>
			<description>ArrayOf_8Numbers shall contain exactly 8 elements</description>
			<test>size == 8</test>
			<error>
				<message>ArrayOf_8Numbers contains %1 element(s) instead of 8</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-4" testNumber="8"/>
			<description>Entry 4 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-5" testNumber="8"/>
			<description>Entry 5 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-6" testNumber="8"/>
			<description>Entry 6 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 6 || entry6HasTypeNumber == true</test>
			<error>
				<message>Entry 6 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry6Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_8Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_8Numbers-7" testNumber="8"/>
			<description>Entry 7 in ArrayOf_8Numbers shall have type Number</description>
			<test>size &lt;= 7 || entry7HasTypeNumber == true</test>
			<error>
				<message>Entry 7 in ArrayOf_8Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry7Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers" testNumber="2"/>
			<description>ArrayOf_9Numbers shall contain exactly 9 elements</description>
			<test>size == 9</test>
			<error>
				<message>ArrayOf_9Numbers contains %1 element(s) instead of 9</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-0" testNumber="8"/>
			<description>Entry 0 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-1" testNumber="8"/>
			<description>Entry 1 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-2" testNumber="8"/>
			<description>Entry 2 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-3" testNumber="8"/>
			<description>Entry 3 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-4" testNumber="8"/>
			<description>Entry 4 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 4 || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-5" testNumber="8"/>
			<description>Entry 5 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 5 || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-6" testNumber="8"/>
			<description>Entry 6 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 6 || entry6HasTypeNumber == true</test>
			<error>
				<message>Entry 6 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry6Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-7" testNumber="8"/>
			<description>Entry 7 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 7 || entry7HasTypeNumber == true</test>
			<error>
				<message>Entry 7 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry7Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_9Numbers">
			<id specification="PDF_1_4" clause="ArrayOf_9Numbers-8" testNumber="8"/>
			<description>Entry 8 in ArrayOf_9Numbers shall have type Number</description>
			<test>size &lt;= 8 || entry8HasTypeNumber == true</test>
			<error>
				<message>Entry 8 in ArrayOf_9Numbers has type %1 instead of type Number</message>
				<arguments>
					<argument>entry8Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AArrayOf_ArrayOfNumbersEntry">
			<id specification="PDF_1_4" clause="ArrayOf_ArrayOfNumbersEntry" testNumber="8"/>
			<description>Entry in ArrayOf_ArrayOfNumbers shall have type Array</description>
			<test>HasTypeArray == true</test>
			<error>
				<message>Entry %keyName% in ArrayOf_ArrayOfNumbers has type %1 instead of type Array</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead" testNumber="1"/>
			<description>Bead shall not contain entries except N, P, R, T, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Bead contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-N-Dictionary" testNumber="17"/>
			<description>Entry N with type Dictionary in Bead shall be one of objects BeadFirst, Bead</description>
			<test>NHasTypeDictionary != true || N_size == 1</test>
			<error>
				<message>Entry N with type Dictionary in Bead is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-N" testNumber="8"/>
			<description>Entry N in Bead shall have type Dictionary</description>
			<test>containsN == false || NHasTypeDictionary == true</test>
			<error>
				<message>Entry N in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-N" testNumber="7"/>
			<description>Entry N in Bead is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-N-Dictionary" testNumber="10"/>
			<description>Entry N with type Dictionary in Bead shall be indirect</description>
			<test>NHasTypeDictionary != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-P" testNumber="8"/>
			<description>Entry P in Bead shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-P" testNumber="7"/>
			<description>Entry P in Bead is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in Bead shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-R" testNumber="8"/>
			<description>Entry R in Bead shall have type Rectangle</description>
			<test>containsR == false || RHasTypeRectangle == true</test>
			<error>
				<message>Entry R in Bead has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-R" testNumber="7"/>
			<description>Entry R in Bead is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-T" testNumber="8"/>
			<description>Entry T in Bead shall have type Dictionary</description>
			<test>containsT == false || THasTypeDictionary == true</test>
			<error>
				<message>Entry T in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in Bead shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-Type" testNumber="8"/>
			<description>Entry Type in Bead shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Bead has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Bead shall have value Bead</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Bead"</test>
			<error>
				<message>Entry Type with type Name in Bead has incorrect value %1 instead of Bead</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in Bead shall be one of objects BeadFirst, Bead</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in Bead is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-V" testNumber="8"/>
			<description>Entry V in Bead shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in Bead has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-V" testNumber="7"/>
			<description>Entry V in Bead is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in Bead is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABead">
			<id specification="PDF_1_4" clause="Bead-V-Dictionary" testNumber="10"/>
			<description>Entry V with type Dictionary in Bead shall be indirect</description>
			<test>VHasTypeDictionary != true || isVIndirect == true</test>
			<error>
				<message>Entry V with type Dictionary in Bead is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst" testNumber="1"/>
			<description>BeadFirst shall not contain entries except N, P, R, T, Type, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BeadFirst contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'N' &amp;&amp; elem != 'P' &amp;&amp; elem != 'R' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-N-Dictionary" testNumber="17"/>
			<description>Entry N with type Dictionary in BeadFirst shall be one of objects BeadFirst, Bead</description>
			<test>NHasTypeDictionary != true || N_size == 1</test>
			<error>
				<message>Entry N with type Dictionary in BeadFirst is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-N" testNumber="8"/>
			<description>Entry N in BeadFirst shall have type Dictionary</description>
			<test>containsN == false || NHasTypeDictionary == true</test>
			<error>
				<message>Entry N in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-N" testNumber="7"/>
			<description>Entry N in BeadFirst is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-N-Dictionary" testNumber="10"/>
			<description>Entry N with type Dictionary in BeadFirst shall be indirect</description>
			<test>NHasTypeDictionary != true || isNIndirect == true</test>
			<error>
				<message>Entry N with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-P" testNumber="8"/>
			<description>Entry P in BeadFirst shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-P" testNumber="7"/>
			<description>Entry P in BeadFirst is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in BeadFirst shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-R" testNumber="8"/>
			<description>Entry R in BeadFirst shall have type Rectangle</description>
			<test>containsR == false || RHasTypeRectangle == true</test>
			<error>
				<message>Entry R in BeadFirst has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-R" testNumber="7"/>
			<description>Entry R in BeadFirst is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-T" testNumber="8"/>
			<description>Entry T in BeadFirst shall have type Dictionary</description>
			<test>containsT == false || THasTypeDictionary == true</test>
			<error>
				<message>Entry T in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-T" testNumber="7"/>
			<description>Entry T in BeadFirst is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-T-Dictionary" testNumber="10"/>
			<description>Entry T with type Dictionary in BeadFirst shall be indirect</description>
			<test>THasTypeDictionary != true || isTIndirect == true</test>
			<error>
				<message>Entry T with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-Type" testNumber="8"/>
			<description>Entry Type in BeadFirst shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in BeadFirst has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in BeadFirst shall have value Bead</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Bead"</test>
			<error>
				<message>Entry Type with type Name in BeadFirst has incorrect value %1 instead of Bead</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in BeadFirst shall be one of objects BeadFirst, Bead</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in BeadFirst is not one of objects BeadFirst, Bead</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-V" testNumber="8"/>
			<description>Entry V in BeadFirst shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in BeadFirst has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-V" testNumber="7"/>
			<description>Entry V in BeadFirst is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in BeadFirst is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABeadFirst">
			<id specification="PDF_1_4" clause="BeadFirst-V-Dictionary" testNumber="10"/>
			<description>Entry V with type Dictionary in BeadFirst shall be indirect</description>
			<test>VHasTypeDictionary != true || isVIndirect == true</test>
			<error>
				<message>Entry V with type Dictionary in BeadFirst is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray" testNumber="2"/>
			<description>BlackpointArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>BlackpointArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-0" testNumber="8"/>
			<description>Entry 0 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-1" testNumber="8"/>
			<description>Entry 1 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-2" testNumber="8"/>
			<description>Entry 2 in BlackpointArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in BlackpointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABlackpointArray">
			<id specification="PDF_1_4" clause="BlackpointArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in BlackpointArray shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in BlackpointArray does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle" testNumber="1"/>
			<description>BorderStyle shall not contain entries except D, S, Type, W</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BorderStyle contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-D" testNumber="8"/>
			<description>Entry D in BorderStyle shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in BorderStyle has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-S" testNumber="8"/>
			<description>Entry S in BorderStyle shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in BorderStyle has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-S-Name" testNumber="6"/>
			<description>Entry S with type Name in BorderStyle shall have one of values: B, S, D, U, I</description>
			<test>SHasTypeName != true || SNameValue == "S" || SNameValue == "B" || SNameValue == "D" || SNameValue == "I" || SNameValue == "U"</test>
			<error>
				<message>Entry S with type Name in BorderStyle has incorrect value %1 instead of B, S, D, U, I</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-Type" testNumber="8"/>
			<description>Entry Type in BorderStyle shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in BorderStyle has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in BorderStyle shall have value Border</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Border"</test>
			<error>
				<message>Entry Type with type Name in BorderStyle has incorrect value %1 instead of Border</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-W" testNumber="8"/>
			<description>Entry W in BorderStyle shall have type Number</description>
			<test>containsW == false || WHasTypeNumber == true</test>
			<error>
				<message>Entry W in BorderStyle has type %1 instead of type Number</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABorderStyle">
			<id specification="PDF_1_4" clause="BorderStyle-W-Number" testNumber="14"/>
			<description>Entry W with type Number in BorderStyle shall satisfy possible value predicate: fn:Eval(@W &gt;= 0.0)</description>
			<test>WHasTypeNumber != true || WNumberValue &gt;= 0.0</test>
			<error>
				<message>Entry W with type Number in BorderStyle does not satisfy possible value predicate: fn:Eval(@W &gt;= 0.0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ABoxColorInfo">
			<id specification="PDF_1_4" clause="BoxColorInfo" testNumber="1"/>
			<description>BoxColorInfo shall not contain entries except ArtBox, BleedBox, CropBox, TrimBox</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ArtBox' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'TrimBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BoxColorInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ArtBox' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'TrimBox' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxColorInfo">
			<id specification="PDF_1_4" clause="BoxColorInfo-ArtBox" testNumber="8"/>
			<description>Entry ArtBox in BoxColorInfo shall have type Dictionary</description>
			<test>containsArtBox == false || ArtBoxHasTypeDictionary == true</test>
			<error>
				<message>Entry ArtBox in BoxColorInfo has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ArtBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxColorInfo">
			<id specification="PDF_1_4" clause="BoxColorInfo-BleedBox" testNumber="8"/>
			<description>Entry BleedBox in BoxColorInfo shall have type Dictionary</description>
			<test>containsBleedBox == false || BleedBoxHasTypeDictionary == true</test>
			<error>
				<message>Entry BleedBox in BoxColorInfo has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BleedBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxColorInfo">
			<id specification="PDF_1_4" clause="BoxColorInfo-CropBox" testNumber="8"/>
			<description>Entry CropBox in BoxColorInfo shall have type Dictionary</description>
			<test>containsCropBox == false || CropBoxHasTypeDictionary == true</test>
			<error>
				<message>Entry CropBox in BoxColorInfo has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxColorInfo">
			<id specification="PDF_1_4" clause="BoxColorInfo-TrimBox" testNumber="8"/>
			<description>Entry TrimBox in BoxColorInfo shall have type Dictionary</description>
			<test>containsTrimBox == false || TrimBoxHasTypeDictionary == true</test>
			<error>
				<message>Entry TrimBox in BoxColorInfo has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TrimBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle" testNumber="1"/>
			<description>BoxStyle shall not contain entries except C, D, S, W</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'D' &amp;&amp; elem != 'S' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>BoxStyle contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'D' &amp;&amp; elem != 'S' &amp;&amp; elem != 'W' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle-C" testNumber="8"/>
			<description>Entry C in BoxStyle shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in BoxStyle has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle-D" testNumber="8"/>
			<description>Entry D in BoxStyle shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in BoxStyle has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle-S" testNumber="8"/>
			<description>Entry S in BoxStyle shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in BoxStyle has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle-S-Name" testNumber="6"/>
			<description>Entry S with type Name in BoxStyle shall have one of values: S, D</description>
			<test>SHasTypeName != true || SNameValue == "S" || SNameValue == "D"</test>
			<error>
				<message>Entry S with type Name in BoxStyle has incorrect value %1 instead of S, D</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ABoxStyle">
			<id specification="PDF_1_4" clause="BoxStyle-W" testNumber="8"/>
			<description>Entry W in BoxStyle shall have type Number</description>
			<test>containsW == false || WHasTypeNumber == true</test>
			<error>
				<message>Entry W in BoxStyle has type %1 instead of type Number</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics" testNumber="1"/>
			<description>CIDFontDescriptorMetrics shall not contain entries except Ascent, AvgWidth, CapHeight, CharSet, Descent, Flags, FontBBox, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CIDFontDescriptorMetrics contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Ascent" testNumber="8"/>
			<description>Entry Ascent in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Ascent" testNumber="7"/>
			<description>Entry Ascent in CIDFontDescriptorMetrics is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-CharSet" testNumber="8"/>
			<description>Entry CharSet in CIDFontDescriptorMetrics shall have type String</description>
			<test>containsCharSet == false || CharSetHasTypeString == true</test>
			<error>
				<message>Entry CharSet in CIDFontDescriptorMetrics has type %1 instead of type String</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Descent" testNumber="8"/>
			<description>Entry Descent in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Descent" testNumber="7"/>
			<description>Entry Descent in CIDFontDescriptorMetrics is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in CIDFontDescriptorMetrics shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in CIDFontDescriptorMetrics does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Flags" testNumber="8"/>
			<description>Entry Flags in CIDFontDescriptorMetrics shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in CIDFontDescriptorMetrics has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Flags" testNumber="7"/>
			<description>Entry Flags in CIDFontDescriptorMetrics is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in CIDFontDescriptorMetrics shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in CIDFontDescriptorMetrics does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in CIDFontDescriptorMetrics shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in CIDFontDescriptorMetrics has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in CIDFontDescriptorMetrics is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-FontName" testNumber="8"/>
			<description>Entry FontName in CIDFontDescriptorMetrics shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in CIDFontDescriptorMetrics has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-FontName" testNumber="7"/>
			<description>Entry FontName in CIDFontDescriptorMetrics is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in CIDFontDescriptorMetrics is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Leading" testNumber="8"/>
			<description>Entry Leading in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-StemH" testNumber="8"/>
			<description>Entry StemH in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-StemV" testNumber="8"/>
			<description>Entry StemV in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-StemV" testNumber="7"/>
			<description>Entry StemV in CIDFontDescriptorMetrics is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Type" testNumber="8"/>
			<description>Entry Type in CIDFontDescriptorMetrics shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in CIDFontDescriptorMetrics has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Type" testNumber="7"/>
			<description>Entry Type in CIDFontDescriptorMetrics is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in CIDFontDescriptorMetrics is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in CIDFontDescriptorMetrics shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in CIDFontDescriptorMetrics has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDFontDescriptorMetrics">
			<id specification="PDF_1_4" clause="CIDFontDescriptorMetrics-XHeight" testNumber="8"/>
			<description>Entry XHeight in CIDFontDescriptorMetrics shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in CIDFontDescriptorMetrics has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo" testNumber="1"/>
			<description>CIDSystemInfo shall not contain entries except Ordering, Registry, Supplement</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ordering' &amp;&amp; elem != 'Registry' &amp;&amp; elem != 'Supplement' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CIDSystemInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ordering' &amp;&amp; elem != 'Registry' &amp;&amp; elem != 'Supplement' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Ordering" testNumber="8"/>
			<description>Entry Ordering in CIDSystemInfo shall have type StringAscii</description>
			<test>containsOrdering == false || OrderingHasTypeStringAscii == true</test>
			<error>
				<message>Entry Ordering in CIDSystemInfo has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>OrderingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Ordering" testNumber="7"/>
			<description>Entry Ordering in CIDSystemInfo is required</description>
			<test>containsOrdering == true</test>
			<error>
				<message>Entry Ordering in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Registry" testNumber="8"/>
			<description>Entry Registry in CIDSystemInfo shall have type StringAscii</description>
			<test>containsRegistry == false || RegistryHasTypeStringAscii == true</test>
			<error>
				<message>Entry Registry in CIDSystemInfo has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>RegistryType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Registry" testNumber="7"/>
			<description>Entry Registry in CIDSystemInfo is required</description>
			<test>containsRegistry == true</test>
			<error>
				<message>Entry Registry in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Supplement" testNumber="8"/>
			<description>Entry Supplement in CIDSystemInfo shall have type Integer</description>
			<test>containsSupplement == false || SupplementHasTypeInteger == true</test>
			<error>
				<message>Entry Supplement in CIDSystemInfo has type %1 instead of type Integer</message>
				<arguments>
					<argument>SupplementType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACIDSystemInfo">
			<id specification="PDF_1_4" clause="CIDSystemInfo-Supplement" testNumber="7"/>
			<description>Entry Supplement in CIDSystemInfo is required</description>
			<test>containsSupplement == true</test>
			<error>
				<message>Entry Supplement in CIDSystemInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream" testNumber="1"/>
			<description>CMapStream shall not contain entries except CIDSystemInfo, CMapName, DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Type, UseCMap, WMode</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'WMode' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CMapStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'WMode' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream" testNumber="22"/>
			<description>CMapStream shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>CMapStream contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in CMapStream shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in CMapStream has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in CMapStream is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-CMapName" testNumber="8"/>
			<description>Entry CMapName in CMapStream shall have type Name</description>
			<test>containsCMapName == false || CMapNameHasTypeName == true</test>
			<error>
				<message>Entry CMapName in CMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>CMapNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-CMapName" testNumber="7"/>
			<description>Entry CMapName in CMapStream is required</description>
			<test>containsCMapName == true</test>
			<error>
				<message>Entry CMapName in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in CMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in CMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in CMapStream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in CMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-F" testNumber="8"/>
			<description>Entry F in CMapStream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in CMapStream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in CMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in CMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in CMapStream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in CMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FFilter" testNumber="8"/>
			<description>Entry FFilter in CMapStream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in CMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in CMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in CMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Filter" testNumber="8"/>
			<description>Entry Filter in CMapStream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in CMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in CMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in CMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in CMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in CMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Length" testNumber="8"/>
			<description>Entry Length in CMapStream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in CMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Length" testNumber="7"/>
			<description>Entry Length in CMapStream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Type" testNumber="8"/>
			<description>Entry Type in CMapStream shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in CMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Type" testNumber="7"/>
			<description>Entry Type in CMapStream is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in CMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in CMapStream shall have value CMap</description>
			<test>TypeHasTypeName != true || TypeNameValue == "CMap"</test>
			<error>
				<message>Entry Type with type Name in CMapStream has incorrect value %1 instead of CMap</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-UseCMap" testNumber="8"/>
			<description>Entry UseCMap in CMapStream shall have one of types: Name, Stream</description>
			<test>containsUseCMap == false || UseCMapHasTypeName == true || UseCMapHasTypeStream == true</test>
			<error>
				<message>Entry UseCMap in CMapStream has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>UseCMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-UseCMap-Name" testNumber="6"/>
			<description>Entry UseCMap with type Name in CMapStream shall have one of values: GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</description>
			<test>UseCMapHasTypeName != true || UseCMapNameValue == "GB-EUC-H" || UseCMapNameValue == "GB-EUC-V" || UseCMapNameValue == "GBpc-EUC-H" || UseCMapNameValue == "GBpc-EUC-V" || UseCMapNameValue == "GBK-EUC-H" || UseCMapNameValue == "GBK-EUC-V" || UseCMapNameValue == "GBKp-EUC-H" || UseCMapNameValue == "GBKp-EUC-V" || UseCMapNameValue == "GBK2K-H" || UseCMapNameValue == "GBK2K-V" || UseCMapNameValue == "UniGB-UCS2-H" || UseCMapNameValue == "UniGB-UCS2-V" || UseCMapNameValue == "UniGB-UTF16-H" || UseCMapNameValue == "UniGB-UTF16-V" || UseCMapNameValue == "B5pc-H" || UseCMapNameValue == "B5pc-V" || UseCMapNameValue == "HKscs-B5-H" || UseCMapNameValue == "HKscs-B5-V" || UseCMapNameValue == "ETen-B5-H" || UseCMapNameValue == "ETen-B5-V" || UseCMapNameValue == "ETenms-B5-H" || UseCMapNameValue == "ETenms-B5-V" || UseCMapNameValue == "CNS-EUC-H" || UseCMapNameValue == "CNS-EUC-V" || UseCMapNameValue == "UniCNS-UCS2-H" || UseCMapNameValue == "UniCNS-UCS2-V" || UseCMapNameValue == "UniCNS-UTF16-H" || UseCMapNameValue == "UniCNS-UTF16-V" || UseCMapNameValue == "83pv-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-V" || UseCMapNameValue == "90msp-RKSJ-H" || UseCMapNameValue == "90msp-RKSJ-V" || UseCMapNameValue == "90pv-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-V" || UseCMapNameValue == "EUC-H" || UseCMapNameValue == "EUC-V" || UseCMapNameValue == "Ext-RKSJ-H" || UseCMapNameValue == "Ext-RKSJ-V" || UseCMapNameValue == "H" || UseCMapNameValue == "V" || UseCMapNameValue == "UniJIS-UCS2-H" || UseCMapNameValue == "UniJIS-UCS2-V" || UseCMapNameValue == "UniJIS-UCS2-HW-H" || UseCMapNameValue == "UniJIS-UCS2-HW-V" || UseCMapNameValue == "UniJIS-UTF16-H" || UseCMapNameValue == "UniJIS-UTF16-V" || UseCMapNameValue == "KSC-EUC-H" || UseCMapNameValue == "KSC-EUC-V" || UseCMapNameValue == "KSCms-UHC-H" || UseCMapNameValue == "KSCms-UHC-V" || UseCMapNameValue == "KSCms-UHC-HW-H" || UseCMapNameValue == "KSCms-UHC-HW-V" || UseCMapNameValue == "KSCpc-EUC-H" || UseCMapNameValue == "UniKS-UCS2-H" || UseCMapNameValue == "UniKS-UCS2-V" || UseCMapNameValue == "UniKS-UTF16-H" || UseCMapNameValue == "UniKS-UTF16-V" || UseCMapNameValue == "Identity-H" || UseCMapNameValue == "Identity-V"</test>
			<error>
				<message>Entry UseCMap with type Name in CMapStream has incorrect value %1 instead of GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</message>
				<arguments>
					<argument>UseCMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-UseCMap-Stream" testNumber="10"/>
			<description>Entry UseCMap with type Stream in CMapStream shall be indirect</description>
			<test>UseCMapHasTypeStream != true || isUseCMapIndirect == true</test>
			<error>
				<message>Entry UseCMap with type Stream in CMapStream is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-WMode" testNumber="8"/>
			<description>Entry WMode in CMapStream shall have type Integer</description>
			<test>containsWMode == false || WModeHasTypeInteger == true</test>
			<error>
				<message>Entry WMode in CMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>WModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACMapStream">
			<id specification="PDF_1_4" clause="CMapStream-WMode-Integer" testNumber="6"/>
			<description>Entry WMode with type Integer in CMapStream shall have one of values: 0, 1</description>
			<test>WModeHasTypeInteger != true || WModeIntegerValue == 1 || WModeIntegerValue == 0</test>
			<error>
				<message>Entry WMode with type Integer in CMapStream has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>WModeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_4" clause="CalGrayColorSpace" testNumber="2"/>
			<description>CalGrayColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>CalGrayColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_4" clause="CalGrayColorSpace-0" testNumber="8"/>
			<description>Entry 0 in CalGrayColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in CalGrayColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_4" clause="CalGrayColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in CalGrayColorSpace shall have value CalGray</description>
			<test>entry0HasTypeName != true || entry0NameValue == "CalGray"</test>
			<error>
				<message>Entry 0 with type Name in CalGrayColorSpace has incorrect value %1 instead of CalGray</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayColorSpace">
			<id specification="PDF_1_4" clause="CalGrayColorSpace-1" testNumber="8"/>
			<description>Entry 1 in CalGrayColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in CalGrayColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict" testNumber="1"/>
			<description>CalGrayDict shall not contain entries except BlackPoint, Gamma, WhitePoint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CalGrayDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Gamma' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in CalGrayDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in CalGrayDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict-Gamma" testNumber="8"/>
			<description>Entry Gamma in CalGrayDict shall have type Number</description>
			<test>containsGamma == false || GammaHasTypeNumber == true</test>
			<error>
				<message>Entry Gamma in CalGrayDict has type %1 instead of type Number</message>
				<arguments>
					<argument>GammaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict-Gamma-Number" testNumber="14"/>
			<description>Entry Gamma with type Number in CalGrayDict shall satisfy possible value predicate: fn:Eval(@Gamma &gt; 0)</description>
			<test>GammaHasTypeNumber != true || GammaNumberValue &gt; 0</test>
			<error>
				<message>Entry Gamma with type Number in CalGrayDict does not satisfy possible value predicate: fn:Eval(@Gamma &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in CalGrayDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in CalGrayDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalGrayDict">
			<id specification="PDF_1_4" clause="CalGrayDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in CalGrayDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in CalGrayDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_4" clause="CalRGBColorSpace" testNumber="2"/>
			<description>CalRGBColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>CalRGBColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_4" clause="CalRGBColorSpace-0" testNumber="8"/>
			<description>Entry 0 in CalRGBColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in CalRGBColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_4" clause="CalRGBColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in CalRGBColorSpace shall have value CalRGB</description>
			<test>entry0HasTypeName != true || entry0NameValue == "CalRGB"</test>
			<error>
				<message>Entry 0 with type Name in CalRGBColorSpace has incorrect value %1 instead of CalRGB</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBColorSpace">
			<id specification="PDF_1_4" clause="CalRGBColorSpace-1" testNumber="8"/>
			<description>Entry 1 in CalRGBColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in CalRGBColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict" testNumber="1"/>
			<description>CalRGBDict shall not contain entries except BlackPoint, Gamma, Matrix, WhitePoint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Gamma' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>CalRGBDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Gamma' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in CalRGBDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict-Gamma" testNumber="8"/>
			<description>Entry Gamma in CalRGBDict shall have type Array</description>
			<test>containsGamma == false || GammaHasTypeArray == true</test>
			<error>
				<message>Entry Gamma in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>GammaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict-Matrix" testNumber="8"/>
			<description>Entry Matrix in CalRGBDict shall have type Array</description>
			<test>containsMatrix == false || MatrixHasTypeArray == true</test>
			<error>
				<message>Entry Matrix in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in CalRGBDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in CalRGBDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACalRGBDict">
			<id specification="PDF_1_4" clause="CalRGBDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in CalRGBDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in CalRGBDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog" testNumber="1"/>
			<description>Catalog shall not contain entries except AA, AcroForm, Dests, Lang, MarkInfo, Metadata, Names, NeedsRendering, OpenAction, Outlines, OutputIntents, PageLabels, PageLayout, PageMode, Pages, PieceInfo, SpiderInfo, StructTreeRoot, Threads, Type, URI, Version, ViewerPreferences</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AcroForm' &amp;&amp; elem != 'Collection' &amp;&amp; elem != 'DPartRoot' &amp;&amp; elem != 'DSS' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'Extensions' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Legal' &amp;&amp; elem != 'MarkInfo' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Names' &amp;&amp; elem != 'NeedsRendering' &amp;&amp; elem != 'OCProperties' &amp;&amp; elem != 'OpenAction' &amp;&amp; elem != 'Outlines' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PageLabels' &amp;&amp; elem != 'PageLayout' &amp;&amp; elem != 'PageMode' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'Requirements' &amp;&amp; elem != 'SpiderInfo' &amp;&amp; elem != 'StructTreeRoot' &amp;&amp; elem != 'Threads' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'URI' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ViewerPreferences' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Catalog contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'AcroForm' &amp;&amp; elem != 'Collection' &amp;&amp; elem != 'DPartRoot' &amp;&amp; elem != 'DSS' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'Extensions' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Legal' &amp;&amp; elem != 'MarkInfo' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Names' &amp;&amp; elem != 'NeedsRendering' &amp;&amp; elem != 'OCProperties' &amp;&amp; elem != 'OpenAction' &amp;&amp; elem != 'Outlines' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PageLabels' &amp;&amp; elem != 'PageLayout' &amp;&amp; elem != 'PageMode' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'Requirements' &amp;&amp; elem != 'SpiderInfo' &amp;&amp; elem != 'StructTreeRoot' &amp;&amp; elem != 'Threads' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'URI' &amp;&amp; elem != 'Version' &amp;&amp; elem != 'ViewerPreferences' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog" testNumber="22"/>
			<description>Catalog shall not contain entries AF, Collection, DPartRoot, DSS, Extensions, Legal, OCProperties, Perms, Requirements in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Collection' || elem == 'DPartRoot' || elem == 'DSS' || elem == 'Extensions' || elem == 'Legal' || elem == 'OCProperties' || elem == 'Perms' || elem == 'Requirements').length == 0</test>
			<error>
				<message>Catalog contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Collection' || elem == 'DPartRoot' || elem == 'DSS' || elem == 'Extensions' || elem == 'Legal' || elem == 'OCProperties' || elem == 'Perms' || elem == 'Requirements').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-AA" testNumber="8"/>
			<description>Entry AA in Catalog shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-AcroForm" testNumber="8"/>
			<description>Entry AcroForm in Catalog shall have type Dictionary</description>
			<test>containsAcroForm == false || AcroFormHasTypeDictionary == true</test>
			<error>
				<message>Entry AcroForm in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AcroFormType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Dests" testNumber="8"/>
			<description>Entry Dests in Catalog shall have type Dictionary</description>
			<test>containsDests == false || DestsHasTypeDictionary == true</test>
			<error>
				<message>Entry Dests in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DestsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Dests-Dictionary" testNumber="10"/>
			<description>Entry Dests with type Dictionary in Catalog shall be indirect</description>
			<test>DestsHasTypeDictionary != true || isDestsIndirect == true</test>
			<error>
				<message>Entry Dests with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Lang" testNumber="8"/>
			<description>Entry Lang in Catalog shall have type StringText</description>
			<test>containsLang == false || LangHasTypeStringText == true</test>
			<error>
				<message>Entry Lang in Catalog has type %1 instead of type StringText</message>
				<arguments>
					<argument>LangType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-MarkInfo" testNumber="8"/>
			<description>Entry MarkInfo in Catalog shall have type Dictionary</description>
			<test>containsMarkInfo == false || MarkInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry MarkInfo in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MarkInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Metadata" testNumber="8"/>
			<description>Entry Metadata in Catalog shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in Catalog has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in Catalog shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Names" testNumber="8"/>
			<description>Entry Names in Catalog shall have type Dictionary</description>
			<test>containsNames == false || NamesHasTypeDictionary == true</test>
			<error>
				<message>Entry Names in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NamesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-NeedsRendering" testNumber="8"/>
			<description>Entry NeedsRendering in Catalog shall have type Boolean</description>
			<test>containsNeedsRendering == false || NeedsRenderingHasTypeBoolean == true</test>
			<error>
				<message>Entry NeedsRendering in Catalog has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NeedsRenderingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-OpenAction-Array" testNumber="17"/>
			<description>Entry OpenAction with type Array in Catalog shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>OpenActionHasTypeArray != true || OpenAction_size == 1</test>
			<error>
				<message>Entry OpenAction with type Array in Catalog is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-OpenAction-Dictionary" testNumber="17"/>
			<description>Entry OpenAction with type Dictionary in Catalog shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>OpenActionHasTypeDictionary != true || OpenAction_size == 1</test>
			<error>
				<message>Entry OpenAction with type Dictionary in Catalog is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-OpenAction" testNumber="8"/>
			<description>Entry OpenAction in Catalog shall have one of types: Array, Dictionary</description>
			<test>containsOpenAction == false || OpenActionHasTypeArray == true || OpenActionHasTypeDictionary == true</test>
			<error>
				<message>Entry OpenAction in Catalog has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>OpenActionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Outlines" testNumber="8"/>
			<description>Entry Outlines in Catalog shall have type Dictionary</description>
			<test>containsOutlines == false || OutlinesHasTypeDictionary == true</test>
			<error>
				<message>Entry Outlines in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OutlinesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Outlines-Dictionary" testNumber="10"/>
			<description>Entry Outlines with type Dictionary in Catalog shall be indirect</description>
			<test>OutlinesHasTypeDictionary != true || isOutlinesIndirect == true</test>
			<error>
				<message>Entry Outlines with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-OutputIntents" testNumber="8"/>
			<description>Entry OutputIntents in Catalog shall have type Array</description>
			<test>containsOutputIntents == false || OutputIntentsHasTypeArray == true</test>
			<error>
				<message>Entry OutputIntents in Catalog has type %1 instead of type Array</message>
				<arguments>
					<argument>OutputIntentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageLabels" testNumber="8"/>
			<description>Entry PageLabels in Catalog shall have type NumberTree</description>
			<test>containsPageLabels == false || PageLabelsHasTypeNumberTree == true</test>
			<error>
				<message>Entry PageLabels in Catalog has type %1 instead of type NumberTree</message>
				<arguments>
					<argument>PageLabelsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageLabels-NumberTree" testNumber="9"/>
			<description>Entry PageLabels with type NumberTree in Catalog shall satisfy special case: fn:Eval(fn:IsNumberTreeIndex(PageLabels, 0))</description>
			<test>PageLabelsHasTypeNumberTree != true || (number0IsNumberTreePageLabelsIndex == true)</test>
			<error>
				<message>Entry PageLabels with type NumberTree in Catalog does not satisfy special case: fn:Eval(fn:IsNumberTreeIndex(PageLabels, 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageLabelsTreeNode" testNumber="8"/>
			<description>Entry PageLabelsTreeNode in Catalog shall have type NumberTree</description>
			<test>containsPageLabelsTreeNode == false || PageLabelsTreeNodeHasTypeNumberTree == true</test>
			<error>
				<message>Entry PageLabelsTreeNode in Catalog has type %1 instead of type NumberTree</message>
				<arguments>
					<argument>PageLabelsTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageLayout" testNumber="8"/>
			<description>Entry PageLayout in Catalog shall have type Name</description>
			<test>containsPageLayout == false || PageLayoutHasTypeName == true</test>
			<error>
				<message>Entry PageLayout in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>PageLayoutType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageLayout-Name" testNumber="6"/>
			<description>Entry PageLayout with type Name in Catalog shall have one of values: SinglePage, TwoColumnLeft, OneColumn, TwoPageRight, TwoPageLeft, TwoColumnRight</description>
			<test>PageLayoutHasTypeName != true || PageLayoutNameValue == "SinglePage" || PageLayoutNameValue == "OneColumn" || PageLayoutNameValue == "TwoColumnLeft" || PageLayoutNameValue == "TwoColumnRight" || PageLayoutNameValue == "TwoPageLeft" || PageLayoutNameValue == "TwoPageRight"</test>
			<error>
				<message>Entry PageLayout with type Name in Catalog has incorrect value %1 instead of SinglePage, TwoColumnLeft, OneColumn, TwoPageRight, TwoPageLeft, TwoColumnRight</message>
				<arguments>
					<argument>PageLayoutNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageMode" testNumber="8"/>
			<description>Entry PageMode in Catalog shall have type Name</description>
			<test>containsPageMode == false || PageModeHasTypeName == true</test>
			<error>
				<message>Entry PageMode in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>PageModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PageMode-Name" testNumber="6"/>
			<description>Entry PageMode with type Name in Catalog shall have one of values: UseOutlines, UseThumbs, UseOC, UseAttachments, UseNone, FullScreen</description>
			<test>PageModeHasTypeName != true || PageModeNameValue == "UseNone" || PageModeNameValue == "UseOutlines" || PageModeNameValue == "UseThumbs" || PageModeNameValue == "FullScreen" || PageModeNameValue == "UseOC" || PageModeNameValue == "UseAttachments"</test>
			<error>
				<message>Entry PageMode with type Name in Catalog has incorrect value %1 instead of UseOutlines, UseThumbs, UseOC, UseAttachments, UseNone, FullScreen</message>
				<arguments>
					<argument>PageModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Pages" testNumber="8"/>
			<description>Entry Pages in Catalog shall have type Dictionary</description>
			<test>containsPages == false || PagesHasTypeDictionary == true</test>
			<error>
				<message>Entry Pages in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PagesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Pages" testNumber="7"/>
			<description>Entry Pages in Catalog is required</description>
			<test>containsPages == true</test>
			<error>
				<message>Entry Pages in Catalog is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Pages-Dictionary" testNumber="10"/>
			<description>Entry Pages with type Dictionary in Catalog shall be indirect</description>
			<test>PagesHasTypeDictionary != true || isPagesIndirect == true</test>
			<error>
				<message>Entry Pages with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-PieceInfo" testNumber="8"/>
			<description>Entry PieceInfo in Catalog shall have type Dictionary</description>
			<test>containsPieceInfo == false || PieceInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry PieceInfo in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PieceInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-SpiderInfo" testNumber="8"/>
			<description>Entry SpiderInfo in Catalog shall have type Dictionary</description>
			<test>containsSpiderInfo == false || SpiderInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry SpiderInfo in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>SpiderInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-StructTreeRoot" testNumber="8"/>
			<description>Entry StructTreeRoot in Catalog shall have type Dictionary</description>
			<test>containsStructTreeRoot == false || StructTreeRootHasTypeDictionary == true</test>
			<error>
				<message>Entry StructTreeRoot in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>StructTreeRootType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-StructTreeRoot-Dictionary" testNumber="10"/>
			<description>Entry StructTreeRoot with type Dictionary in Catalog shall be indirect</description>
			<test>StructTreeRootHasTypeDictionary != true || isStructTreeRootIndirect == true</test>
			<error>
				<message>Entry StructTreeRoot with type Dictionary in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Threads" testNumber="8"/>
			<description>Entry Threads in Catalog shall have type Array</description>
			<test>containsThreads == false || ThreadsHasTypeArray == true</test>
			<error>
				<message>Entry Threads in Catalog has type %1 instead of type Array</message>
				<arguments>
					<argument>ThreadsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Threads-Array" testNumber="10"/>
			<description>Entry Threads with type Array in Catalog shall be indirect</description>
			<test>ThreadsHasTypeArray != true || isThreadsIndirect == true</test>
			<error>
				<message>Entry Threads with type Array in Catalog is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Type" testNumber="8"/>
			<description>Entry Type in Catalog shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Type" testNumber="7"/>
			<description>Entry Type in Catalog is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in Catalog is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Catalog shall have value Catalog</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Catalog"</test>
			<error>
				<message>Entry Type with type Name in Catalog has incorrect value %1 instead of Catalog</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-URI" testNumber="8"/>
			<description>Entry URI in Catalog shall have type Dictionary</description>
			<test>containsURI == false || URIHasTypeDictionary == true</test>
			<error>
				<message>Entry URI in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>URIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Version" testNumber="8"/>
			<description>Entry Version in Catalog shall have type Name</description>
			<test>containsVersion == false || VersionHasTypeName == true</test>
			<error>
				<message>Entry Version in Catalog has type %1 instead of type Name</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-Version-Name" testNumber="6"/>
			<description>Entry Version with type Name in Catalog shall have one of values: 1.0, 1.1, 2.0, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7</description>
			<test>VersionHasTypeName != true || VersionNameValue == "1.0" || VersionNameValue == "1.1" || VersionNameValue == "1.2" || VersionNameValue == "1.3" || VersionNameValue == "1.4" || VersionNameValue == "1.5" || VersionNameValue == "1.6" || VersionNameValue == "1.7" || VersionNameValue == "2.0"</test>
			<error>
				<message>Entry Version with type Name in Catalog has incorrect value %1 instead of 1.0, 1.1, 2.0, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7</message>
				<arguments>
					<argument>VersionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalog">
			<id specification="PDF_1_4" clause="Catalog-ViewerPreferences" testNumber="8"/>
			<description>Entry ViewerPreferences in Catalog shall have type Dictionary</description>
			<test>containsViewerPreferences == false || ViewerPreferencesHasTypeDictionary == true</test>
			<error>
				<message>Entry ViewerPreferences in Catalog has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ViewerPreferencesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACatalogNumberTreePageLabelsEntry">
			<id specification="PDF_1_4" clause="CatalogNumberTreePageLabelsEntry" testNumber="8"/>
			<description>Entry in CatalogNumberTreePageLabels shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in CatalogNumberTreePageLabels has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACharProcMapEntry">
			<id specification="PDF_1_4" clause="CharProcMapEntry" testNumber="8"/>
			<description>Entry in CharProcMap shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in CharProcMap has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ACharProcMapEntry">
			<id specification="PDF_1_4" clause="CharProcMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in CharProcMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in CharProcMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AClassMapEntry">
			<id specification="PDF_1_4" clause="ClassMapEntry" testNumber="8"/>
			<description>Entry in ClassMap shall have one of types: Array, Dictionary</description>
			<test>HasTypeArray == true || HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in ClassMap has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultCMYK-Array" testNumber="17"/>
			<description>Entry DefaultCMYK with type Array in ColorSpaceMap shall be one of objects ICCBasedColorSpace, DeviceNColorSpace</description>
			<test>DefaultCMYKHasTypeArray != true || DefaultCMYK_size == 1</test>
			<error>
				<message>Entry DefaultCMYK with type Array in ColorSpaceMap is not one of objects ICCBasedColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultCMYK" testNumber="8"/>
			<description>Entry DefaultCMYK in ColorSpaceMap shall have type Array</description>
			<test>containsDefaultCMYK == false || DefaultCMYKHasTypeArray == true</test>
			<error>
				<message>Entry DefaultCMYK in ColorSpaceMap has type %1 instead of type Array</message>
				<arguments>
					<argument>DefaultCMYKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultGray-Array" testNumber="17"/>
			<description>Entry DefaultGray with type Array in ColorSpaceMap shall be one of objects CalGrayColorSpace, ICCBasedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>DefaultGrayHasTypeArray != true || DefaultGray_size == 1</test>
			<error>
				<message>Entry DefaultGray with type Array in ColorSpaceMap is not one of objects CalGrayColorSpace, ICCBasedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultGray" testNumber="8"/>
			<description>Entry DefaultGray in ColorSpaceMap shall have type Array</description>
			<test>containsDefaultGray == false || DefaultGrayHasTypeArray == true</test>
			<error>
				<message>Entry DefaultGray in ColorSpaceMap has type %1 instead of type Array</message>
				<arguments>
					<argument>DefaultGrayType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultRGB-Array" testNumber="17"/>
			<description>Entry DefaultRGB with type Array in ColorSpaceMap shall be one of objects CalRGBColorSpace, ICCBasedColorSpace, DeviceNColorSpace</description>
			<test>DefaultRGBHasTypeArray != true || DefaultRGB_size == 1</test>
			<error>
				<message>Entry DefaultRGB with type Array in ColorSpaceMap is not one of objects CalRGBColorSpace, ICCBasedColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMap">
			<id specification="PDF_1_4" clause="ColorSpaceMap-DefaultRGB" testNumber="8"/>
			<description>Entry DefaultRGB in ColorSpaceMap shall have type Array</description>
			<test>containsDefaultRGB == false || DefaultRGBHasTypeArray == true</test>
			<error>
				<message>Entry DefaultRGB in ColorSpaceMap has type %1 instead of type Array</message>
				<arguments>
					<argument>DefaultRGBType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_4" clause="ColorSpaceMapEntry-Array" testNumber="17"/>
			<description>Entry with type Array in ColorSpaceMap shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in ColorSpaceMap is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_4" clause="ColorSpaceMapEntry" testNumber="8"/>
			<description>Entry in ColorSpaceMap shall have one of types: Array, Name</description>
			<test>HasTypeArray == true || HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in ColorSpaceMap has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorSpaceMapEntry">
			<id specification="PDF_1_4" clause="ColorSpaceMapEntry-Name" testNumber="6"/>
			<description>Entry with type Name in ColorSpaceMap shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>HasTypeName != true || NameValue == "DeviceCMYK" || NameValue == "DeviceRGB" || NameValue == "DeviceGray"</test>
			<error>
				<message>Entry %keyName% with type Name in ColorSpaceMap has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>NameValue</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AColorantsDictEntry">
			<id specification="PDF_1_4" clause="ColorantsDictEntry" testNumber="8"/>
			<description>Entry in ColorantsDict shall have type Array</description>
			<test>HasTypeArray == true</test>
			<error>
				<message>Entry %keyName% in ColorantsDict has type %1 instead of type Array</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AData">
			<id specification="PDF_1_4" clause="Data-LastModified" testNumber="8"/>
			<description>Entry LastModified in Data shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in Data has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AData">
			<id specification="PDF_1_4" clause="Data-LastModified" testNumber="7"/>
			<description>Entry LastModified in Data is required</description>
			<test>containsLastModified == true</test>
			<error>
				<message>Entry LastModified in Data is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AData">
			<id specification="PDF_1_4" clause="Data-Private" testNumber="8"/>
			<description>Entry Private in Data shall have one of types: Array, Boolean, Dictionary, Integer, Name, Number, Stream, String</description>
			<test>containsPrivate == false || PrivateHasTypeArray == true || PrivateHasTypeBoolean == true || PrivateHasTypeDictionary == true || PrivateHasTypeInteger == true || PrivateHasTypeName == true || PrivateHasTypeNumber == true || PrivateHasTypeStream == true || PrivateHasTypeString == true</test>
			<error>
				<message>Entry Private in Data has type %1 instead of one of types: Array, Boolean, Dictionary, Integer, Name, Number, Stream, String</message>
				<arguments>
					<argument>PrivateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AData">
			<id specification="PDF_1_4" clause="Data-Private-Stream" testNumber="10"/>
			<description>Entry Private with type Stream in Data shall be indirect</description>
			<test>PrivateHasTypeStream != true || isPrivateIndirect == true</test>
			<error>
				<message>Entry Private with type Stream in Data is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADataEntry">
			<id specification="PDF_1_4" clause="DataEntry" testNumber="8"/>
			<description>Entry in Data shall have one of types: Array, Boolean, Dictionary, Integer, Name, Number, Stream, String</description>
			<test>HasTypeArray == true || HasTypeBoolean == true || HasTypeDictionary == true || HasTypeInteger == true || HasTypeName == true || HasTypeNumber == true || HasTypeStream == true || HasTypeString == true</test>
			<error>
				<message>Entry %keyName% in Data has type %1 instead of one of types: Array, Boolean, Dictionary, Integer, Name, Number, Stream, String</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADataEntry">
			<id specification="PDF_1_4" clause="DataEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in Data shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in Data is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_4" clause="Dest0Array" testNumber="2"/>
			<description>Dest0Array shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>Dest0Array contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_4" clause="Dest0Array-0" testNumber="8"/>
			<description>Entry 0 in Dest0Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest0Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_4" clause="Dest0Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest0Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest0Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_4" clause="Dest0Array-1" testNumber="8"/>
			<description>Entry 1 in Dest0Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest0Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest0Array">
			<id specification="PDF_1_4" clause="Dest0Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest0Array shall have one of values: Fit, FitB</description>
			<test>entry1HasTypeName != true || entry1NameValue == "Fit" || entry1NameValue == "FitB"</test>
			<error>
				<message>Entry 1 with type Name in Dest0Array has incorrect value %1 instead of Fit, FitB</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array" testNumber="2"/>
			<description>Dest1Array shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>Dest1Array contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array-0" testNumber="8"/>
			<description>Entry 0 in Dest1Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest1Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest1Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest1Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array-1" testNumber="8"/>
			<description>Entry 1 in Dest1Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest1Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest1Array shall have one of values: FitV, FitH, FitBH, FitBV</description>
			<test>entry1HasTypeName != true || entry1NameValue == "FitH" || entry1NameValue == "FitV" || entry1NameValue == "FitBH" || entry1NameValue == "FitBV"</test>
			<error>
				<message>Entry 1 with type Name in Dest1Array has incorrect value %1 instead of FitV, FitH, FitBH, FitBV</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest1Array">
			<id specification="PDF_1_4" clause="Dest1Array-2" testNumber="8"/>
			<description>Entry 2 in Dest1Array shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in Dest1Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array" testNumber="2"/>
			<description>Dest4Array shall contain exactly 6 elements</description>
			<test>size == 6</test>
			<error>
				<message>Dest4Array contains %1 element(s) instead of 6</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-0" testNumber="8"/>
			<description>Entry 0 in Dest4Array shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in Dest4Array has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in Dest4Array shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in Dest4Array does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-1" testNumber="8"/>
			<description>Entry 1 in Dest4Array shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in Dest4Array has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in Dest4Array shall have value FitR</description>
			<test>entry1HasTypeName != true || entry1NameValue == "FitR"</test>
			<error>
				<message>Entry 1 with type Name in Dest4Array has incorrect value %1 instead of FitR</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-2" testNumber="8"/>
			<description>Entry 2 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-3" testNumber="8"/>
			<description>Entry 3 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 3 || entry3HasTypeNull == true || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-4" testNumber="8"/>
			<description>Entry 4 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 4 || entry4HasTypeNull == true || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADest4Array">
			<id specification="PDF_1_4" clause="Dest4Array-5" testNumber="8"/>
			<description>Entry 5 in Dest4Array shall have one of types: Null, Number</description>
			<test>size &lt;= 5 || entry5HasTypeNull == true || entry5HasTypeNumber == true</test>
			<error>
				<message>Entry 5 in Dest4Array has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry5Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_4" clause="DestDict" testNumber="1"/>
			<description>DestDict shall not contain entries except D</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'SD' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>DestDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'SD' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_4" clause="DestDict" testNumber="22"/>
			<description>DestDict shall not contain entry SD in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsSD == false</test>
			<error>
				<message>DestDict contains entry SD</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_4" clause="DestDict-D-Array" testNumber="17"/>
			<description>Entry D with type Array in DestDict shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DHasTypeArray != true || D_size == 1</test>
			<error>
				<message>Entry D with type Array in DestDict is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_4" clause="DestDict-D" testNumber="8"/>
			<description>Entry D in DestDict shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in DestDict has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestDict">
			<id specification="PDF_1_4" clause="DestDict-D" testNumber="7"/>
			<description>Entry D in DestDict is required</description>
			<test>containsD == true</test>
			<error>
				<message>Entry D in DestDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray" testNumber="2"/>
			<description>DestXYZArray shall contain exactly 5 elements</description>
			<test>size == 5</test>
			<error>
				<message>DestXYZArray contains %1 element(s) instead of 5</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-0" testNumber="8"/>
			<description>Entry 0 in DestXYZArray shall have one of types: Dictionary, Number</description>
			<test>size &lt;= 0 || entry0HasTypeDictionary == true || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in DestXYZArray has type %1 instead of one of types: Dictionary, Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in DestXYZArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in DestXYZArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-1" testNumber="8"/>
			<description>Entry 1 in DestXYZArray shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in DestXYZArray has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in DestXYZArray shall have value XYZ</description>
			<test>entry1HasTypeName != true || entry1NameValue == "XYZ"</test>
			<error>
				<message>Entry 1 with type Name in DestXYZArray has incorrect value %1 instead of XYZ</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-2" testNumber="8"/>
			<description>Entry 2 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 2 || entry2HasTypeNull == true || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-3" testNumber="8"/>
			<description>Entry 3 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 3 || entry3HasTypeNull == true || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestXYZArray">
			<id specification="PDF_1_4" clause="DestXYZArray-4" testNumber="8"/>
			<description>Entry 4 in DestXYZArray shall have one of types: Null, Number</description>
			<test>size &lt;= 4 || entry4HasTypeNull == true || entry4HasTypeNumber == true</test>
			<error>
				<message>Entry 4 in DestXYZArray has type %1 instead of one of types: Null, Number</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_4" clause="DestsMapEntry-Array" testNumber="17"/>
			<description>Entry with type Array in DestsMap shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in DestsMap is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_4" clause="DestsMapEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in DestsMap shall be one of objects ActionGoTo, ActionGoToR, DestDict</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in DestsMap is not one of objects ActionGoTo, ActionGoToR, DestDict</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADestsMapEntry">
			<id specification="PDF_1_4" clause="DestsMapEntry" testNumber="8"/>
			<description>Entry in DestsMap shall have one of types: Array, Dictionary</description>
			<test>HasTypeArray == true || HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in DestsMap has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace" testNumber="24"/>
			<description>DeviceNColorSpace shall contain 4 to 5 elements</description>
			<test>size &gt;= 4 &amp;&amp; size &lt;= 5</test>
			<error>
				<message>DeviceNColorSpace contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-0" testNumber="8"/>
			<description>Entry 0 in DeviceNColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in DeviceNColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in DeviceNColorSpace shall have value DeviceN</description>
			<test>entry0HasTypeName != true || entry0NameValue == "DeviceN"</test>
			<error>
				<message>Entry 0 with type Name in DeviceNColorSpace has incorrect value %1 instead of DeviceN</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-1" testNumber="8"/>
			<description>Entry 1 in DeviceNColorSpace shall have type Array</description>
			<test>size &lt;= 1 || entry1HasTypeArray == true</test>
			<error>
				<message>Entry 1 in DeviceNColorSpace has type %1 instead of type Array</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-2-Array" testNumber="17"/>
			<description>Entry 2 with type Array in DeviceNColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace</description>
			<test>entry2HasTypeArray != true || entry2_size == 1</test>
			<error>
				<message>Entry 2 with type Array in DeviceNColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-2" testNumber="8"/>
			<description>Entry 2 in DeviceNColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 2 || entry2HasTypeArray == true || entry2HasTypeName == true</test>
			<error>
				<message>Entry 2 in DeviceNColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-2-Name" testNumber="6"/>
			<description>Entry 2 with type Name in DeviceNColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry2HasTypeName != true || entry2NameValue == "DeviceCMYK" || entry2NameValue == "DeviceRGB" || entry2NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 2 with type Name in DeviceNColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry2NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-3-Dictionary" testNumber="17"/>
			<description>Entry 3 with type Dictionary in DeviceNColorSpace shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry3HasTypeDictionary != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Dictionary in DeviceNColorSpace is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-3-Stream" testNumber="17"/>
			<description>Entry 3 with type Stream in DeviceNColorSpace shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry3HasTypeStream != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Stream in DeviceNColorSpace is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-3" testNumber="8"/>
			<description>Entry 3 in DeviceNColorSpace shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 3 || entry3HasTypeDictionary == true || entry3HasTypeStream == true</test>
			<error>
				<message>Entry 3 in DeviceNColorSpace has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in DeviceNColorSpace shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in DeviceNColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNColorSpace">
			<id specification="PDF_1_4" clause="DeviceNColorSpace-4" testNumber="8"/>
			<description>Entry 4 in DeviceNColorSpace shall have type Dictionary</description>
			<test>size &lt;= 4 || entry4HasTypeDictionary == true</test>
			<error>
				<message>Entry 4 in DeviceNColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry4Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNDict">
			<id specification="PDF_1_4" clause="DeviceNDict" testNumber="1"/>
			<description>DeviceNDict shall not contain entries except Colorants</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Colorants' &amp;&amp; elem != 'MixingHints' &amp;&amp; elem != 'Process' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>DeviceNDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Colorants' &amp;&amp; elem != 'MixingHints' &amp;&amp; elem != 'Process' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNDict">
			<id specification="PDF_1_4" clause="DeviceNDict" testNumber="22"/>
			<description>DeviceNDict shall not contain entries MixingHints, Process, Subtype in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'MixingHints' || elem == 'Process' || elem == 'Subtype').length == 0</test>
			<error>
				<message>DeviceNDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'MixingHints' || elem == 'Process' || elem == 'Subtype').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNDict">
			<id specification="PDF_1_4" clause="DeviceNDict-Colorants" testNumber="8"/>
			<description>Entry Colorants in DeviceNDict shall have type Dictionary</description>
			<test>containsColorants == false || ColorantsHasTypeDictionary == true</test>
			<error>
				<message>Entry Colorants in DeviceNDict has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ColorantsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADeviceNDict">
			<id specification="PDF_1_4" clause="DeviceNDict-Colorants" testNumber="11"/>
			<description>Entry Colorants in DeviceNDict is required, when fn:HasSpotColorants(parent::1)</description>
			<test>containsColorants == true || (parent1EntriesString != null &amp;&amp; parent1EntriesString.split('&amp;').filter(elem =&gt; elem != "Cyan" &amp;&amp; elem != "Magenta" &amp;&amp; elem != "Yellow" &amp;&amp; elem != "Black").length &gt; 0) == false</test>
			<error>
				<message>Entry Colorants in DeviceNDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADictionaryOfDictionariesEntry">
			<id specification="PDF_1_4" clause="DictionaryOfDictionariesEntry" testNumber="8"/>
			<description>Entry in DictionaryOfDictionaries shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in DictionaryOfDictionaries has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Author" testNumber="8"/>
			<description>Entry Author in DocInfo shall have type StringText</description>
			<test>containsAuthor == false || AuthorHasTypeStringText == true</test>
			<error>
				<message>Entry Author in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>AuthorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-CreationDate" testNumber="8"/>
			<description>Entry CreationDate in DocInfo shall have type Date</description>
			<test>containsCreationDate == false || CreationDateHasTypeDate == true</test>
			<error>
				<message>Entry CreationDate in DocInfo has type %1 instead of type Date</message>
				<arguments>
					<argument>CreationDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Creator" testNumber="8"/>
			<description>Entry Creator in DocInfo shall have type StringText</description>
			<test>containsCreator == false || CreatorHasTypeStringText == true</test>
			<error>
				<message>Entry Creator in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>CreatorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Keywords" testNumber="8"/>
			<description>Entry Keywords in DocInfo shall have type StringText</description>
			<test>containsKeywords == false || KeywordsHasTypeStringText == true</test>
			<error>
				<message>Entry Keywords in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>KeywordsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-ModDate" testNumber="8"/>
			<description>Entry ModDate in DocInfo shall have type Date</description>
			<test>containsModDate == false || ModDateHasTypeDate == true</test>
			<error>
				<message>Entry ModDate in DocInfo has type %1 instead of type Date</message>
				<arguments>
					<argument>ModDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Producer" testNumber="8"/>
			<description>Entry Producer in DocInfo shall have type StringText</description>
			<test>containsProducer == false || ProducerHasTypeStringText == true</test>
			<error>
				<message>Entry Producer in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>ProducerType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Subject" testNumber="8"/>
			<description>Entry Subject in DocInfo shall have type StringText</description>
			<test>containsSubject == false || SubjectHasTypeStringText == true</test>
			<error>
				<message>Entry Subject in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>SubjectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Title" testNumber="8"/>
			<description>Entry Title in DocInfo shall have type StringText</description>
			<test>containsTitle == false || TitleHasTypeStringText == true</test>
			<error>
				<message>Entry Title in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>TitleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Trapped" testNumber="8"/>
			<description>Entry Trapped in DocInfo shall have type Name</description>
			<test>containsTrapped == false || TrappedHasTypeName == true</test>
			<error>
				<message>Entry Trapped in DocInfo has type %1 instead of type Name</message>
				<arguments>
					<argument>TrappedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfo">
			<id specification="PDF_1_4" clause="DocInfo-Trapped-Name" testNumber="6"/>
			<description>Entry Trapped with type Name in DocInfo shall have one of values: Unknown, True, False</description>
			<test>TrappedHasTypeName != true || TrappedNameValue == "True" || TrappedNameValue == "False" || TrappedNameValue == "Unknown"</test>
			<error>
				<message>Entry Trapped with type Name in DocInfo has incorrect value %1 instead of Unknown, True, False</message>
				<arguments>
					<argument>TrappedNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocInfoEntry">
			<id specification="PDF_1_4" clause="DocInfoEntry" testNumber="8"/>
			<description>Entry in DocInfo shall have type StringText</description>
			<test>HasTypeStringText == true</test>
			<error>
				<message>Entry %keyName% in DocInfo has type %1 instead of type StringText</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_4" clause="Document-ObjectStreams" testNumber="25"/>
			<description>Document shall not contain ObjectStreams in PDF 1.4</description>
			<test>containsObjectStreams == false</test>
			<error>
				<message>Document contains ObjectStreams</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_4" clause="Document-XRefStream" testNumber="25"/>
			<description>Document shall not contain XRefStream in PDF 1.4</description>
			<test>containsXRefStream == false</test>
			<error>
				<message>Document contains XRefStream</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ADocument">
			<id specification="PDF_1_4" clause="Document-FileTrailer" testNumber="8"/>
			<description>FileTrailer shall have type Dictionary</description>
			<test>containsFileTrailer == false || FileTrailerHasTypeDictionary == true</test>
			<error>
				<message>FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FileTrailerType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter" testNumber="1"/>
			<description>EmbeddedFileParameter shall not contain entries except CheckSum, CreationDate, Mac, ModDate, Size</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CheckSum' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'ModDate' &amp;&amp; elem != 'Size' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EmbeddedFileParameter contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CheckSum' &amp;&amp; elem != 'CreationDate' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'ModDate' &amp;&amp; elem != 'Size' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-CheckSum" testNumber="8"/>
			<description>Entry CheckSum in EmbeddedFileParameter shall have type StringByte</description>
			<test>containsCheckSum == false || CheckSumHasTypeStringByte == true</test>
			<error>
				<message>Entry CheckSum in EmbeddedFileParameter has type %1 instead of type StringByte</message>
				<arguments>
					<argument>CheckSumType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-CheckSum-StringByte" testNumber="9"/>
			<description>Entry CheckSum with type StringByte in EmbeddedFileParameter shall satisfy special case: fn:Eval(fn:StringLength(CheckSum) == 16)</description>
			<test>CheckSumHasTypeStringByte != true || (CheckSumStringSize == 16)</test>
			<error>
				<message>Entry CheckSum with type StringByte in EmbeddedFileParameter does not satisfy special case: fn:Eval(fn:StringLength(CheckSum) == 16)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-CreationDate" testNumber="8"/>
			<description>Entry CreationDate in EmbeddedFileParameter shall have type Date</description>
			<test>containsCreationDate == false || CreationDateHasTypeDate == true</test>
			<error>
				<message>Entry CreationDate in EmbeddedFileParameter has type %1 instead of type Date</message>
				<arguments>
					<argument>CreationDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-Mac" testNumber="8"/>
			<description>Entry Mac in EmbeddedFileParameter shall have type Dictionary</description>
			<test>containsMac == false || MacHasTypeDictionary == true</test>
			<error>
				<message>Entry Mac in EmbeddedFileParameter has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>MacType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-ModDate" testNumber="8"/>
			<description>Entry ModDate in EmbeddedFileParameter shall have type Date</description>
			<test>containsModDate == false || ModDateHasTypeDate == true</test>
			<error>
				<message>Entry ModDate in EmbeddedFileParameter has type %1 instead of type Date</message>
				<arguments>
					<argument>ModDateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-Size" testNumber="8"/>
			<description>Entry Size in EmbeddedFileParameter shall have type Integer</description>
			<test>containsSize == false || SizeHasTypeInteger == true</test>
			<error>
				<message>Entry Size in EmbeddedFileParameter has type %1 instead of type Integer</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileParameter">
			<id specification="PDF_1_4" clause="EmbeddedFileParameter-Size-Integer" testNumber="14"/>
			<description>Entry Size with type Integer in EmbeddedFileParameter shall satisfy possible value predicate: fn:Eval(@Size &gt;= 0)</description>
			<test>SizeHasTypeInteger != true || SizeIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Size with type Integer in EmbeddedFileParameter does not satisfy possible value predicate: fn:Eval(@Size &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream" testNumber="1"/>
			<description>EmbeddedFileStream shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Params, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Mail_MediaTypeParameters' &amp;&amp; elem != 'Params' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EmbeddedFileStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Mail_MediaTypeParameters' &amp;&amp; elem != 'Params' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream" testNumber="22"/>
			<description>EmbeddedFileStream shall not contain entries DL, Mail_MediaTypeParameters in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DL' || elem == 'Mail_MediaTypeParameters').length == 0</test>
			<error>
				<message>EmbeddedFileStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DL' || elem == 'Mail_MediaTypeParameters').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in EmbeddedFileStream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in EmbeddedFileStream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in EmbeddedFileStream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in EmbeddedFileStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in EmbeddedFileStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in EmbeddedFileStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-F" testNumber="8"/>
			<description>Entry F in EmbeddedFileStream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in EmbeddedFileStream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in EmbeddedFileStream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in EmbeddedFileStream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in EmbeddedFileStream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in EmbeddedFileStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in EmbeddedFileStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in EmbeddedFileStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FFilter" testNumber="8"/>
			<description>Entry FFilter in EmbeddedFileStream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in EmbeddedFileStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in EmbeddedFileStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in EmbeddedFileStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in EmbeddedFileStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in EmbeddedFileStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Filter" testNumber="8"/>
			<description>Entry Filter in EmbeddedFileStream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in EmbeddedFileStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in EmbeddedFileStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in EmbeddedFileStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in EmbeddedFileStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in EmbeddedFileStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Length" testNumber="8"/>
			<description>Entry Length in EmbeddedFileStream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in EmbeddedFileStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Length" testNumber="7"/>
			<description>Entry Length in EmbeddedFileStream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in EmbeddedFileStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Params" testNumber="8"/>
			<description>Entry Params in EmbeddedFileStream shall have type Dictionary</description>
			<test>containsParams == false || ParamsHasTypeDictionary == true</test>
			<error>
				<message>Entry Params in EmbeddedFileStream has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParamsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Subtype" testNumber="8"/>
			<description>Entry Subtype in EmbeddedFileStream shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in EmbeddedFileStream has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Type" testNumber="8"/>
			<description>Entry Type in EmbeddedFileStream shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in EmbeddedFileStream has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEmbeddedFileStream">
			<id specification="PDF_1_4" clause="EmbeddedFileStream-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in EmbeddedFileStream shall have value EmbeddedFile</description>
			<test>TypeHasTypeName != true || TypeNameValue == "EmbeddedFile"</test>
			<error>
				<message>Entry Type with type Name in EmbeddedFileStream has incorrect value %1 instead of EmbeddedFile</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding" testNumber="1"/>
			<description>Encoding shall not contain entries except BaseEncoding, Differences, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseEncoding' &amp;&amp; elem != 'Differences' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Encoding contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseEncoding' &amp;&amp; elem != 'Differences' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding-BaseEncoding" testNumber="8"/>
			<description>Entry BaseEncoding in Encoding shall have type Name</description>
			<test>containsBaseEncoding == false || BaseEncodingHasTypeName == true</test>
			<error>
				<message>Entry BaseEncoding in Encoding has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseEncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding-BaseEncoding-Name" testNumber="6"/>
			<description>Entry BaseEncoding with type Name in Encoding shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>BaseEncodingHasTypeName != true || BaseEncodingNameValue == "MacRomanEncoding" || BaseEncodingNameValue == "MacExpertEncoding" || BaseEncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry BaseEncoding with type Name in Encoding has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>BaseEncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding-Differences" testNumber="8"/>
			<description>Entry Differences in Encoding shall have type Array</description>
			<test>containsDifferences == false || DifferencesHasTypeArray == true</test>
			<error>
				<message>Entry Differences in Encoding has type %1 instead of type Array</message>
				<arguments>
					<argument>DifferencesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding-Type" testNumber="8"/>
			<description>Entry Type in Encoding shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Encoding has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncoding">
			<id specification="PDF_1_4" clause="Encoding-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Encoding shall have value Encoding</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Encoding"</test>
			<error>
				<message>Entry Type with type Name in Encoding has incorrect value %1 instead of Encoding</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey" testNumber="1"/>
			<description>EncryptionPublicKey shall not contain entries except Filter, Length, P, Recipients, SubFilter, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Recipients' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EncryptionPublicKey contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Recipients' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey" testNumber="22"/>
			<description>EncryptionPublicKey shall not contain entries CF, EFF, EncryptMetadata, KDFSalt, StmF, StrF in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EFF' || elem == 'EncryptMetadata' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'StrF').length == 0</test>
			<error>
				<message>EncryptionPublicKey contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EFF' || elem == 'EncryptMetadata' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'StrF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Filter" testNumber="8"/>
			<description>Entry Filter in EncryptionPublicKey shall have type Name</description>
			<test>containsFilter == false || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in EncryptionPublicKey has type %1 instead of type Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Filter" testNumber="7"/>
			<description>Entry Filter in EncryptionPublicKey is required</description>
			<test>containsFilter == true</test>
			<error>
				<message>Entry Filter in EncryptionPublicKey is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in EncryptionPublicKey shall have one of values: Adobe.PubSec, AdobePPKLite</description>
			<test>FilterHasTypeName != true || FilterNameValue == "Adobe.PubSec" || FilterNameValue == "AdobePPKLite"</test>
			<error>
				<message>Entry Filter with type Name in EncryptionPublicKey has incorrect value %1 instead of Adobe.PubSec, AdobePPKLite</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Length" testNumber="8"/>
			<description>Entry Length in EncryptionPublicKey shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in EncryptionPublicKey has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Length-Integer" testNumber="14"/>
			<description>Entry Length with type Integer in EncryptionPublicKey shall satisfy possible value predicate: fn:Eval((@Length &gt;= 40) &amp;&amp; (@Length &lt;= 128) &amp;&amp; ((@Length mod 8) == 0))</description>
			<test>LengthHasTypeInteger != true || (LengthIntegerValue &gt;= 40) &amp;&amp; (LengthIntegerValue &lt;= 128) &amp;&amp; ((LengthIntegerValue % 8) == 0)</test>
			<error>
				<message>Entry Length with type Integer in EncryptionPublicKey does not satisfy possible value predicate: fn:Eval((@Length &gt;= 40) &amp;&amp; (@Length &lt;= 128) &amp;&amp; ((@Length mod 8) == 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-P" testNumber="8"/>
			<description>Entry P in EncryptionPublicKey shall have type Bitmask</description>
			<test>containsP == false || PHasTypeBitmask == true</test>
			<error>
				<message>Entry P in EncryptionPublicKey has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-P-Bitmask" testNumber="9"/>
			<description>Entry P with type Bitmask in EncryptionPublicKey shall satisfy special case: fn:Eval(fn:BitsClear(13, 32))</description>
			<test>PHasTypeBitmask != true || ((PBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry P with type Bitmask in EncryptionPublicKey does not satisfy special case: fn:Eval(fn:BitsClear(13, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Recipients" testNumber="8"/>
			<description>Entry Recipients in EncryptionPublicKey shall have type Array</description>
			<test>containsRecipients == false || RecipientsHasTypeArray == true</test>
			<error>
				<message>Entry Recipients in EncryptionPublicKey has type %1 instead of type Array</message>
				<arguments>
					<argument>RecipientsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-Recipients" testNumber="11"/>
			<description>Entry Recipients in EncryptionPublicKey is required, when (@SubFilter == adbe.pkcs7.s3) || (@SubFilter == adbe.pkcs7.s4)</description>
			<test>containsRecipients == true || ((SubFilterNameValue != "adbe.pkcs7.s3") &amp;&amp; (SubFilterNameValue != "adbe.pkcs7.s4"))</test>
			<error>
				<message>Entry Recipients in EncryptionPublicKey is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-SubFilter" testNumber="8"/>
			<description>Entry SubFilter in EncryptionPublicKey shall have type Name</description>
			<test>containsSubFilter == false || SubFilterHasTypeName == true</test>
			<error>
				<message>Entry SubFilter in EncryptionPublicKey has type %1 instead of type Name</message>
				<arguments>
					<argument>SubFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-SubFilter-Name" testNumber="6"/>
			<description>Entry SubFilter with type Name in EncryptionPublicKey shall have one of values: adbe.pkcs7.s3, adbe.pkcs7.s4</description>
			<test>SubFilterHasTypeName != true || SubFilterNameValue == "adbe.pkcs7.s3" || SubFilterNameValue == "adbe.pkcs7.s4"</test>
			<error>
				<message>Entry SubFilter with type Name in EncryptionPublicKey has incorrect value %1 instead of adbe.pkcs7.s3, adbe.pkcs7.s4</message>
				<arguments>
					<argument>SubFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-V" testNumber="8"/>
			<description>Entry V in EncryptionPublicKey shall have type Integer</description>
			<test>containsV == false || VHasTypeInteger == true</test>
			<error>
				<message>Entry V in EncryptionPublicKey has type %1 instead of type Integer</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-V" testNumber="7"/>
			<description>Entry V in EncryptionPublicKey is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in EncryptionPublicKey is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-V-Integer" testNumber="19"/>
			<description>Entry V with type Integer in EncryptionPublicKey should not have deprecated value 0</description>
			<test>VIntegerValue != 0</test>
			<error>
				<message>Entry V with type Integer in EncryptionPublicKey has deprecated value 0</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionPublicKey">
			<id specification="PDF_1_4" clause="EncryptionPublicKey-V-Integer" testNumber="6"/>
			<description>Entry V with type Integer in EncryptionPublicKey shall have one of values: 0, 1, 2, 3</description>
			<test>VHasTypeInteger != true || VIntegerValue == 0 || VIntegerValue == 1 || VIntegerValue == 2 || VIntegerValue == 3</test>
			<error>
				<message>Entry V with type Integer in EncryptionPublicKey has incorrect value %1 instead of 0, 1, 2, 3</message>
				<arguments>
					<argument>VIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard" testNumber="1"/>
			<description>EncryptionStandard shall not contain entries except EFF, Filter, Length, O, OE, P, Perms, R, SubFilter, U, UE, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'O' &amp;&amp; elem != 'OE' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'R' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'U' &amp;&amp; elem != 'UE' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>EncryptionStandard contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CF' &amp;&amp; elem != 'EFF' &amp;&amp; elem != 'EncryptMetadata' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'KDFSalt' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'O' &amp;&amp; elem != 'OE' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Perms' &amp;&amp; elem != 'R' &amp;&amp; elem != 'StmF' &amp;&amp; elem != 'StrF' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'U' &amp;&amp; elem != 'UE' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard" testNumber="22"/>
			<description>EncryptionStandard shall not contain entries CF, EncryptMetadata, KDFSalt, StmF, StrF in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EncryptMetadata' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'StrF').length == 0</test>
			<error>
				<message>EncryptionStandard contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'CF' || elem == 'EncryptMetadata' || elem == 'KDFSalt' || elem == 'StmF' || elem == 'StrF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-EFF" testNumber="8"/>
			<description>Entry EFF in EncryptionStandard shall have type Name</description>
			<test>containsEFF == false || EFFHasTypeName == true</test>
			<error>
				<message>Entry EFF in EncryptionStandard has type %1 instead of type Name</message>
				<arguments>
					<argument>EFFType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Filter" testNumber="8"/>
			<description>Entry Filter in EncryptionStandard shall have type Name</description>
			<test>containsFilter == false || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in EncryptionStandard has type %1 instead of type Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Filter" testNumber="7"/>
			<description>Entry Filter in EncryptionStandard is required</description>
			<test>containsFilter == true</test>
			<error>
				<message>Entry Filter in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in EncryptionStandard shall have value Standard</description>
			<test>FilterHasTypeName != true || FilterNameValue == "Standard"</test>
			<error>
				<message>Entry Filter with type Name in EncryptionStandard has incorrect value %1 instead of Standard</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Length" testNumber="8"/>
			<description>Entry Length in EncryptionStandard shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in EncryptionStandard has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Length-Integer" testNumber="14"/>
			<description>Entry Length with type Integer in EncryptionStandard shall satisfy possible value predicate: fn:Eval((@Length &gt;= 40) &amp;&amp; ((@Length &lt;= 128) || fn:Extension(ADBE_Extn3, (@Length &lt;= 256))) &amp;&amp; ((@Length mod 8) == 0))</description>
			<test>LengthHasTypeInteger != true || (LengthIntegerValue &gt;= 40) &amp;&amp; ((LengthIntegerValue &lt;= 128) || ((hasExtensionADBE_Extn3 == true) &amp;&amp; (LengthIntegerValue &lt;= 256))) &amp;&amp; ((LengthIntegerValue % 8) == 0)</test>
			<error>
				<message>Entry Length with type Integer in EncryptionStandard does not satisfy possible value predicate: fn:Eval((@Length &gt;= 40) &amp;&amp; ((@Length &lt;= 128) || fn:Extension(ADBE_Extn3, (@Length &lt;= 256))) &amp;&amp; ((@Length mod 8) == 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-O" testNumber="8"/>
			<description>Entry O in EncryptionStandard shall have type StringByte</description>
			<test>containsO == false || OHasTypeStringByte == true</test>
			<error>
				<message>Entry O in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-O" testNumber="7"/>
			<description>Entry O in EncryptionStandard is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-O-StringByte" testNumber="9"/>
			<description>Entry O with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(O) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(O) == 48))))</description>
			<test>OHasTypeStringByte != true || (((RHasTypeInteger == false || (RIntegerValue &lt;= 4)) &amp;&amp; (OStringSize == 32)) || ((RHasTypeInteger == false || ((RIntegerValue == 5) || (RIntegerValue == 6))) &amp;&amp; (OStringSize == 48)))</test>
			<error>
				<message>Entry O with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(O) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(O) == 48))))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-OE" testNumber="8"/>
			<description>Entry OE in EncryptionStandard shall have type StringByte</description>
			<test>containsOE == false || OEHasTypeStringByte == true</test>
			<error>
				<message>Entry OE in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>OEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-OE" testNumber="11"/>
			<description>Entry OE in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsOE == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry OE in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-OE-StringByte" testNumber="9"/>
			<description>Entry OE with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (fn:StringLength(OE) == 32))</description>
			<test>OEHasTypeStringByte != true || (OEStringSize == 32)</test>
			<error>
				<message>Entry OE with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (fn:StringLength(OE) == 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-P" testNumber="8"/>
			<description>Entry P in EncryptionStandard shall have type Bitmask</description>
			<test>containsP == false || PHasTypeBitmask == true</test>
			<error>
				<message>Entry P in EncryptionStandard has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-P" testNumber="7"/>
			<description>Entry P in EncryptionStandard is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-P-Bitmask" testNumber="9"/>
			<description>Entry P with type Bitmask in EncryptionStandard shall satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitsSet(7, 8) &amp;&amp; fn:BitsSet(13, 32))</description>
			<test>PHasTypeBitmask != true || (((PBitmaskValue &gt;&gt; 0 &amp; 1) == 0 &amp;&amp; (PBitmaskValue &gt;&gt; 1 &amp; 1) == 0) &amp;&amp; ((PBitmaskValue &gt;&gt; 6 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 7 &amp; 1) == 1) &amp;&amp; ((PBitmaskValue &gt;&gt; 12 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 13 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 14 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 17 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 18 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 19 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 20 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 21 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 22 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 23 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 24 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 25 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 26 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 27 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 28 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 29 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 30 &amp; 1) == 1 &amp;&amp; (PBitmaskValue &gt;&gt; 31 &amp; 1) == 1))</test>
			<error>
				<message>Entry P with type Bitmask in EncryptionStandard does not satisfy special case: fn:Eval(fn:BitsClear(1, 2) &amp;&amp; fn:BitsSet(7, 8) &amp;&amp; fn:BitsSet(13, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Perms" testNumber="8"/>
			<description>Entry Perms in EncryptionStandard shall have type StringByte</description>
			<test>containsPerms == false || PermsHasTypeStringByte == true</test>
			<error>
				<message>Entry Perms in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PermsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-Perms" testNumber="11"/>
			<description>Entry Perms in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsPerms == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry Perms in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R" testNumber="8"/>
			<description>Entry R in EncryptionStandard shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in EncryptionStandard has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R" testNumber="7"/>
			<description>Entry R in EncryptionStandard is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R-Integer-2" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 2, if this object satisfies condition @V &lt; 2</description>
			<test>VHasTypeInteger == false || ((VIntegerValue &gt;= 2) || RIntegerValue == 2)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 2</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R-Integer-3" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 3, if this object satisfies condition (@V == 2) || (@V == 3)</description>
			<test>VHasTypeInteger == false || (((VIntegerValue != 2) &amp;&amp; (VIntegerValue != 3)) || RIntegerValue == 3)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R-Integer-4" testNumber="15"/>
			<description>Entry R in EncryptionStandard shall have Integer value 4, if this object satisfies condition @V == 4</description>
			<test>VHasTypeInteger == false || ((VIntegerValue != 4) || RIntegerValue == 4)</test>
			<error>
				<message>Entry R in EncryptionStandard does not have value 4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-R-Integer" testNumber="6"/>
			<description>Entry R with type Integer in EncryptionStandard shall have one of values: 2, 3, 4</description>
			<test>RHasTypeInteger != true || RIntegerValue == 2 || RIntegerValue == 3 || RIntegerValue == 4</test>
			<error>
				<message>Entry R with type Integer in EncryptionStandard has incorrect value %1 instead of 2, 3, 4</message>
				<arguments>
					<argument>RIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-SubFilter" testNumber="8"/>
			<description>Entry SubFilter in EncryptionStandard shall have type Name</description>
			<test>containsSubFilter == false || SubFilterHasTypeName == true</test>
			<error>
				<message>Entry SubFilter in EncryptionStandard has type %1 instead of type Name</message>
				<arguments>
					<argument>SubFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-U" testNumber="8"/>
			<description>Entry U in EncryptionStandard shall have type StringByte</description>
			<test>containsU == false || UHasTypeStringByte == true</test>
			<error>
				<message>Entry U in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-U" testNumber="7"/>
			<description>Entry U in EncryptionStandard is required</description>
			<test>containsU == true</test>
			<error>
				<message>Entry U in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-U-StringByte" testNumber="9"/>
			<description>Entry U with type StringByte in EncryptionStandard shall satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(U) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(U) == 48))))</description>
			<test>UHasTypeStringByte != true || (((RHasTypeInteger == false || (RIntegerValue &lt;= 4)) &amp;&amp; (UStringSize == 32)) || ((RHasTypeInteger == false || ((RIntegerValue == 5) || (RIntegerValue == 6))) &amp;&amp; (UStringSize == 48)))</test>
			<error>
				<message>Entry U with type StringByte in EncryptionStandard does not satisfy special case: fn:Eval(fn:AlwaysUnencrypted() &amp;&amp; (((@R &lt;= 4) &amp;&amp; (fn:StringLength(U) == 32)) || (((@R == 5) || (@R == 6)) &amp;&amp; (fn:StringLength(U) == 48))))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-UE" testNumber="8"/>
			<description>Entry UE in EncryptionStandard shall have type StringByte</description>
			<test>containsUE == false || UEHasTypeStringByte == true</test>
			<error>
				<message>Entry UE in EncryptionStandard has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-UE" testNumber="11"/>
			<description>Entry UE in EncryptionStandard is required, when (@R == 5) || (@R == 6)</description>
			<test>RHasTypeInteger == false || (containsUE == true || ((RIntegerValue != 5) &amp;&amp; (RIntegerValue != 6)))</test>
			<error>
				<message>Entry UE in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-V" testNumber="8"/>
			<description>Entry V in EncryptionStandard shall have type Integer</description>
			<test>containsV == false || VHasTypeInteger == true</test>
			<error>
				<message>Entry V in EncryptionStandard has type %1 instead of type Integer</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-V" testNumber="7"/>
			<description>Entry V in EncryptionStandard is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in EncryptionStandard is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-V-Integer" testNumber="19"/>
			<description>Entry V with type Integer in EncryptionStandard should not have deprecated value 0</description>
			<test>VIntegerValue != 0</test>
			<error>
				<message>Entry V with type Integer in EncryptionStandard has deprecated value 0</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AEncryptionStandard">
			<id specification="PDF_1_4" clause="EncryptionStandard-V-Integer" testNumber="6"/>
			<description>Entry V with type Integer in EncryptionStandard shall have one of values: 0, 1, 2, 3</description>
			<test>VHasTypeInteger != true || VIntegerValue == 0 || VIntegerValue == 1 || VIntegerValue == 2 || VIntegerValue == 3</test>
			<error>
				<message>Entry V with type Integer in EncryptionStandard has incorrect value %1 instead of 0, 1, 2, 3</message>
				<arguments>
					<argument>VIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFDDictEntry">
			<id specification="PDF_1_4" clause="FDDictEntry" testNumber="8"/>
			<description>Entry in FDDict shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in FDDict has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field" testNumber="1"/>
			<description>Field shall not contain entries except AA, Ff, Kids, Parent, T, TM, TU</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Field contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-AA" testNumber="8"/>
			<description>Entry AA in Field shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in Field has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-Ff" testNumber="8"/>
			<description>Entry Ff in Field shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in Field has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in Field shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in Field does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-Kids" testNumber="8"/>
			<description>Entry Kids in Field shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in Field has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in Field shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in Field is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-Parent" testNumber="8"/>
			<description>Entry Parent in Field shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in Field has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-T" testNumber="8"/>
			<description>Entry T in Field shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in Field has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-TM" testNumber="8"/>
			<description>Entry TM in Field shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in Field has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AField">
			<id specification="PDF_1_4" clause="Field-TU" testNumber="8"/>
			<description>Entry TU in Field shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in Field has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox" testNumber="1"/>
			<description>FieldBtnCheckbox shall not contain entries except AA, DA, DV, FT, Ff, Kids, Opt, Parent, Q, T, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox" testNumber="22"/>
			<description>FieldBtnCheckbox shall not contain entries DS, RV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').length == 0</test>
			<error>
				<message>FieldBtnCheckbox contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-AA" testNumber="8"/>
			<description>Entry AA in FieldBtnCheckbox shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnCheckbox shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnCheckbox has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnCheckbox is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnCheckbox shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnCheckbox shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnCheckbox is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnCheckbox is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnCheckbox shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnCheckbox has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnCheckbox shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnCheckbox has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnCheckbox shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnCheckbox does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitsClear(16, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnCheckbox shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Opt" testNumber="8"/>
			<description>Entry Opt in FieldBtnCheckbox shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in FieldBtnCheckbox has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnCheckbox shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnCheckbox is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnCheckbox shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnCheckbox has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnCheckbox shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnCheckbox has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnCheckbox shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnCheckbox has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-T" testNumber="8"/>
			<description>Entry T in FieldBtnCheckbox shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-TM" testNumber="8"/>
			<description>Entry TM in FieldBtnCheckbox shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-TU" testNumber="8"/>
			<description>Entry TU in FieldBtnCheckbox shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldBtnCheckbox has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnCheckbox">
			<id specification="PDF_1_4" clause="FieldBtnCheckbox-V" testNumber="8"/>
			<description>Entry V in FieldBtnCheckbox shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnCheckbox has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush" testNumber="1"/>
			<description>FieldBtnPush shall not contain entries except AA, DA, DV, FT, Ff, Kids, Parent, Q, T, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush" testNumber="22"/>
			<description>FieldBtnPush shall not contain entries DS, RV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').length == 0</test>
			<error>
				<message>FieldBtnPush contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-AA" testNumber="8"/>
			<description>Entry AA in FieldBtnPush shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnPush shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnPush has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnPush is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnPush shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnPush shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnPush is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnPush is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnPush shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnPush has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnPush shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnPush has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnPush shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnPush does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(16) &amp;&amp; fn:BitSet(17) &amp;&amp; fn:BitsClear(18, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnPush shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnPush has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnPush shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnPush is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnPush shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnPush has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnPush shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnPush has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnPush shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnPush has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-T" testNumber="8"/>
			<description>Entry T in FieldBtnPush shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-TM" testNumber="8"/>
			<description>Entry TM in FieldBtnPush shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-TU" testNumber="8"/>
			<description>Entry TU in FieldBtnPush shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldBtnPush has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnPush">
			<id specification="PDF_1_4" clause="FieldBtnPush-V" testNumber="8"/>
			<description>Entry V in FieldBtnPush shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnPush has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio" testNumber="1"/>
			<description>FieldBtnRadio shall not contain entries except AA, DA, DV, FT, Ff, Kids, Opt, Parent, Q, T, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio" testNumber="22"/>
			<description>FieldBtnRadio shall not contain entries DS, RV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').length == 0</test>
			<error>
				<message>FieldBtnRadio contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-AA" testNumber="8"/>
			<description>Entry AA in FieldBtnRadio shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-DA" testNumber="8"/>
			<description>Entry DA in FieldBtnRadio shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldBtnRadio has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-DA" testNumber="7"/>
			<description>Entry DA in FieldBtnRadio is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-DV" testNumber="8"/>
			<description>Entry DV in FieldBtnRadio shall have type Name</description>
			<test>containsDV == false || DVHasTypeName == true</test>
			<error>
				<message>Entry DV in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-FT" testNumber="8"/>
			<description>Entry FT in FieldBtnRadio shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-FT" testNumber="7"/>
			<description>Entry FT in FieldBtnRadio is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldBtnRadio is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldBtnRadio shall have value Btn</description>
			<test>FTHasTypeName != true || FTNameValue == "Btn"</test>
			<error>
				<message>Entry FT with type Name in FieldBtnRadio has incorrect value %1 instead of Btn</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Ff" testNumber="8"/>
			<description>Entry Ff in FieldBtnRadio shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldBtnRadio has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldBtnRadio shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 1 &amp;&amp; ((FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldBtnRadio does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitSet(16) &amp;&amp; fn:BitsClear(17, 25) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Kids" testNumber="8"/>
			<description>Entry Kids in FieldBtnRadio shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Opt" testNumber="8"/>
			<description>Entry Opt in FieldBtnRadio shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in FieldBtnRadio has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldBtnRadio shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldBtnRadio is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Parent" testNumber="8"/>
			<description>Entry Parent in FieldBtnRadio shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldBtnRadio has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Q" testNumber="8"/>
			<description>Entry Q in FieldBtnRadio shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldBtnRadio has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldBtnRadio shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldBtnRadio has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-T" testNumber="8"/>
			<description>Entry T in FieldBtnRadio shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-TM" testNumber="8"/>
			<description>Entry TM in FieldBtnRadio shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-TU" testNumber="8"/>
			<description>Entry TU in FieldBtnRadio shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldBtnRadio has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldBtnRadio">
			<id specification="PDF_1_4" clause="FieldBtnRadio-V" testNumber="8"/>
			<description>Entry V in FieldBtnRadio shall have type Name</description>
			<test>containsV == false || VHasTypeName == true</test>
			<error>
				<message>Entry V in FieldBtnRadio has type %1 instead of type Name</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice" testNumber="1"/>
			<description>FieldChoice shall not contain entries except AA, DA, DV, FT, Ff, I, Kids, Opt, Parent, Q, T, TI, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Opt' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TI' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice" testNumber="22"/>
			<description>FieldChoice shall not contain entries DS, RV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').length == 0</test>
			<error>
				<message>FieldChoice contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-AA" testNumber="8"/>
			<description>Entry AA in FieldChoice shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-DA" testNumber="8"/>
			<description>Entry DA in FieldChoice shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldChoice has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-DA" testNumber="7"/>
			<description>Entry DA in FieldChoice is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-DV" testNumber="8"/>
			<description>Entry DV in FieldChoice shall have one of types: Array, StringText</description>
			<test>containsDV == false || DVHasTypeArray == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in FieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-FT" testNumber="8"/>
			<description>Entry FT in FieldChoice shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldChoice has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-FT" testNumber="7"/>
			<description>Entry FT in FieldChoice is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldChoice is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldChoice shall have value Ch</description>
			<test>FTHasTypeName != true || FTNameValue == "Ch"</test>
			<error>
				<message>Entry FT with type Name in FieldChoice has incorrect value %1 instead of Ch</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Ff" testNumber="8"/>
			<description>Entry Ff in FieldChoice shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldChoice has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldChoice shall satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldChoice does not satisfy special case: fn:Eval(fn:BitsClear(4, 14) &amp;&amp; fn:BitClear(21) &amp;&amp; fn:BitsClear(24, 26) &amp;&amp; fn:BitClear(27) &amp;&amp; fn:BitsClear(28, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-I" testNumber="8"/>
			<description>Entry I in FieldChoice shall have type Array</description>
			<test>containsI == false || IHasTypeArray == true</test>
			<error>
				<message>Entry I in FieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-I-Array" testNumber="9"/>
			<description>Entry I with type Array in FieldChoice shall satisfy special case: fn:Eval(fn:ArraySortAscending(I, 1))</description>
			<test>IHasTypeArray != true || (isIArraySortAscending1 == true)</test>
			<error>
				<message>Entry I with type Array in FieldChoice does not satisfy special case: fn:Eval(fn:ArraySortAscending(I, 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Kids" testNumber="8"/>
			<description>Entry Kids in FieldChoice shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Opt" testNumber="8"/>
			<description>Entry Opt in FieldChoice shall have type Array</description>
			<test>containsOpt == false || OptHasTypeArray == true</test>
			<error>
				<message>Entry Opt in FieldChoice has type %1 instead of type Array</message>
				<arguments>
					<argument>OptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldChoice shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldChoice is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Parent" testNumber="8"/>
			<description>Entry Parent in FieldChoice shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldChoice has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Q" testNumber="8"/>
			<description>Entry Q in FieldChoice shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldChoice shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldChoice has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-T" testNumber="8"/>
			<description>Entry T in FieldChoice shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-TI" testNumber="8"/>
			<description>Entry TI in FieldChoice shall have type Integer</description>
			<test>containsTI == false || TIHasTypeInteger == true</test>
			<error>
				<message>Entry TI in FieldChoice has type %1 instead of type Integer</message>
				<arguments>
					<argument>TIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-TI-Integer" testNumber="14"/>
			<description>Entry TI with type Integer in FieldChoice shall satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</description>
			<test>TIHasTypeInteger != true || (TIIntegerValue &gt;= 0) &amp;&amp; (OptHasTypeArray == false || (TIIntegerValue &lt; OptArraySize))</test>
			<error>
				<message>Entry TI with type Integer in FieldChoice does not satisfy possible value predicate: fn:Eval((@TI &gt;= 0) &amp;&amp; (@TI &lt; fn:ArrayLength(Opt)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-TM" testNumber="8"/>
			<description>Entry TM in FieldChoice shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-TU" testNumber="8"/>
			<description>Entry TU in FieldChoice shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldChoice has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldChoice">
			<id specification="PDF_1_4" clause="FieldChoice-V" testNumber="8"/>
			<description>Entry V in FieldChoice shall have one of types: Array, StringText</description>
			<test>containsV == false || VHasTypeArray == true || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in FieldChoice has type %1 instead of one of types: Array, StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig" testNumber="1"/>
			<description>FieldSig shall not contain entries except AA, DA, DV, FT, Ff, Kids, Parent, Q, T, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Lock' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'SV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldSig contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'Lock' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'SV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig" testNumber="22"/>
			<description>FieldSig shall not contain entries DS, Lock, RV, SV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'Lock' || elem == 'RV' || elem == 'SV').length == 0</test>
			<error>
				<message>FieldSig contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'Lock' || elem == 'RV' || elem == 'SV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-AA" testNumber="8"/>
			<description>Entry AA in FieldSig shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-DA" testNumber="8"/>
			<description>Entry DA in FieldSig shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldSig has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-DV-Dictionary" testNumber="17"/>
			<description>Entry DV with type Dictionary in FieldSig shall be one of objects Signature, DocTimeStamp</description>
			<test>DVHasTypeDictionary != true || DV_size == 1</test>
			<error>
				<message>Entry DV with type Dictionary in FieldSig is not one of objects Signature, DocTimeStamp</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-DV" testNumber="8"/>
			<description>Entry DV in FieldSig shall have type Dictionary</description>
			<test>containsDV == false || DVHasTypeDictionary == true</test>
			<error>
				<message>Entry DV in FieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-FT" testNumber="8"/>
			<description>Entry FT in FieldSig shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldSig has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-FT" testNumber="7"/>
			<description>Entry FT in FieldSig is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldSig is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldSig shall have value Sig</description>
			<test>FTHasTypeName != true || FTNameValue == "Sig"</test>
			<error>
				<message>Entry FT with type Name in FieldSig has incorrect value %1 instead of Sig</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Ff" testNumber="8"/>
			<description>Entry Ff in FieldSig shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldSig has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldSig shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FfHasTypeBitmask != true || ((FfBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldSig does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Kids" testNumber="8"/>
			<description>Entry Kids in FieldSig shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldSig has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldSig shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldSig is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Parent" testNumber="8"/>
			<description>Entry Parent in FieldSig shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Q" testNumber="8"/>
			<description>Entry Q in FieldSig shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldSig has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldSig shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldSig has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-T" testNumber="8"/>
			<description>Entry T in FieldSig shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-TM" testNumber="8"/>
			<description>Entry TM in FieldSig shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-TU" testNumber="8"/>
			<description>Entry TU in FieldSig shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldSig has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-V-Dictionary" testNumber="17"/>
			<description>Entry V with type Dictionary in FieldSig shall be one of objects Signature, DocTimeStamp</description>
			<test>VHasTypeDictionary != true || V_size == 1</test>
			<error>
				<message>Entry V with type Dictionary in FieldSig is not one of objects Signature, DocTimeStamp</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldSig">
			<id specification="PDF_1_4" clause="FieldSig-V" testNumber="8"/>
			<description>Entry V in FieldSig shall have type Dictionary</description>
			<test>containsV == false || VHasTypeDictionary == true</test>
			<error>
				<message>Entry V in FieldSig has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx" testNumber="1"/>
			<description>FieldTx shall not contain entries except AA, DA, DV, FT, Ff, Kids, MaxLen, Parent, Q, T, TM, TU, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DS' &amp;&amp; elem != 'DV' &amp;&amp; elem != 'FT' &amp;&amp; elem != 'Ff' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MaxLen' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'RV' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TM' &amp;&amp; elem != 'TU' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx" testNumber="22"/>
			<description>FieldTx shall not contain entries DS, RV in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').length == 0</test>
			<error>
				<message>FieldTx contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DS' || elem == 'RV').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-AA" testNumber="8"/>
			<description>Entry AA in FieldTx shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in FieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-DA" testNumber="8"/>
			<description>Entry DA in FieldTx shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in FieldTx has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-DA" testNumber="7"/>
			<description>Entry DA in FieldTx is required</description>
			<test>containsDA == true</test>
			<error>
				<message>Entry DA in FieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-DV" testNumber="8"/>
			<description>Entry DV in FieldTx shall have one of types: Stream, StringText</description>
			<test>containsDV == false || DVHasTypeStream == true || DVHasTypeStringText == true</test>
			<error>
				<message>Entry DV in FieldTx has type %1 instead of one of types: Stream, StringText</message>
				<arguments>
					<argument>DVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-DV-Stream" testNumber="10"/>
			<description>Entry DV with type Stream in FieldTx shall be indirect</description>
			<test>DVHasTypeStream != true || isDVIndirect == true</test>
			<error>
				<message>Entry DV with type Stream in FieldTx is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-FT" testNumber="8"/>
			<description>Entry FT in FieldTx shall have type Name</description>
			<test>containsFT == false || FTHasTypeName == true</test>
			<error>
				<message>Entry FT in FieldTx has type %1 instead of type Name</message>
				<arguments>
					<argument>FTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-FT" testNumber="7"/>
			<description>Entry FT in FieldTx is required</description>
			<test>containsFT == true</test>
			<error>
				<message>Entry FT in FieldTx is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-FT-Name" testNumber="6"/>
			<description>Entry FT with type Name in FieldTx shall have value Tx</description>
			<test>FTHasTypeName != true || FTNameValue == "Tx"</test>
			<error>
				<message>Entry FT with type Name in FieldTx has incorrect value %1 instead of Tx</message>
				<arguments>
					<argument>FTNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Ff" testNumber="8"/>
			<description>Entry Ff in FieldTx shall have type Bitmask</description>
			<test>containsFf == false || FfHasTypeBitmask == true</test>
			<error>
				<message>Entry Ff in FieldTx has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FfType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Ff-Bitmask" testNumber="9"/>
			<description>Entry Ff with type Bitmask in FieldTx shall satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</description>
			<test>FfHasTypeBitmask != true || (((FfBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 19 &amp; 1) == 0) &amp;&amp; (FfBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; ((FfBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 25 &amp; 1) == 0) &amp;&amp; ((FfBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FfBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Ff with type Bitmask in FieldTx does not satisfy special case: fn:Eval(fn:BitsClear(15, 20) &amp;&amp; fn:BitClear(22) &amp;&amp; fn:BitsClear(25, 26) &amp;&amp; fn:BitsClear(27, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Kids" testNumber="8"/>
			<description>Entry Kids in FieldTx shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in FieldTx has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-MaxLen" testNumber="8"/>
			<description>Entry MaxLen in FieldTx shall have type Integer</description>
			<test>containsMaxLen == false || MaxLenHasTypeInteger == true</test>
			<error>
				<message>Entry MaxLen in FieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>MaxLenType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-MaxLen-Integer" testNumber="9"/>
			<description>Entry MaxLen with type Integer in FieldTx shall satisfy special case: fn:Eval(@MaxLen &gt;= 0)</description>
			<test>MaxLenHasTypeInteger != true || (MaxLenIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry MaxLen with type Integer in FieldTx does not satisfy special case: fn:Eval(@MaxLen &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in FieldTx shall be one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in FieldTx is not one of objects FieldTx, FieldBtnPush, FieldBtnCheckbox, FieldBtnRadio, FieldChoice, FieldSig, Field, AnnotWidgetFieldTx, AnnotWidgetFieldBtnPush, AnnotWidgetFieldBtnCheckbox, AnnotWidgetFieldBtnRadio, AnnotWidgetFieldChoice, AnnotWidgetFieldSig, AnnotWidgetField</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Parent" testNumber="8"/>
			<description>Entry Parent in FieldTx shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in FieldTx has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Q" testNumber="8"/>
			<description>Entry Q in FieldTx shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in FieldTx has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in FieldTx shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in FieldTx has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-T" testNumber="8"/>
			<description>Entry T in FieldTx shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-TM" testNumber="8"/>
			<description>Entry TM in FieldTx shall have type StringText</description>
			<test>containsTM == false || TMHasTypeStringText == true</test>
			<error>
				<message>Entry TM in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-TU" testNumber="8"/>
			<description>Entry TU in FieldTx shall have type StringText</description>
			<test>containsTU == false || TUHasTypeStringText == true</test>
			<error>
				<message>Entry TU in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>TUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFieldTx">
			<id specification="PDF_1_4" clause="FieldTx-V" testNumber="8"/>
			<description>Entry V in FieldTx shall have type StringText</description>
			<test>containsV == false || VHasTypeStringText == true</test>
			<error>
				<message>Entry V in FieldTx has type %1 instead of type StringText</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecEF">
			<id specification="PDF_1_4" clause="FileSpecEF" testNumber="1"/>
			<description>FileSpecEF shall not contain entries except F</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'UF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileSpecEF contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'UF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecEF">
			<id specification="PDF_1_4" clause="FileSpecEF" testNumber="22"/>
			<description>FileSpecEF shall not contain entry UF in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsUF == false</test>
			<error>
				<message>FileSpecEF contains entry UF</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecEF">
			<id specification="PDF_1_4" clause="FileSpecEF-F" testNumber="8"/>
			<description>Entry F in FileSpecEF shall have type Stream</description>
			<test>containsF == false || FHasTypeStream == true</test>
			<error>
				<message>Entry F in FileSpecEF has type %1 instead of type Stream</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecEF">
			<id specification="PDF_1_4" clause="FileSpecEF-F-Stream" testNumber="10"/>
			<description>Entry F with type Stream in FileSpecEF shall be indirect</description>
			<test>FHasTypeStream != true || isFIndirect == true</test>
			<error>
				<message>Entry F with type Stream in FileSpecEF is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecRF">
			<id specification="PDF_1_4" clause="FileSpecRF" testNumber="1"/>
			<description>FileSpecRF shall not contain entries except F</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'UF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileSpecRF contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'UF' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecRF">
			<id specification="PDF_1_4" clause="FileSpecRF" testNumber="22"/>
			<description>FileSpecRF shall not contain entry UF in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsUF == false</test>
			<error>
				<message>FileSpecRF contains entry UF</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecRF">
			<id specification="PDF_1_4" clause="FileSpecRF-F" testNumber="8"/>
			<description>Entry F in FileSpecRF shall have type Array</description>
			<test>containsF == false || FHasTypeArray == true</test>
			<error>
				<message>Entry F in FileSpecRF has type %1 instead of type Array</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecRF">
			<id specification="PDF_1_4" clause="FileSpecRF-F-Array" testNumber="10"/>
			<description>Entry F with type Array in FileSpecRF shall be indirect</description>
			<test>FHasTypeArray != true || isFIndirect == true</test>
			<error>
				<message>Entry F with type Array in FileSpecRF is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecRF">
			<id specification="PDF_1_4" clause="FileSpecRF-F-Array" testNumber="9"/>
			<description>Entry F with type Array in FileSpecRF shall satisfy special case: fn:Eval((fn:ArrayLength(F) mod 2) == 0)</description>
			<test>FHasTypeArray != true || ((FArraySize % 2) == 0)</test>
			<error>
				<message>Entry F with type Array in FileSpecRF does not satisfy special case: fn:Eval((fn:ArrayLength(F) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification" testNumber="1"/>
			<description>FileSpecification shall not contain entries except DOS, EF, F, FS, ID, Mac, RF, Type, Unix, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AFRelationship' &amp;&amp; elem != 'CI' &amp;&amp; elem != 'DOS' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'EF' &amp;&amp; elem != 'EP' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'RF' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UF' &amp;&amp; elem != 'Unix' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileSpecification contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AFRelationship' &amp;&amp; elem != 'CI' &amp;&amp; elem != 'DOS' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'EF' &amp;&amp; elem != 'EP' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FS' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Mac' &amp;&amp; elem != 'RF' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UF' &amp;&amp; elem != 'Unix' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification" testNumber="22"/>
			<description>FileSpecification shall not contain entries AFRelationship, CI, Desc, EP, Thumb, UF in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AFRelationship' || elem == 'CI' || elem == 'Desc' || elem == 'EP' || elem == 'Thumb' || elem == 'UF').length == 0</test>
			<error>
				<message>FileSpecification contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AFRelationship' || elem == 'CI' || elem == 'Desc' || elem == 'EP' || elem == 'Thumb' || elem == 'UF').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-DOS" testNumber="8"/>
			<description>Entry DOS in FileSpecification shall have type StringByte</description>
			<test>containsDOS == false || DOSHasTypeStringByte == true</test>
			<error>
				<message>Entry DOS in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DOSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-EF" testNumber="8"/>
			<description>Entry EF in FileSpecification shall have type Dictionary</description>
			<test>containsEF == false || EFHasTypeDictionary == true</test>
			<error>
				<message>Entry EF in FileSpecification has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EFType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-EF" testNumber="11"/>
			<description>Entry EF in FileSpecification is required, when fn:IsPresent(RF)</description>
			<test>containsEF == true || (containsRF != true)</test>
			<error>
				<message>Entry EF in FileSpecification is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-F" testNumber="8"/>
			<description>Entry F in FileSpecification shall have type String</description>
			<test>containsF == false || FHasTypeString == true</test>
			<error>
				<message>Entry F in FileSpecification has type %1 instead of type String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-F" testNumber="11"/>
			<description>Entry F in FileSpecification is required, when fn:Not(fn:IsPresent(DOS)) &amp;&amp; fn:Not(fn:IsPresent(Mac)) &amp;&amp; fn:Not(fn:IsPresent(Unix))</description>
			<test>containsF == true || ((containsDOS == true) || (containsMac == true) || (containsUnix == true))</test>
			<error>
				<message>Entry F in FileSpecification is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-FS" testNumber="8"/>
			<description>Entry FS in FileSpecification shall have type Name</description>
			<test>containsFS == false || FSHasTypeName == true</test>
			<error>
				<message>Entry FS in FileSpecification has type %1 instead of type Name</message>
				<arguments>
					<argument>FSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-ID" testNumber="8"/>
			<description>Entry ID in FileSpecification shall have type Array</description>
			<test>containsID == false || entryIDHasTypeArray == true</test>
			<error>
				<message>Entry ID in FileSpecification has type %1 instead of type Array</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-Mac" testNumber="8"/>
			<description>Entry Mac in FileSpecification shall have type StringByte</description>
			<test>containsMac == false || MacHasTypeStringByte == true</test>
			<error>
				<message>Entry Mac in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>MacType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-RF" testNumber="8"/>
			<description>Entry RF in FileSpecification shall have type Dictionary</description>
			<test>containsRF == false || RFHasTypeDictionary == true</test>
			<error>
				<message>Entry RF in FileSpecification has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RFType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-Type" testNumber="8"/>
			<description>Entry Type in FileSpecification shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FileSpecification has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-Type" testNumber="11"/>
			<description>Entry Type in FileSpecification is required, when fn:IsPresent(EF) || fn:IsPresent(RF)</description>
			<test>containsType == true || ((containsEF != true) &amp;&amp; (containsRF != true))</test>
			<error>
				<message>Entry Type in FileSpecification is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FileSpecification shall have value Filespec</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Filespec"</test>
			<error>
				<message>Entry Type with type Name in FileSpecification has incorrect value %1 instead of Filespec</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-Unix" testNumber="8"/>
			<description>Entry Unix in FileSpecification shall have type StringByte</description>
			<test>containsUnix == false || UnixHasTypeStringByte == true</test>
			<error>
				<message>Entry Unix in FileSpecification has type %1 instead of type StringByte</message>
				<arguments>
					<argument>UnixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileSpecification">
			<id specification="PDF_1_4" clause="FileSpecification-V" testNumber="8"/>
			<description>Entry V in FileSpecification shall have type Boolean</description>
			<test>containsV == false || VHasTypeBoolean == true</test>
			<error>
				<message>Entry V in FileSpecification has type %1 instead of type Boolean</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer" testNumber="1"/>
			<description>FileTrailer shall not contain entries except AdditionalStreams, DocChecksum, Encrypt, ID, Info, Prev, Root, Size</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AdditionalStreams' &amp;&amp; elem != 'AuthCode' &amp;&amp; elem != 'DocChecksum' &amp;&amp; elem != 'Encrypt' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'Root' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'XRefStm' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FileTrailer contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AdditionalStreams' &amp;&amp; elem != 'AuthCode' &amp;&amp; elem != 'DocChecksum' &amp;&amp; elem != 'Encrypt' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'Root' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'XRefStm' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer" testNumber="22"/>
			<description>FileTrailer shall not contain entries AuthCode, XRefStm in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AuthCode' || elem == 'XRefStm').length == 0</test>
			<error>
				<message>FileTrailer contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AuthCode' || elem == 'XRefStm').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-AdditionalStreams" testNumber="8"/>
			<description>Entry AdditionalStreams in FileTrailer shall have type Array</description>
			<test>containsAdditionalStreams == false || AdditionalStreamsHasTypeArray == true</test>
			<error>
				<message>Entry AdditionalStreams in FileTrailer has type %1 instead of type Array</message>
				<arguments>
					<argument>AdditionalStreamsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-AdditionalStreams" testNumber="23"/>
			<description>Entry AdditionalStreams in FileTrailer can only be present, if satisfy predicate fn:Extension(OpenOffice)</description>
			<test>containsAdditionalStreams == false || hasExtensionOpenOffice == true</test>
			<error>
				<message>Entry AdditionalStreams in FileTrailer is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-AdditionalStreams-Array" testNumber="10"/>
			<description>Entry AdditionalStreams with type Array in FileTrailer shall be direct</description>
			<test>AdditionalStreamsHasTypeArray != true || isAdditionalStreamsIndirect == false</test>
			<error>
				<message>Entry AdditionalStreams with type Array in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-AdditionalStreams-Array" testNumber="9"/>
			<description>Entry AdditionalStreams with type Array in FileTrailer shall satisfy special case: fn:Eval((fn:ArrayLength(AdditionalStreams) mod 2) == 0)</description>
			<test>AdditionalStreamsHasTypeArray != true || ((AdditionalStreamsArraySize % 2) == 0)</test>
			<error>
				<message>Entry AdditionalStreams with type Array in FileTrailer does not satisfy special case: fn:Eval((fn:ArrayLength(AdditionalStreams) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-DocChecksum" testNumber="8"/>
			<description>Entry DocChecksum in FileTrailer shall have type Name</description>
			<test>containsDocChecksum == false || DocChecksumHasTypeName == true</test>
			<error>
				<message>Entry DocChecksum in FileTrailer has type %1 instead of type Name</message>
				<arguments>
					<argument>DocChecksumType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-DocChecksum" testNumber="23"/>
			<description>Entry DocChecksum in FileTrailer can only be present, if satisfy predicate fn:Extension(OpenOffice)</description>
			<test>containsDocChecksum == false || hasExtensionOpenOffice == true</test>
			<error>
				<message>Entry DocChecksum in FileTrailer is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-DocChecksum-Name" testNumber="10"/>
			<description>Entry DocChecksum with type Name in FileTrailer shall be direct</description>
			<test>DocChecksumHasTypeName != true || isDocChecksumIndirect == false</test>
			<error>
				<message>Entry DocChecksum with type Name in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Encrypt-Dictionary" testNumber="17"/>
			<description>Entry Encrypt with type Dictionary in FileTrailer shall be one of objects EncryptionStandard, EncryptionPublicKey</description>
			<test>EncryptHasTypeDictionary != true || Encrypt_size == 1</test>
			<error>
				<message>Entry Encrypt with type Dictionary in FileTrailer is not one of objects EncryptionStandard, EncryptionPublicKey</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Encrypt" testNumber="8"/>
			<description>Entry Encrypt in FileTrailer shall have type Dictionary</description>
			<test>containsEncrypt == false || EncryptHasTypeDictionary == true</test>
			<error>
				<message>Entry Encrypt in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EncryptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-ID" testNumber="8"/>
			<description>Entry ID in FileTrailer shall have type Array</description>
			<test>containsID == false || entryIDHasTypeArray == true</test>
			<error>
				<message>Entry ID in FileTrailer has type %1 instead of type Array</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-ID" testNumber="11"/>
			<description>Entry ID in FileTrailer is required, when fn:IsPresent(Encrypt)</description>
			<test>containsID == true || (containsEncrypt != true)</test>
			<error>
				<message>Entry ID in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-ID-Array" testNumber="16"/>
			<description>If entry ID with type Array in FileTrailer satisfies condition fn:IsPresent(Encrypt), it shall be direct</description>
			<test>entryIDHasTypeArray != true || (isentryIDIndirect == false || (containsEncrypt != true))</test>
			<error>
				<message>Entry ID with type Array in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Info" testNumber="8"/>
			<description>Entry Info in FileTrailer shall have type Dictionary</description>
			<test>containsInfo == false || InfoHasTypeDictionary == true</test>
			<error>
				<message>Entry Info in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>InfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Info" testNumber="11"/>
			<description>Entry Info in FileTrailer is required, when fn:IsPresent(trailer::Catalog::PieceInfo)</description>
			<test>containsInfo == true || (containstrailerCatalogPieceInfo != true)</test>
			<error>
				<message>Entry Info in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Info-Dictionary" testNumber="10"/>
			<description>Entry Info with type Dictionary in FileTrailer shall be indirect</description>
			<test>InfoHasTypeDictionary != true || isInfoIndirect == true</test>
			<error>
				<message>Entry Info with type Dictionary in FileTrailer is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Info-Dictionary" testNumber="9"/>
			<description>Entry Info with type Dictionary in FileTrailer shall satisfy special case: fn:Eval(fn:IsPresent(trailer::Catalog::PieceInfo, fn:IsPresent(trailer::Info::ModDate)))</description>
			<test>InfoHasTypeDictionary != true || ((containstrailerCatalogPieceInfo == false) || (containstrailerInfoModDate == true))</test>
			<error>
				<message>Entry Info with type Dictionary in FileTrailer does not satisfy special case: fn:Eval(fn:IsPresent(trailer::Catalog::PieceInfo, fn:IsPresent(trailer::Info::ModDate)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Prev" testNumber="8"/>
			<description>Entry Prev in FileTrailer shall have type Integer</description>
			<test>containsPrev == false || PrevHasTypeInteger == true</test>
			<error>
				<message>Entry Prev in FileTrailer has type %1 instead of type Integer</message>
				<arguments>
					<argument>PrevType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Prev-Integer" testNumber="10"/>
			<description>Entry Prev with type Integer in FileTrailer shall be direct</description>
			<test>PrevHasTypeInteger != true || isPrevIndirect == false</test>
			<error>
				<message>Entry Prev with type Integer in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Prev-Integer" testNumber="14"/>
			<description>Entry Prev with type Integer in FileTrailer shall satisfy possible value predicate: fn:Eval((@Prev &gt;= 0) &amp;&amp; (@Prev &lt;= fn:FileSize()))</description>
			<test>PrevHasTypeInteger != true || (PrevIntegerValue &gt;= 0) &amp;&amp; (PrevIntegerValue &lt;= fileSize)</test>
			<error>
				<message>Entry Prev with type Integer in FileTrailer does not satisfy possible value predicate: fn:Eval((@Prev &gt;= 0) &amp;&amp; (@Prev &lt;= fn:FileSize()))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Root" testNumber="8"/>
			<description>Entry Root in FileTrailer shall have type Dictionary</description>
			<test>containsRoot == false || RootHasTypeDictionary == true</test>
			<error>
				<message>Entry Root in FileTrailer has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RootType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Root" testNumber="7"/>
			<description>Entry Root in FileTrailer is required</description>
			<test>containsRoot == true</test>
			<error>
				<message>Entry Root in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Root-Dictionary" testNumber="10"/>
			<description>Entry Root with type Dictionary in FileTrailer shall be indirect</description>
			<test>RootHasTypeDictionary != true || isRootIndirect == true</test>
			<error>
				<message>Entry Root with type Dictionary in FileTrailer is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Size" testNumber="8"/>
			<description>Entry Size in FileTrailer shall have type Integer</description>
			<test>containsSize == false || SizeHasTypeInteger == true</test>
			<error>
				<message>Entry Size in FileTrailer has type %1 instead of type Integer</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Size" testNumber="7"/>
			<description>Entry Size in FileTrailer is required</description>
			<test>containsSize == true</test>
			<error>
				<message>Entry Size in FileTrailer is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Size-Integer" testNumber="10"/>
			<description>Entry Size with type Integer in FileTrailer shall be direct</description>
			<test>SizeHasTypeInteger != true || isSizeIndirect == false</test>
			<error>
				<message>Entry Size with type Integer in FileTrailer is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFileTrailer">
			<id specification="PDF_1_4" clause="FileTrailer-Size-Integer" testNumber="14"/>
			<description>Entry Size with type Integer in FileTrailer shall satisfy possible value predicate: fn:Eval(@Size &gt; 0)</description>
			<test>SizeHasTypeInteger != true || SizeIntegerValue &gt; 0</test>
			<error>
				<message>Entry Size with type Integer in FileTrailer does not satisfy possible value predicate: fn:Eval(@Size &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode" testNumber="1"/>
			<description>FilterCCITTFaxDecode shall not contain entries except BlackIs1, Blackls1, Columns, DamagedRowsBeforeError, EncodedByteAlign, EndOfBlock, EndOfLine, K, Rows</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BlackIs1' &amp;&amp; elem != 'Blackls1' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'DamagedRowsBeforeError' &amp;&amp; elem != 'EncodedByteAlign' &amp;&amp; elem != 'EndOfBlock' &amp;&amp; elem != 'EndOfLine' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Rows' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterCCITTFaxDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BlackIs1' &amp;&amp; elem != 'Blackls1' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'DamagedRowsBeforeError' &amp;&amp; elem != 'EncodedByteAlign' &amp;&amp; elem != 'EndOfBlock' &amp;&amp; elem != 'EndOfLine' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Rows' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-BlackIs1" testNumber="8"/>
			<description>Entry BlackIs1 in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsBlackIs1 == false || BlackIs1HasTypeBoolean == true</test>
			<error>
				<message>Entry BlackIs1 in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>BlackIs1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Blackls1" testNumber="8"/>
			<description>Entry Blackls1 in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsBlackls1 == false || Blackls1HasTypeBoolean == true</test>
			<error>
				<message>Entry Blackls1 in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>Blackls1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Blackls1" testNumber="23"/>
			<description>Entry Blackls1 in FilterCCITTFaxDecode can only be present, if satisfy predicate fn:Extension(Malforms)</description>
			<test>containsBlackls1 == false || hasExtensionMalforms == true</test>
			<error>
				<message>Entry Blackls1 in FilterCCITTFaxDecode is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Columns-Integer" testNumber="14"/>
			<description>Entry Columns with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@Columns &gt;= 0)</description>
			<test>ColumnsHasTypeInteger != true || ColumnsIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Columns with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@Columns &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-DamagedRowsBeforeError" testNumber="8"/>
			<description>Entry DamagedRowsBeforeError in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsDamagedRowsBeforeError == false || DamagedRowsBeforeErrorHasTypeInteger == true</test>
			<error>
				<message>Entry DamagedRowsBeforeError in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>DamagedRowsBeforeErrorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-DamagedRowsBeforeError-Integer" testNumber="14"/>
			<description>Entry DamagedRowsBeforeError with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@DamagedRowsBeforeError &gt;= 0)</description>
			<test>DamagedRowsBeforeErrorHasTypeInteger != true || DamagedRowsBeforeErrorIntegerValue &gt;= 0</test>
			<error>
				<message>Entry DamagedRowsBeforeError with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@DamagedRowsBeforeError &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-EncodedByteAlign" testNumber="8"/>
			<description>Entry EncodedByteAlign in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEncodedByteAlign == false || EncodedByteAlignHasTypeBoolean == true</test>
			<error>
				<message>Entry EncodedByteAlign in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EncodedByteAlignType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-EndOfBlock" testNumber="8"/>
			<description>Entry EndOfBlock in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEndOfBlock == false || EndOfBlockHasTypeBoolean == true</test>
			<error>
				<message>Entry EndOfBlock in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EndOfBlockType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-EndOfLine" testNumber="8"/>
			<description>Entry EndOfLine in FilterCCITTFaxDecode shall have type Boolean</description>
			<test>containsEndOfLine == false || EndOfLineHasTypeBoolean == true</test>
			<error>
				<message>Entry EndOfLine in FilterCCITTFaxDecode has type %1 instead of type Boolean</message>
				<arguments>
					<argument>EndOfLineType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-K" testNumber="8"/>
			<description>Entry K in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsK == false || KHasTypeInteger == true</test>
			<error>
				<message>Entry K in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Rows" testNumber="8"/>
			<description>Entry Rows in FilterCCITTFaxDecode shall have type Integer</description>
			<test>containsRows == false || RowsHasTypeInteger == true</test>
			<error>
				<message>Entry Rows in FilterCCITTFaxDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>RowsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterCCITTFaxDecode">
			<id specification="PDF_1_4" clause="FilterCCITTFaxDecode-Rows-Integer" testNumber="14"/>
			<description>Entry Rows with type Integer in FilterCCITTFaxDecode shall satisfy possible value predicate: fn:Eval(@Rows &gt;= 0)</description>
			<test>RowsHasTypeInteger != true || RowsIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Rows with type Integer in FilterCCITTFaxDecode does not satisfy possible value predicate: fn:Eval(@Rows &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_4" clause="FilterDCTDecode" testNumber="1"/>
			<description>FilterDCTDecode shall not contain entries except ColorTransform</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ColorTransform' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterDCTDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ColorTransform' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_4" clause="FilterDCTDecode-ColorTransform" testNumber="8"/>
			<description>Entry ColorTransform in FilterDCTDecode shall have type Integer</description>
			<test>containsColorTransform == false || ColorTransformHasTypeInteger == true</test>
			<error>
				<message>Entry ColorTransform in FilterDCTDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorTransformType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterDCTDecode">
			<id specification="PDF_1_4" clause="FilterDCTDecode-ColorTransform-Integer" testNumber="6"/>
			<description>Entry ColorTransform with type Integer in FilterDCTDecode shall have one of values: 0, 1</description>
			<test>ColorTransformHasTypeInteger != true || ColorTransformIntegerValue == 0 || ColorTransformIntegerValue == 1</test>
			<error>
				<message>Entry ColorTransform with type Integer in FilterDCTDecode has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>ColorTransformIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode" testNumber="1"/>
			<description>FilterFlateDecode shall not contain entries except BitsPerComponent, Colors, Columns, Predictor</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'Colors' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'Predictor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterFlateDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'Colors' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'Predictor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in FilterFlateDecode shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in FilterFlateDecode shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in FilterFlateDecode has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-Colors" testNumber="8"/>
			<description>Entry Colors in FilterFlateDecode shall have type Integer</description>
			<test>containsColors == false || ColorsHasTypeInteger == true</test>
			<error>
				<message>Entry Colors in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-Colors-Integer" testNumber="14"/>
			<description>Entry Colors with type Integer in FilterFlateDecode shall satisfy possible value predicate: fn:Eval((@Colors &gt;= 1))</description>
			<test>ColorsHasTypeInteger != true || (ColorsIntegerValue &gt;= 1)</test>
			<error>
				<message>Entry Colors with type Integer in FilterFlateDecode does not satisfy possible value predicate: fn:Eval((@Colors &gt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterFlateDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-Predictor" testNumber="8"/>
			<description>Entry Predictor in FilterFlateDecode shall have type Integer</description>
			<test>containsPredictor == false || PredictorHasTypeInteger == true</test>
			<error>
				<message>Entry Predictor in FilterFlateDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>PredictorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterFlateDecode">
			<id specification="PDF_1_4" clause="FilterFlateDecode-Predictor-Integer" testNumber="6"/>
			<description>Entry Predictor with type Integer in FilterFlateDecode shall have one of values: 11, 1, 12, 2, 13, 14, 15, 10</description>
			<test>PredictorHasTypeInteger != true || PredictorIntegerValue == 1 || PredictorIntegerValue == 2 || PredictorIntegerValue == 10 || PredictorIntegerValue == 11 || PredictorIntegerValue == 12 || PredictorIntegerValue == 13 || PredictorIntegerValue == 14 || PredictorIntegerValue == 15</test>
			<error>
				<message>Entry Predictor with type Integer in FilterFlateDecode has incorrect value %1 instead of 11, 1, 12, 2, 13, 14, 15, 10</message>
				<arguments>
					<argument>PredictorIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterJBIG2Decode">
			<id specification="PDF_1_4" clause="FilterJBIG2Decode" testNumber="1"/>
			<description>FilterJBIG2Decode shall not contain entries except JBIG2Globals</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'JBIG2Globals' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterJBIG2Decode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'JBIG2Globals' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterJBIG2Decode">
			<id specification="PDF_1_4" clause="FilterJBIG2Decode-JBIG2Globals" testNumber="8"/>
			<description>Entry JBIG2Globals in FilterJBIG2Decode shall have type Stream</description>
			<test>containsJBIG2Globals == false || JBIG2GlobalsHasTypeStream == true</test>
			<error>
				<message>Entry JBIG2Globals in FilterJBIG2Decode has type %1 instead of type Stream</message>
				<arguments>
					<argument>JBIG2GlobalsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterJBIG2Decode">
			<id specification="PDF_1_4" clause="FilterJBIG2Decode-JBIG2Globals-Stream" testNumber="10"/>
			<description>Entry JBIG2Globals with type Stream in FilterJBIG2Decode shall be indirect</description>
			<test>JBIG2GlobalsHasTypeStream != true || isJBIG2GlobalsIndirect == true</test>
			<error>
				<message>Entry JBIG2Globals with type Stream in FilterJBIG2Decode is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode" testNumber="1"/>
			<description>FilterLZWDecode shall not contain entries except BitsPerComponent, Colors, Columns, EarlyChange, Predictor</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'Colors' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'EarlyChange' &amp;&amp; elem != 'Predictor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FilterLZWDecode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'Colors' &amp;&amp; elem != 'Columns' &amp;&amp; elem != 'EarlyChange' &amp;&amp; elem != 'Predictor' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in FilterLZWDecode shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in FilterLZWDecode shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in FilterLZWDecode has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-Colors" testNumber="8"/>
			<description>Entry Colors in FilterLZWDecode shall have type Integer</description>
			<test>containsColors == false || ColorsHasTypeInteger == true</test>
			<error>
				<message>Entry Colors in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColorsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-Colors-Integer" testNumber="14"/>
			<description>Entry Colors with type Integer in FilterLZWDecode shall satisfy possible value predicate: fn:Eval((@Colors &gt;= 1))</description>
			<test>ColorsHasTypeInteger != true || (ColorsIntegerValue &gt;= 1)</test>
			<error>
				<message>Entry Colors with type Integer in FilterLZWDecode does not satisfy possible value predicate: fn:Eval((@Colors &gt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-Columns" testNumber="8"/>
			<description>Entry Columns in FilterLZWDecode shall have type Integer</description>
			<test>containsColumns == false || ColumnsHasTypeInteger == true</test>
			<error>
				<message>Entry Columns in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColumnsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-EarlyChange" testNumber="8"/>
			<description>Entry EarlyChange in FilterLZWDecode shall have type Integer</description>
			<test>containsEarlyChange == false || EarlyChangeHasTypeInteger == true</test>
			<error>
				<message>Entry EarlyChange in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>EarlyChangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-EarlyChange-Integer" testNumber="6"/>
			<description>Entry EarlyChange with type Integer in FilterLZWDecode shall have one of values: 0, 1</description>
			<test>EarlyChangeHasTypeInteger != true || EarlyChangeIntegerValue == 0 || EarlyChangeIntegerValue == 1</test>
			<error>
				<message>Entry EarlyChange with type Integer in FilterLZWDecode has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>EarlyChangeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-Predictor" testNumber="8"/>
			<description>Entry Predictor in FilterLZWDecode shall have type Integer</description>
			<test>containsPredictor == false || PredictorHasTypeInteger == true</test>
			<error>
				<message>Entry Predictor in FilterLZWDecode has type %1 instead of type Integer</message>
				<arguments>
					<argument>PredictorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFilterLZWDecode">
			<id specification="PDF_1_4" clause="FilterLZWDecode-Predictor-Integer" testNumber="6"/>
			<description>Entry Predictor with type Integer in FilterLZWDecode shall have one of values: 11, 1, 12, 2, 13, 14, 15, 10</description>
			<test>PredictorHasTypeInteger != true || PredictorIntegerValue == 1 || PredictorIntegerValue == 2 || PredictorIntegerValue == 10 || PredictorIntegerValue == 11 || PredictorIntegerValue == 12 || PredictorIntegerValue == 13 || PredictorIntegerValue == 14 || PredictorIntegerValue == 15</test>
			<error>
				<message>Entry Predictor with type Integer in FilterLZWDecode has incorrect value %1 instead of 11, 1, 12, 2, 13, 14, 15, 10</message>
				<arguments>
					<argument>PredictorIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0" testNumber="1"/>
			<description>FontCIDType0 shall not contain entries except BaseFont, CIDSystemInfo, CIDToGIDMap, DW, DW2, FontDescriptor, Subtype, ToUnicode, Type, W, W2</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; elem != 'W2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; elem != 'W2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontCIDType0 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontCIDType0 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in FontCIDType0 shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in FontCIDType0 is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-CIDToGIDMap" testNumber="8"/>
			<description>Entry CIDToGIDMap in FontCIDType0 shall have one of types: Name, Stream</description>
			<test>containsCIDToGIDMap == false || CIDToGIDMapHasTypeName == true || CIDToGIDMapHasTypeStream == true</test>
			<error>
				<message>Entry CIDToGIDMap in FontCIDType0 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>CIDToGIDMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-CIDToGIDMap-Name" testNumber="6"/>
			<description>Entry CIDToGIDMap with type Name in FontCIDType0 shall have value Identity</description>
			<test>CIDToGIDMapHasTypeName != true || CIDToGIDMapNameValue == "Identity"</test>
			<error>
				<message>Entry CIDToGIDMap with type Name in FontCIDType0 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>CIDToGIDMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-CIDToGIDMap-Stream" testNumber="10"/>
			<description>Entry CIDToGIDMap with type Stream in FontCIDType0 shall be indirect</description>
			<test>CIDToGIDMapHasTypeStream != true || isCIDToGIDMapIndirect == true</test>
			<error>
				<message>Entry CIDToGIDMap with type Stream in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-DW" testNumber="8"/>
			<description>Entry DW in FontCIDType0 shall have type Integer</description>
			<test>containsDW == false || DWHasTypeInteger == true</test>
			<error>
				<message>Entry DW in FontCIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>DWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-DW2" testNumber="8"/>
			<description>Entry DW2 in FontCIDType0 shall have type Array</description>
			<test>containsDW2 == false || DW2HasTypeArray == true</test>
			<error>
				<message>Entry DW2 in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DW2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontCIDType0 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-FontDescriptor" testNumber="7"/>
			<description>Entry FontDescriptor in FontCIDType0 is required</description>
			<test>containsFontDescriptor == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontCIDType0 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontCIDType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontCIDType0 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontCIDType0 shall have value CIDFontType0</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType0"</test>
			<error>
				<message>Entry Subtype with type Name in FontCIDType0 has incorrect value %1 instead of CIDFontType0</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontCIDType0 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontCIDType0 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Type" testNumber="8"/>
			<description>Entry Type in FontCIDType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Type" testNumber="7"/>
			<description>Entry Type in FontCIDType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontCIDType0 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontCIDType0 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-W" testNumber="8"/>
			<description>Entry W in FontCIDType0 shall have type Array</description>
			<test>containsW == false || WHasTypeArray == true</test>
			<error>
				<message>Entry W in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType0">
			<id specification="PDF_1_4" clause="FontCIDType0-W2" testNumber="8"/>
			<description>Entry W2 in FontCIDType0 shall have type Array</description>
			<test>containsW2 == false || W2HasTypeArray == true</test>
			<error>
				<message>Entry W2 in FontCIDType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>W2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2" testNumber="1"/>
			<description>FontCIDType2 shall not contain entries except BaseFont, CIDSystemInfo, CIDToGIDMap, DW, DW2, FontDescriptor, Subtype, ToUnicode, Type, W, W2</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; elem != 'W2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CIDToGIDMap' &amp;&amp; elem != 'DW' &amp;&amp; elem != 'DW2' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'W' &amp;&amp; elem != 'W2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontCIDType2 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontCIDType2 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in FontCIDType2 shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-CIDSystemInfo" testNumber="7"/>
			<description>Entry CIDSystemInfo in FontCIDType2 is required</description>
			<test>containsCIDSystemInfo == true</test>
			<error>
				<message>Entry CIDSystemInfo in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-CIDToGIDMap" testNumber="8"/>
			<description>Entry CIDToGIDMap in FontCIDType2 shall have one of types: Name, Stream</description>
			<test>containsCIDToGIDMap == false || CIDToGIDMapHasTypeName == true || CIDToGIDMapHasTypeStream == true</test>
			<error>
				<message>Entry CIDToGIDMap in FontCIDType2 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>CIDToGIDMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-CIDToGIDMap-Name" testNumber="6"/>
			<description>Entry CIDToGIDMap with type Name in FontCIDType2 shall have value Identity</description>
			<test>CIDToGIDMapHasTypeName != true || CIDToGIDMapNameValue == "Identity"</test>
			<error>
				<message>Entry CIDToGIDMap with type Name in FontCIDType2 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>CIDToGIDMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-CIDToGIDMap-Stream" testNumber="10"/>
			<description>Entry CIDToGIDMap with type Stream in FontCIDType2 shall be indirect</description>
			<test>CIDToGIDMapHasTypeStream != true || isCIDToGIDMapIndirect == true</test>
			<error>
				<message>Entry CIDToGIDMap with type Stream in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-DW" testNumber="8"/>
			<description>Entry DW in FontCIDType2 shall have type Integer</description>
			<test>containsDW == false || DWHasTypeInteger == true</test>
			<error>
				<message>Entry DW in FontCIDType2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>DWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-DW2" testNumber="8"/>
			<description>Entry DW2 in FontCIDType2 shall have type Array</description>
			<test>containsDW2 == false || DW2HasTypeArray == true</test>
			<error>
				<message>Entry DW2 in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>DW2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontCIDType2 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-FontDescriptor" testNumber="7"/>
			<description>Entry FontDescriptor in FontCIDType2 is required</description>
			<test>containsFontDescriptor == true</test>
			<error>
				<message>Entry FontDescriptor in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontCIDType2 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontCIDType2 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontCIDType2 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontCIDType2 shall have value CIDFontType2</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType2"</test>
			<error>
				<message>Entry Subtype with type Name in FontCIDType2 has incorrect value %1 instead of CIDFontType2</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontCIDType2 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontCIDType2 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Type" testNumber="8"/>
			<description>Entry Type in FontCIDType2 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Type" testNumber="7"/>
			<description>Entry Type in FontCIDType2 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontCIDType2 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontCIDType2 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-W" testNumber="8"/>
			<description>Entry W in FontCIDType2 shall have type Array</description>
			<test>containsW == false || WHasTypeArray == true</test>
			<error>
				<message>Entry W in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>WType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontCIDType2">
			<id specification="PDF_1_4" clause="FontCIDType2-W2" testNumber="8"/>
			<description>Entry W2 in FontCIDType2 shall have type Array</description>
			<test>containsW2 == false || W2HasTypeArray == true</test>
			<error>
				<message>Entry W2 in FontCIDType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>W2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0" testNumber="1"/>
			<description>FontDescriptorCIDType0 shall not contain entries except Ascent, AvgWidth, CIDSet, CapHeight, Descent, FD, Flags, FontBBox, FontFile, FontFile3, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Style, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0" testNumber="22"/>
			<description>FontDescriptorCIDType0 shall not contain entries FontFamily, FontStretch, FontWeight, Lang in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight' || elem == 'Lang').length == 0</test>
			<error>
				<message>FontDescriptorCIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight' || elem == 'Lang').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorCIDType0 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-CIDSet" testNumber="8"/>
			<description>Entry CIDSet in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsCIDSet == false || CIDSetHasTypeStream == true</test>
			<error>
				<message>Entry CIDSet in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>CIDSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-CIDSet-Stream" testNumber="10"/>
			<description>Entry CIDSet with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>CIDSetHasTypeStream != true || isCIDSetIndirect == true</test>
			<error>
				<message>Entry CIDSet with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorCIDType0 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorCIDType0 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorCIDType0 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FD" testNumber="8"/>
			<description>Entry FD in FontDescriptorCIDType0 shall have type Dictionary</description>
			<test>containsFD == false || FDHasTypeDictionary == true</test>
			<error>
				<message>Entry FD in FontDescriptorCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorCIDType0 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType0 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorCIDType0 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorCIDType0 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType0 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorCIDType0 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile3 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile3" testNumber="8"/>
			<description>Entry FontFile3 in FontDescriptorCIDType0 shall have type Stream</description>
			<test>containsFontFile3 == false || FontFile3HasTypeStream == true</test>
			<error>
				<message>Entry FontFile3 in FontDescriptorCIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile3-Stream" testNumber="10"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorCIDType0 shall be indirect</description>
			<test>FontFile3HasTypeStream != true || isFontFile3Indirect == true</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorCIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontFile3-Stream" testNumber="9"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile3HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorCIDType0 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorCIDType0 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorCIDType0 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorCIDType0 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType0 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorCIDType0 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Style" testNumber="8"/>
			<description>Entry Style in FontDescriptorCIDType0 shall have type Dictionary</description>
			<test>containsStyle == false || StyleHasTypeDictionary == true</test>
			<error>
				<message>Entry Style in FontDescriptorCIDType0 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>StyleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorCIDType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorCIDType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorCIDType0 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorCIDType0 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType0">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType0-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorCIDType0 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorCIDType0 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2" testNumber="1"/>
			<description>FontDescriptorCIDType2 shall not contain entries except Ascent, AvgWidth, CIDSet, CapHeight, Descent, FD, Flags, FontBBox, FontFile, FontFile2, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Style, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CIDSet' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'FD' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Style' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2" testNumber="22"/>
			<description>FontDescriptorCIDType2 shall not contain entries FontFamily, FontFile3, FontStretch, FontWeight, Lang in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontFile3' || elem == 'FontStretch' || elem == 'FontWeight' || elem == 'Lang').length == 0</test>
			<error>
				<message>FontDescriptorCIDType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontFile3' || elem == 'FontStretch' || elem == 'FontWeight' || elem == 'Lang').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorCIDType2 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-CIDSet" testNumber="8"/>
			<description>Entry CIDSet in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsCIDSet == false || CIDSetHasTypeStream == true</test>
			<error>
				<message>Entry CIDSet in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>CIDSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-CIDSet-Stream" testNumber="10"/>
			<description>Entry CIDSet with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>CIDSetHasTypeStream != true || isCIDSetIndirect == true</test>
			<error>
				<message>Entry CIDSet with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorCIDType2 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorCIDType2 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorCIDType2 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FD" testNumber="8"/>
			<description>Entry FD in FontDescriptorCIDType2 shall have type Dictionary</description>
			<test>containsFD == false || FDHasTypeDictionary == true</test>
			<error>
				<message>Entry FD in FontDescriptorCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorCIDType2 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType2 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorCIDType2 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorCIDType2 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType2 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorCIDType2 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile2 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile2" testNumber="8"/>
			<description>Entry FontFile2 in FontDescriptorCIDType2 shall have type Stream</description>
			<test>containsFontFile2 == false || FontFile2HasTypeStream == true</test>
			<error>
				<message>Entry FontFile2 in FontDescriptorCIDType2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile2-Stream" testNumber="10"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorCIDType2 shall be indirect</description>
			<test>FontFile2HasTypeStream != true || isFontFile2Indirect == true</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorCIDType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontFile2-Stream" testNumber="9"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile2HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorCIDType2 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorCIDType2 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorCIDType2 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorCIDType2 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorCIDType2 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorCIDType2 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Style" testNumber="8"/>
			<description>Entry Style in FontDescriptorCIDType2 shall have type Dictionary</description>
			<test>containsStyle == false || StyleHasTypeDictionary == true</test>
			<error>
				<message>Entry Style in FontDescriptorCIDType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>StyleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorCIDType2 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorCIDType2 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorCIDType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorCIDType2 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorCIDType2 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorCIDType2">
			<id specification="PDF_1_4" clause="FontDescriptorCIDType2-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorCIDType2 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorCIDType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType" testNumber="1"/>
			<description>FontDescriptorTrueType shall not contain entries except Ascent, AvgWidth, CapHeight, Descent, Flags, FontBBox, FontFile, FontFile2, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile2' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType" testNumber="22"/>
			<description>FontDescriptorTrueType shall not contain entries FontFamily, FontFile3, FontStretch, FontWeight in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontFile3' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontFile3' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorTrueType shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorTrueType is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorTrueType shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorTrueType shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorTrueType is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorTrueType shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorTrueType does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorTrueType shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorTrueType has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorTrueType is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorTrueType shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorTrueType has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorTrueType is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorTrueType shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorTrueType shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile2 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile2)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile2" testNumber="8"/>
			<description>Entry FontFile2 in FontDescriptorTrueType shall have type Stream</description>
			<test>containsFontFile2 == false || FontFile2HasTypeStream == true</test>
			<error>
				<message>Entry FontFile2 in FontDescriptorTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile2-Stream" testNumber="10"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorTrueType shall be indirect</description>
			<test>FontFile2HasTypeStream != true || isFontFile2Indirect == true</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontFile2-Stream" testNumber="9"/>
			<description>Entry FontFile2 with type Stream in FontDescriptorTrueType shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile2HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile2 with type Stream in FontDescriptorTrueType does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorTrueType shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorTrueType is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorTrueType shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorTrueType does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorTrueType shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorTrueType is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorTrueType shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorTrueType shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorTrueType shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorTrueType shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorTrueType is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorTrueType shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorTrueType is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorTrueType shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorTrueType has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorTrueType">
			<id specification="PDF_1_4" clause="FontDescriptorTrueType-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorTrueType shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorTrueType has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1" testNumber="1"/>
			<description>FontDescriptorType1 shall not contain entries except Ascent, AvgWidth, CapHeight, CharSet, Descent, Flags, FontBBox, FontFile, FontFile3, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'CharSet' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontFile' &amp;&amp; elem != 'FontFile3' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1" testNumber="22"/>
			<description>FontDescriptorType1 shall not contain entries FontFamily, FontStretch, FontWeight in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorType1 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Ascent" testNumber="7"/>
			<description>Entry Ascent in FontDescriptorType1 is required</description>
			<test>containsAscent == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorType1 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-CharSet" testNumber="8"/>
			<description>Entry CharSet in FontDescriptorType1 shall have one of types: StringAscii, StringByte</description>
			<test>containsCharSet == false || CharSetHasTypeStringAscii == true || CharSetHasTypeStringByte == true</test>
			<error>
				<message>Entry CharSet in FontDescriptorType1 has type %1 instead of one of types: StringAscii, StringByte</message>
				<arguments>
					<argument>CharSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorType1 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Descent" testNumber="7"/>
			<description>Entry Descent in FontDescriptorType1 is required</description>
			<test>containsDescent == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorType1 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorType1 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorType1 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType1 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorType1 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorType1 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorType1 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorType1 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontDescriptorType1 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile" testNumber="8"/>
			<description>Entry FontFile in FontDescriptorType1 shall have type Stream</description>
			<test>containsFontFile == false || FontFileHasTypeStream == true</test>
			<error>
				<message>Entry FontFile in FontDescriptorType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile-Stream" testNumber="10"/>
			<description>Entry FontFile with type Stream in FontDescriptorType1 shall be indirect</description>
			<test>FontFileHasTypeStream != true || isFontFileIndirect == true</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile-Stream" testNumber="9"/>
			<description>Entry FontFile with type Stream in FontDescriptorType1 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</description>
			<test>FontFileHasTypeStream != true || (containsFontFile3 != true)</test>
			<error>
				<message>Entry FontFile with type Stream in FontDescriptorType1 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile3)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile3" testNumber="8"/>
			<description>Entry FontFile3 in FontDescriptorType1 shall have type Stream</description>
			<test>containsFontFile3 == false || FontFile3HasTypeStream == true</test>
			<error>
				<message>Entry FontFile3 in FontDescriptorType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>FontFile3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile3-Stream" testNumber="10"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorType1 shall be indirect</description>
			<test>FontFile3HasTypeStream != true || isFontFile3Indirect == true</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontFile3-Stream" testNumber="9"/>
			<description>Entry FontFile3 with type Stream in FontDescriptorType1 shall satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</description>
			<test>FontFile3HasTypeStream != true || (containsFontFile != true)</test>
			<error>
				<message>Entry FontFile3 with type Stream in FontDescriptorType1 does not satisfy special case: fn:Eval(fn:Not(fn:IsPresent(FontFile)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorType1 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontName" testNumber="7"/>
			<description>Entry FontName in FontDescriptorType1 is required</description>
			<test>containsFontName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorType1 shall satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentBaseFontNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorType1 does not satisfy special case: fn:Eval(@FontName == parent::@BaseFont)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorType1 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorType1 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorType1 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorType1 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorType1 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorType1 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-StemV" testNumber="7"/>
			<description>Entry StemV in FontDescriptorType1 is required</description>
			<test>containsStemV == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorType1 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorType1 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorType1 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType1">
			<id specification="PDF_1_4" clause="FontDescriptorType1-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorType1 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3" testNumber="1"/>
			<description>FontDescriptorType3 shall not contain entries except Ascent, AvgWidth, CapHeight, Descent, Flags, FontBBox, FontName, ItalicAngle, Leading, MaxWidth, MissingWidth, StemH, StemV, Type, XHeight</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontDescriptorType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Ascent' &amp;&amp; elem != 'AvgWidth' &amp;&amp; elem != 'CapHeight' &amp;&amp; elem != 'Descent' &amp;&amp; elem != 'Flags' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontFamily' &amp;&amp; elem != 'FontName' &amp;&amp; elem != 'FontStretch' &amp;&amp; elem != 'FontWeight' &amp;&amp; elem != 'ItalicAngle' &amp;&amp; elem != 'Leading' &amp;&amp; elem != 'MaxWidth' &amp;&amp; elem != 'MissingWidth' &amp;&amp; elem != 'StemH' &amp;&amp; elem != 'StemV' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XHeight' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3" testNumber="22"/>
			<description>FontDescriptorType3 shall not contain entries FontFamily, FontStretch, FontWeight in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').length == 0</test>
			<error>
				<message>FontDescriptorType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'FontFamily' || elem == 'FontStretch' || elem == 'FontWeight').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Ascent" testNumber="8"/>
			<description>Entry Ascent in FontDescriptorType3 shall have type Number</description>
			<test>containsAscent == false || AscentHasTypeNumber == true</test>
			<error>
				<message>Entry Ascent in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>AscentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-AvgWidth" testNumber="8"/>
			<description>Entry AvgWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsAvgWidth == false || AvgWidthHasTypeNumber == true</test>
			<error>
				<message>Entry AvgWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>AvgWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-CapHeight" testNumber="8"/>
			<description>Entry CapHeight in FontDescriptorType3 shall have type Number</description>
			<test>containsCapHeight == false || CapHeightHasTypeNumber == true</test>
			<error>
				<message>Entry CapHeight in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>CapHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Descent" testNumber="8"/>
			<description>Entry Descent in FontDescriptorType3 shall have type Number</description>
			<test>containsDescent == false || DescentHasTypeNumber == true</test>
			<error>
				<message>Entry Descent in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>DescentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Descent-Number" testNumber="14"/>
			<description>Entry Descent with type Number in FontDescriptorType3 shall satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</description>
			<test>DescentHasTypeNumber != true || DescentNumberValue &lt;= 0</test>
			<error>
				<message>Entry Descent with type Number in FontDescriptorType3 does not satisfy possible value predicate: fn:Eval(@Descent &lt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Flags" testNumber="8"/>
			<description>Entry Flags in FontDescriptorType3 shall have type Bitmask</description>
			<test>containsFlags == false || FlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType3 has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Flags" testNumber="7"/>
			<description>Entry Flags in FontDescriptorType3 is required</description>
			<test>containsFlags == true</test>
			<error>
				<message>Entry Flags in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Flags-Bitmask" testNumber="9"/>
			<description>Entry Flags with type Bitmask in FontDescriptorType3 shall satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</description>
			<test>FlagsHasTypeBitmask != true || ((FlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0) &amp;&amp; ((FlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0))</test>
			<error>
				<message>Entry Flags with type Bitmask in FontDescriptorType3 does not satisfy special case: fn:Eval(fn:BitClear(5) &amp;&amp; fn:BitsClear(8, 16) &amp;&amp; fn:BitsClear(20, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontDescriptorType3 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontDescriptorType3 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-FontName" testNumber="8"/>
			<description>Entry FontName in FontDescriptorType3 shall have type Name</description>
			<test>containsFontName == false || FontNameHasTypeName == true</test>
			<error>
				<message>Entry FontName in FontDescriptorType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>FontNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-FontName-Name" testNumber="9"/>
			<description>Entry FontName with type Name in FontDescriptorType3 shall satisfy special case: fn:Eval(@FontName == parent::@Name)</description>
			<test>FontNameHasTypeName != true || (FontNameNameValue == parentNameNameValue)</test>
			<error>
				<message>Entry FontName with type Name in FontDescriptorType3 does not satisfy special case: fn:Eval(@FontName == parent::@Name)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-ItalicAngle" testNumber="8"/>
			<description>Entry ItalicAngle in FontDescriptorType3 shall have type Number</description>
			<test>containsItalicAngle == false || ItalicAngleHasTypeNumber == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>ItalicAngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-ItalicAngle" testNumber="7"/>
			<description>Entry ItalicAngle in FontDescriptorType3 is required</description>
			<test>containsItalicAngle == true</test>
			<error>
				<message>Entry ItalicAngle in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Leading" testNumber="8"/>
			<description>Entry Leading in FontDescriptorType3 shall have type Number</description>
			<test>containsLeading == false || LeadingHasTypeNumber == true</test>
			<error>
				<message>Entry Leading in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>LeadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-MaxWidth" testNumber="8"/>
			<description>Entry MaxWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsMaxWidth == false || MaxWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MaxWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>MaxWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-MissingWidth" testNumber="8"/>
			<description>Entry MissingWidth in FontDescriptorType3 shall have type Number</description>
			<test>containsMissingWidth == false || MissingWidthHasTypeNumber == true</test>
			<error>
				<message>Entry MissingWidth in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>MissingWidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-StemH" testNumber="8"/>
			<description>Entry StemH in FontDescriptorType3 shall have type Number</description>
			<test>containsStemH == false || StemHHasTypeNumber == true</test>
			<error>
				<message>Entry StemH in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemHType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-StemV" testNumber="8"/>
			<description>Entry StemV in FontDescriptorType3 shall have type Number</description>
			<test>containsStemV == false || StemVHasTypeNumber == true</test>
			<error>
				<message>Entry StemV in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>StemVType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Type" testNumber="8"/>
			<description>Entry Type in FontDescriptorType3 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontDescriptorType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Type" testNumber="7"/>
			<description>Entry Type in FontDescriptorType3 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontDescriptorType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontDescriptorType3 shall have value FontDescriptor</description>
			<test>TypeHasTypeName != true || TypeNameValue == "FontDescriptor"</test>
			<error>
				<message>Entry Type with type Name in FontDescriptorType3 has incorrect value %1 instead of FontDescriptor</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontDescriptorType3">
			<id specification="PDF_1_4" clause="FontDescriptorType3-XHeight" testNumber="8"/>
			<description>Entry XHeight in FontDescriptorType3 shall have type Number</description>
			<test>containsXHeight == false || XHeightHasTypeNumber == true</test>
			<error>
				<message>Entry XHeight in FontDescriptorType3 has type %1 instead of type Number</message>
				<arguments>
					<argument>XHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile" testNumber="1"/>
			<description>FontFile shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Length1, Length2, Length3, Metadata, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile" testNumber="22"/>
			<description>FontFile shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FontFile contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-F" testNumber="8"/>
			<description>Entry F in FontFile shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length" testNumber="8"/>
			<description>Entry Length in FontFile shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length" testNumber="7"/>
			<description>Entry Length in FontFile is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Metadata" testNumber="8"/>
			<description>Entry Metadata in FontFile shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in FontFile has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in FontFile shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in FontFile is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile">
			<id specification="PDF_1_4" clause="FontFile-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile shall have one of values: CIDFontType0C, Type1C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1C" || SubtypeNameValue == "CIDFontType0C"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile has incorrect value %1 instead of CIDFontType0C, Type1C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2" testNumber="1"/>
			<description>FontFile2 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Length1, Length2, Length3, Metadata, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2" testNumber="22"/>
			<description>FontFile2 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FontFile2 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile2 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile2 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile2 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile2 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-F" testNumber="8"/>
			<description>Entry F in FontFile2 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile2 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile2 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile2 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile2 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile2 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile2 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile2 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile2 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile2 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile2 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile2 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile2 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile2 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile2 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile2 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length" testNumber="8"/>
			<description>Entry Length in FontFile2 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length" testNumber="7"/>
			<description>Entry Length in FontFile2 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile2 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length1" testNumber="11"/>
			<description>Entry Length1 in FontFile2 is required, when parent::parent::@Subtype == TrueType</description>
			<test>containsLength1 == true || (parentparentSubtypeNameValue != "TrueType")</test>
			<error>
				<message>Entry Length1 in FontFile2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile2 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile2 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile2 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile2 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Metadata" testNumber="8"/>
			<description>Entry Metadata in FontFile2 shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in FontFile2 has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in FontFile2 shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in FontFile2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile2">
			<id specification="PDF_1_4" clause="FontFile2-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile2 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile2 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0" testNumber="1"/>
			<description>FontFile3CIDType0 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Length1, Length2, Length3, Metadata, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile3CIDType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0" testNumber="22"/>
			<description>FontFile3CIDType0 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FontFile3CIDType0 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile3CIDType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile3CIDType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile3CIDType0 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile3CIDType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-F" testNumber="8"/>
			<description>Entry F in FontFile3CIDType0 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile3CIDType0 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile3CIDType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile3CIDType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile3CIDType0 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile3CIDType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile3CIDType0 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile3CIDType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile3CIDType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile3CIDType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile3CIDType0 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile3CIDType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile3CIDType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile3CIDType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile3CIDType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile3CIDType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length" testNumber="8"/>
			<description>Entry Length in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length" testNumber="7"/>
			<description>Entry Length in FontFile3CIDType0 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile3CIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile3CIDType0 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile3CIDType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile3CIDType0 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile3CIDType0 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Metadata" testNumber="8"/>
			<description>Entry Metadata in FontFile3CIDType0 shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in FontFile3CIDType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in FontFile3CIDType0 shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in FontFile3CIDType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile3CIDType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile3CIDType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontFile3CIDType0 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontFile3CIDType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3CIDType0">
			<id specification="PDF_1_4" clause="FontFile3CIDType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile3CIDType0 shall have value CIDFontType0C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "CIDFontType0C"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile3CIDType0 has incorrect value %1 instead of CIDFontType0C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1" testNumber="1"/>
			<description>FontFile3Type1 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Length1, Length2, Length3, Metadata, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFile3Type1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1" testNumber="22"/>
			<description>FontFile3Type1 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FontFile3Type1 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFile3Type1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFile3Type1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFile3Type1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFile3Type1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFile3Type1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFile3Type1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-F" testNumber="8"/>
			<description>Entry F in FontFile3Type1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFile3Type1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFile3Type1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFile3Type1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFile3Type1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFile3Type1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFile3Type1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFile3Type1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFile3Type1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFile3Type1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFile3Type1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFile3Type1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFile3Type1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFile3Type1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Filter" testNumber="8"/>
			<description>Entry Filter in FontFile3Type1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFile3Type1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFile3Type1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFile3Type1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFile3Type1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFile3Type1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length" testNumber="8"/>
			<description>Entry Length in FontFile3Type1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length" testNumber="7"/>
			<description>Entry Length in FontFile3Type1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFile3Type1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFile3Type1 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFile3Type1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFile3Type1 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFile3Type1 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Metadata" testNumber="8"/>
			<description>Entry Metadata in FontFile3Type1 shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in FontFile3Type1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in FontFile3Type1 shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in FontFile3Type1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFile3Type1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFile3Type1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontFile3Type1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontFile3Type1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFile3Type1">
			<id specification="PDF_1_4" clause="FontFile3Type1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFile3Type1 shall have value Type1C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1C"</test>
			<error>
				<message>Entry Subtype with type Name in FontFile3Type1 has incorrect value %1 instead of Type1C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1" testNumber="1"/>
			<description>FontFileType1 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Length1, Length2, Length3, Metadata, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontFileType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Length1' &amp;&amp; elem != 'Length2' &amp;&amp; elem != 'Length3' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1" testNumber="22"/>
			<description>FontFileType1 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FontFileType1 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FontFileType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FontFileType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FontFileType1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FontFileType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FontFileType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FontFileType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-F" testNumber="8"/>
			<description>Entry F in FontFileType1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FontFileType1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FontFileType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FontFileType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FontFileType1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FontFileType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FontFileType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FontFileType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FFilter" testNumber="8"/>
			<description>Entry FFilter in FontFileType1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FontFileType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FontFileType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FontFileType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FontFileType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FontFileType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Filter" testNumber="8"/>
			<description>Entry Filter in FontFileType1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FontFileType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FontFileType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FontFileType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FontFileType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FontFileType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length" testNumber="8"/>
			<description>Entry Length in FontFileType1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length" testNumber="7"/>
			<description>Entry Length in FontFileType1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length1" testNumber="8"/>
			<description>Entry Length1 in FontFileType1 shall have type Integer</description>
			<test>containsLength1 == false || Length1HasTypeInteger == true</test>
			<error>
				<message>Entry Length1 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length1" testNumber="7"/>
			<description>Entry Length1 in FontFileType1 is required</description>
			<test>containsLength1 == true</test>
			<error>
				<message>Entry Length1 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length1-Integer" testNumber="9"/>
			<description>Entry Length1 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length1 &gt;= 0)</description>
			<test>Length1HasTypeInteger != true || (Length1IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length1 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length2" testNumber="8"/>
			<description>Entry Length2 in FontFileType1 shall have type Integer</description>
			<test>containsLength2 == false || Length2HasTypeInteger == true</test>
			<error>
				<message>Entry Length2 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length2" testNumber="7"/>
			<description>Entry Length2 in FontFileType1 is required</description>
			<test>containsLength2 == true</test>
			<error>
				<message>Entry Length2 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length2-Integer" testNumber="9"/>
			<description>Entry Length2 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length2 &gt;= 0)</description>
			<test>Length2HasTypeInteger != true || (Length2IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length2 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length3" testNumber="8"/>
			<description>Entry Length3 in FontFileType1 shall have type Integer</description>
			<test>containsLength3 == false || Length3HasTypeInteger == true</test>
			<error>
				<message>Entry Length3 in FontFileType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Length3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length3" testNumber="7"/>
			<description>Entry Length3 in FontFileType1 is required</description>
			<test>containsLength3 == true</test>
			<error>
				<message>Entry Length3 in FontFileType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Length3-Integer" testNumber="9"/>
			<description>Entry Length3 with type Integer in FontFileType1 shall satisfy special case: fn:Eval(@Length3 &gt;= 0)</description>
			<test>Length3HasTypeInteger != true || (Length3IntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Length3 with type Integer in FontFileType1 does not satisfy special case: fn:Eval(@Length3 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Metadata" testNumber="8"/>
			<description>Entry Metadata in FontFileType1 shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in FontFileType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in FontFileType1 shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in FontFileType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontFileType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontFileType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontFileType1">
			<id specification="PDF_1_4" clause="FontFileType1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontFileType1 shall have value Type1C</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1C"</test>
			<error>
				<message>Entry Subtype with type Name in FontFileType1 has incorrect value %1 instead of Type1C</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMapEntry">
			<id specification="PDF_1_4" clause="FontMapEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in FontMap shall be one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in FontMap is not one of objects FontType1, FontTrueType, FontMultipleMaster, FontType3, FontType0, FontCIDType0, FontCIDType2</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMapEntry">
			<id specification="PDF_1_4" clause="FontMapEntry" testNumber="8"/>
			<description>Entry in FontMap shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in FontMap has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster" testNumber="1"/>
			<description>FontMultipleMaster shall not contain entries except BaseFont, Encoding, FirstChar, FontDescriptor, LastChar, Name, Subtype, ToUnicode, Type, Widths</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontMultipleMaster contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontMultipleMaster shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontMultipleMaster is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontMultipleMaster shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontMultipleMaster has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontMultipleMaster shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontMultipleMaster has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontMultipleMaster shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontMultipleMaster has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontMultipleMaster shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontMultipleMaster has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontMultipleMaster shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontMultipleMaster is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontMultipleMaster shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontMultipleMaster has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Name" testNumber="8"/>
			<description>Entry Name in FontMultipleMaster shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontMultipleMaster shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontMultipleMaster is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontMultipleMaster shall have value MMType1</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "MMType1"</test>
			<error>
				<message>Entry Subtype with type Name in FontMultipleMaster has incorrect value %1 instead of MMType1</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontMultipleMaster shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontMultipleMaster has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontMultipleMaster shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontMultipleMaster is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Type" testNumber="8"/>
			<description>Entry Type in FontMultipleMaster shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontMultipleMaster has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Type" testNumber="7"/>
			<description>Entry Type in FontMultipleMaster is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontMultipleMaster shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontMultipleMaster has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Widths" testNumber="8"/>
			<description>Entry Widths in FontMultipleMaster shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontMultipleMaster has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontMultipleMaster">
			<id specification="PDF_1_4" clause="FontMultipleMaster-Widths" testNumber="11"/>
			<description>Entry Widths in FontMultipleMaster is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontMultipleMaster is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType" testNumber="1"/>
			<description>FontTrueType shall not contain entries except BaseFont, Encoding, FirstChar, FontDescriptor, LastChar, Name, Subtype, ToUnicode, Type, Widths</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontTrueType contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontTrueType shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontTrueType is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontTrueType shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontTrueType has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontTrueType shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontTrueType has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontTrueType shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontTrueType has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontTrueType shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontTrueType has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontTrueType shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontTrueType shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontTrueType has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Name" testNumber="8"/>
			<description>Entry Name in FontTrueType shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontTrueType shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontTrueType is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontTrueType shall have value TrueType</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "TrueType"</test>
			<error>
				<message>Entry Subtype with type Name in FontTrueType has incorrect value %1 instead of TrueType</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontTrueType shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontTrueType has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontTrueType shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontTrueType is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Type" testNumber="8"/>
			<description>Entry Type in FontTrueType shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontTrueType has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Type" testNumber="7"/>
			<description>Entry Type in FontTrueType is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontTrueType shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontTrueType has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Widths" testNumber="8"/>
			<description>Entry Widths in FontTrueType shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontTrueType has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontTrueType">
			<id specification="PDF_1_4" clause="FontTrueType-Widths" testNumber="11"/>
			<description>Entry Widths in FontTrueType is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontTrueType is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0" testNumber="1"/>
			<description>FontType0 shall not contain entries except BaseFont, DescendantFonts, Encoding, Subtype, ToUnicode, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'DescendantFonts' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'DescendantFonts' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontType0 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontType0 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-DescendantFonts" testNumber="8"/>
			<description>Entry DescendantFonts in FontType0 shall have type Array</description>
			<test>containsDescendantFonts == false || DescendantFontsHasTypeArray == true</test>
			<error>
				<message>Entry DescendantFonts in FontType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DescendantFontsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-DescendantFonts" testNumber="7"/>
			<description>Entry DescendantFonts in FontType0 is required</description>
			<test>containsDescendantFonts == true</test>
			<error>
				<message>Entry DescendantFonts in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType0 shall have one of types: Name, Stream</description>
			<test>containsEncoding == false || EncodingHasTypeName == true || EncodingHasTypeStream == true</test>
			<error>
				<message>Entry Encoding in FontType0 has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Encoding" testNumber="7"/>
			<description>Entry Encoding in FontType0 is required</description>
			<test>containsEncoding == true</test>
			<error>
				<message>Entry Encoding in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontType0 shall have one of values: GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "GB-EUC-H" || EncodingNameValue == "GB-EUC-V" || EncodingNameValue == "GBpc-EUC-H" || EncodingNameValue == "GBpc-EUC-V" || EncodingNameValue == "GBK-EUC-H" || EncodingNameValue == "GBK-EUC-V" || EncodingNameValue == "GBKp-EUC-H" || EncodingNameValue == "GBKp-EUC-V" || EncodingNameValue == "GBK2K-H" || EncodingNameValue == "GBK2K-V" || EncodingNameValue == "UniGB-UCS2-H" || EncodingNameValue == "UniGB-UCS2-V" || EncodingNameValue == "UniGB-UTF16-H" || EncodingNameValue == "UniGB-UTF16-V" || EncodingNameValue == "B5pc-H" || EncodingNameValue == "B5pc-V" || EncodingNameValue == "HKscs-B5-H" || EncodingNameValue == "HKscs-B5-V" || EncodingNameValue == "ETen-B5-H" || EncodingNameValue == "ETen-B5-V" || EncodingNameValue == "ETenms-B5-H" || EncodingNameValue == "ETenms-B5-V" || EncodingNameValue == "CNS-EUC-H" || EncodingNameValue == "CNS-EUC-V" || EncodingNameValue == "UniCNS-UCS2-H" || EncodingNameValue == "UniCNS-UCS2-V" || EncodingNameValue == "UniCNS-UTF16-H" || EncodingNameValue == "UniCNS-UTF16-V" || EncodingNameValue == "83pv-RKSJ-H" || EncodingNameValue == "90ms-RKSJ-H" || EncodingNameValue == "90ms-RKSJ-V" || EncodingNameValue == "90msp-RKSJ-H" || EncodingNameValue == "90msp-RKSJ-V" || EncodingNameValue == "90pv-RKSJ-H" || EncodingNameValue == "Add-RKSJ-H" || EncodingNameValue == "Add-RKSJ-V" || EncodingNameValue == "EUC-H" || EncodingNameValue == "EUC-V" || EncodingNameValue == "Ext-RKSJ-H" || EncodingNameValue == "Ext-RKSJ-V" || EncodingNameValue == "H" || EncodingNameValue == "V" || EncodingNameValue == "UniJIS-UCS2-H" || EncodingNameValue == "UniJIS-UCS2-V" || EncodingNameValue == "UniJIS-UCS2-HW-H" || EncodingNameValue == "UniJIS-UCS2-HW-V" || EncodingNameValue == "UniJIS-UTF16-H" || EncodingNameValue == "UniJIS-UTF16-V" || EncodingNameValue == "KSC-EUC-H" || EncodingNameValue == "KSC-EUC-V" || EncodingNameValue == "KSCms-UHC-H" || EncodingNameValue == "KSCms-UHC-V" || EncodingNameValue == "KSCms-UHC-HW-H" || EncodingNameValue == "KSCms-UHC-HW-V" || EncodingNameValue == "KSCpc-EUC-H" || EncodingNameValue == "UniKS-UCS2-H" || EncodingNameValue == "UniKS-UCS2-V" || EncodingNameValue == "UniKS-UTF16-H" || EncodingNameValue == "UniKS-UTF16-V" || EncodingNameValue == "Identity-H" || EncodingNameValue == "Identity-V"</test>
			<error>
				<message>Entry Encoding with type Name in FontType0 has incorrect value %1 instead of GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Encoding-Stream" testNumber="10"/>
			<description>Entry Encoding with type Stream in FontType0 shall be indirect</description>
			<test>EncodingHasTypeStream != true || isEncodingIndirect == true</test>
			<error>
				<message>Entry Encoding with type Stream in FontType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType0 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType0 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType0 shall have value Type0</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type0"</test>
			<error>
				<message>Entry Subtype with type Name in FontType0 has incorrect value %1 instead of Type0</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType0 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType0 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType0 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType0 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Type" testNumber="8"/>
			<description>Entry Type in FontType0 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType0 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Type" testNumber="7"/>
			<description>Entry Type in FontType0 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType0">
			<id specification="PDF_1_4" clause="FontType0-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType0 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType0 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1" testNumber="1"/>
			<description>FontType1 shall not contain entries except BaseFont, Encoding, FirstChar, FontDescriptor, LastChar, Name, Subtype, ToUnicode, Type, Widths</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BaseFont' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-BaseFont" testNumber="8"/>
			<description>Entry BaseFont in FontType1 shall have type Name</description>
			<test>containsBaseFont == false || BaseFontHasTypeName == true</test>
			<error>
				<message>Entry BaseFont in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>BaseFontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-BaseFont" testNumber="7"/>
			<description>Entry BaseFont in FontType1 is required</description>
			<test>containsBaseFont == true</test>
			<error>
				<message>Entry BaseFont in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType1 shall have one of types: Dictionary, Name</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true || EncodingHasTypeName == true</test>
			<error>
				<message>Entry Encoding in FontType1 has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Encoding-Name" testNumber="6"/>
			<description>Entry Encoding with type Name in FontType1 shall have one of values: MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</description>
			<test>EncodingHasTypeName != true || EncodingNameValue == "MacRomanEncoding" || EncodingNameValue == "MacExpertEncoding" || EncodingNameValue == "WinAnsiEncoding"</test>
			<error>
				<message>Entry Encoding with type Name in FontType1 has incorrect value %1 instead of MacExpertEncoding, MacRomanEncoding, WinAnsiEncoding</message>
				<arguments>
					<argument>EncodingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontType1 shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-FirstChar" testNumber="11"/>
			<description>Entry FirstChar in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsFirstChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry FirstChar in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontType1 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsFontDescriptor == true || notStandard14Font == false</test>
			<error>
				<message>Entry FontDescriptor in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontType1 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontType1 shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-LastChar" testNumber="11"/>
			<description>Entry LastChar in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsLastChar == true || notStandard14Font == false</test>
			<error>
				<message>Entry LastChar in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Name" testNumber="8"/>
			<description>Entry Name in FontType1 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType1 shall have value Type1</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type1"</test>
			<error>
				<message>Entry Subtype with type Name in FontType1 has incorrect value %1 instead of Type1</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType1 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType1 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Type" testNumber="8"/>
			<description>Entry Type in FontType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Type" testNumber="7"/>
			<description>Entry Type in FontType1 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType1 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType1 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Widths" testNumber="8"/>
			<description>Entry Widths in FontType1 shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Widths" testNumber="11"/>
			<description>Entry Widths in FontType1 is required, when fn:NotStandard14Font()</description>
			<test>containsWidths == true || notStandard14Font == false</test>
			<error>
				<message>Entry Widths in FontType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType1">
			<id specification="PDF_1_4" clause="FontType1-Widths-Array" testNumber="9"/>
			<description>Entry Widths with type Array in FontType1 shall satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</description>
			<test>WidthsHasTypeArray != true || (LastCharHasTypeInteger == false || FirstCharHasTypeInteger == false || WidthsArraySize == (1 + (LastCharIntegerValue - FirstCharIntegerValue)))</test>
			<error>
				<message>Entry Widths with type Array in FontType1 does not satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3" testNumber="1"/>
			<description>FontType3 shall not contain entries except CharProcs, Encoding, FirstChar, FontBBox, FontDescriptor, FontMatrix, LastChar, Name, Resources, Subtype, ToUnicode, Type, Widths</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CharProcs' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'FontMatrix' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FontType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CharProcs' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'FirstChar' &amp;&amp; elem != 'FontBBox' &amp;&amp; elem != 'FontDescriptor' &amp;&amp; elem != 'FontMatrix' &amp;&amp; elem != 'LastChar' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'ToUnicode' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Widths' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-CharProcs" testNumber="8"/>
			<description>Entry CharProcs in FontType3 shall have type Dictionary</description>
			<test>containsCharProcs == false || CharProcsHasTypeDictionary == true</test>
			<error>
				<message>Entry CharProcs in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CharProcsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-CharProcs" testNumber="7"/>
			<description>Entry CharProcs in FontType3 is required</description>
			<test>containsCharProcs == true</test>
			<error>
				<message>Entry CharProcs in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Encoding" testNumber="8"/>
			<description>Entry Encoding in FontType3 shall have type Dictionary</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true</test>
			<error>
				<message>Entry Encoding in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Encoding" testNumber="7"/>
			<description>Entry Encoding in FontType3 is required</description>
			<test>containsEncoding == true</test>
			<error>
				<message>Entry Encoding in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FirstChar" testNumber="8"/>
			<description>Entry FirstChar in FontType3 shall have type Integer</description>
			<test>containsFirstChar == false || FirstCharHasTypeInteger == true</test>
			<error>
				<message>Entry FirstChar in FontType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FirstCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FirstChar" testNumber="7"/>
			<description>Entry FirstChar in FontType3 is required</description>
			<test>containsFirstChar == true</test>
			<error>
				<message>Entry FirstChar in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontBBox" testNumber="8"/>
			<description>Entry FontBBox in FontType3 shall have type Rectangle</description>
			<test>containsFontBBox == false || FontBBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry FontBBox in FontType3 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>FontBBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontBBox" testNumber="7"/>
			<description>Entry FontBBox in FontType3 is required</description>
			<test>containsFontBBox == true</test>
			<error>
				<message>Entry FontBBox in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontDescriptor" testNumber="8"/>
			<description>Entry FontDescriptor in FontType3 shall have type Dictionary</description>
			<test>containsFontDescriptor == false || FontDescriptorHasTypeDictionary == true</test>
			<error>
				<message>Entry FontDescriptor in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontDescriptorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontDescriptor" testNumber="11"/>
			<description>Entry FontDescriptor in FontType3 is required, when fn:IsPDFTagged()</description>
			<test>containsFontDescriptor == true || isPDFTagged == false</test>
			<error>
				<message>Entry FontDescriptor in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontDescriptor-Dictionary" testNumber="10"/>
			<description>Entry FontDescriptor with type Dictionary in FontType3 shall be indirect</description>
			<test>FontDescriptorHasTypeDictionary != true || isFontDescriptorIndirect == true</test>
			<error>
				<message>Entry FontDescriptor with type Dictionary in FontType3 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontMatrix" testNumber="8"/>
			<description>Entry FontMatrix in FontType3 shall have type Matrix</description>
			<test>containsFontMatrix == false || FontMatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry FontMatrix in FontType3 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>FontMatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-FontMatrix" testNumber="7"/>
			<description>Entry FontMatrix in FontType3 is required</description>
			<test>containsFontMatrix == true</test>
			<error>
				<message>Entry FontMatrix in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-LastChar" testNumber="8"/>
			<description>Entry LastChar in FontType3 shall have type Integer</description>
			<test>containsLastChar == false || LastCharHasTypeInteger == true</test>
			<error>
				<message>Entry LastChar in FontType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LastCharType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-LastChar" testNumber="7"/>
			<description>Entry LastChar in FontType3 is required</description>
			<test>containsLastChar == true</test>
			<error>
				<message>Entry LastChar in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Name" testNumber="8"/>
			<description>Entry Name in FontType3 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Resources" testNumber="8"/>
			<description>Entry Resources in FontType3 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in FontType3 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Subtype" testNumber="8"/>
			<description>Entry Subtype in FontType3 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Subtype" testNumber="7"/>
			<description>Entry Subtype in FontType3 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in FontType3 shall have value Type3</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Type3"</test>
			<error>
				<message>Entry Subtype with type Name in FontType3 has incorrect value %1 instead of Type3</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-ToUnicode" testNumber="8"/>
			<description>Entry ToUnicode in FontType3 shall have type Stream</description>
			<test>containsToUnicode == false || ToUnicodeHasTypeStream == true</test>
			<error>
				<message>Entry ToUnicode in FontType3 has type %1 instead of type Stream</message>
				<arguments>
					<argument>ToUnicodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-ToUnicode-Stream" testNumber="10"/>
			<description>Entry ToUnicode with type Stream in FontType3 shall be indirect</description>
			<test>ToUnicodeHasTypeStream != true || isToUnicodeIndirect == true</test>
			<error>
				<message>Entry ToUnicode with type Stream in FontType3 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Type" testNumber="8"/>
			<description>Entry Type in FontType3 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in FontType3 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Type" testNumber="7"/>
			<description>Entry Type in FontType3 is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in FontType3 shall have value Font</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Font"</test>
			<error>
				<message>Entry Type with type Name in FontType3 has incorrect value %1 instead of Font</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Widths" testNumber="8"/>
			<description>Entry Widths in FontType3 shall have type Array</description>
			<test>containsWidths == false || WidthsHasTypeArray == true</test>
			<error>
				<message>Entry Widths in FontType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>WidthsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Widths" testNumber="7"/>
			<description>Entry Widths in FontType3 is required</description>
			<test>containsWidths == true</test>
			<error>
				<message>Entry Widths in FontType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFontType3">
			<id specification="PDF_1_4" clause="FontType3-Widths-Array" testNumber="9"/>
			<description>Entry Widths with type Array in FontType3 shall satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</description>
			<test>WidthsHasTypeArray != true || (LastCharHasTypeInteger == false || FirstCharHasTypeInteger == false || WidthsArraySize == (1 + (LastCharIntegerValue - FirstCharIntegerValue)))</test>
			<error>
				<message>Entry Widths with type Array in FontType3 does not satisfy special case: fn:Eval(fn:ArrayLength(Widths) == (1 + (@LastChar - @FirstChar)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0" testNumber="1"/>
			<description>FunctionType0 shall not contain entries except BitsPerSample, Decode, DecodeParms, Domain, Encode, F, FDecodeParms, FFilter, Filter, FunctionType, Length, Order, Range, Size</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerSample' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Order' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'Size' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FunctionType0 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerSample' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Order' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'Size' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0" testNumber="22"/>
			<description>FunctionType0 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FunctionType0 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-BitsPerSample" testNumber="8"/>
			<description>Entry BitsPerSample in FunctionType0 shall have type Integer</description>
			<test>containsBitsPerSample == false || BitsPerSampleHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerSample in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerSampleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-BitsPerSample" testNumber="7"/>
			<description>Entry BitsPerSample in FunctionType0 is required</description>
			<test>containsBitsPerSample == true</test>
			<error>
				<message>Entry BitsPerSample in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-BitsPerSample-Integer" testNumber="6"/>
			<description>Entry BitsPerSample with type Integer in FunctionType0 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerSampleHasTypeInteger != true || BitsPerSampleIntegerValue == 1 || BitsPerSampleIntegerValue == 2 || BitsPerSampleIntegerValue == 4 || BitsPerSampleIntegerValue == 8 || BitsPerSampleIntegerValue == 12 || BitsPerSampleIntegerValue == 16 || BitsPerSampleIntegerValue == 24 || BitsPerSampleIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerSample with type Integer in FunctionType0 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerSampleIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Decode" testNumber="8"/>
			<description>Entry Decode in FunctionType0 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Decode-Array" testNumber="9"/>
			<description>Entry Decode with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Decode) == fn:ArrayLength(Range))</description>
			<test>DecodeHasTypeArray != true || (RangeHasTypeArray == false || DecodeArraySize == RangeArraySize)</test>
			<error>
				<message>Entry Decode with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Decode) == fn:ArrayLength(Range))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FunctionType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FunctionType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FunctionType0 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FunctionType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Domain" testNumber="8"/>
			<description>Entry Domain in FunctionType0 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Domain" testNumber="7"/>
			<description>Entry Domain in FunctionType0 is required</description>
			<test>containsDomain == true</test>
			<error>
				<message>Entry Domain in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Domain-Array" testNumber="9"/>
			<description>Entry Domain with type Array in FunctionType0 shall satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</description>
			<test>DomainHasTypeArray != true || ((DomainArraySize % 2) == 0)</test>
			<error>
				<message>Entry Domain with type Array in FunctionType0 does not satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Encode" testNumber="8"/>
			<description>Entry Encode in FunctionType0 shall have type Array</description>
			<test>containsEncode == false || EncodeHasTypeArray == true</test>
			<error>
				<message>Entry Encode in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>EncodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Encode-Array" testNumber="9"/>
			<description>Entry Encode with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Encode) == (2 * fn:ArrayLength(Size)))</description>
			<test>EncodeHasTypeArray != true || (SizeHasTypeArray == false || EncodeArraySize == (2 * SizeArraySize))</test>
			<error>
				<message>Entry Encode with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Encode) == (2 * fn:ArrayLength(Size)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-F" testNumber="8"/>
			<description>Entry F in FunctionType0 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FunctionType0 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FunctionType0 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FunctionType0 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FunctionType0 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FunctionType0 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FFilter" testNumber="8"/>
			<description>Entry FFilter in FunctionType0 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FunctionType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FunctionType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FunctionType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Filter" testNumber="8"/>
			<description>Entry Filter in FunctionType0 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FunctionType0 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FunctionType0 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FunctionType0 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FunctionType" testNumber="8"/>
			<description>Entry FunctionType in FunctionType0 shall have type Integer</description>
			<test>containsFunctionType == false || FunctionTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FunctionType in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FunctionTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FunctionType" testNumber="7"/>
			<description>Entry FunctionType in FunctionType0 is required</description>
			<test>containsFunctionType == true</test>
			<error>
				<message>Entry FunctionType in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-FunctionType-Integer" testNumber="6"/>
			<description>Entry FunctionType with type Integer in FunctionType0 shall have value 0</description>
			<test>FunctionTypeHasTypeInteger != true || FunctionTypeIntegerValue == 0</test>
			<error>
				<message>Entry FunctionType with type Integer in FunctionType0 has incorrect value %1 instead of 0</message>
				<arguments>
					<argument>FunctionTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Length" testNumber="8"/>
			<description>Entry Length in FunctionType0 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Length" testNumber="7"/>
			<description>Entry Length in FunctionType0 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Order" testNumber="8"/>
			<description>Entry Order in FunctionType0 shall have type Integer</description>
			<test>containsOrder == false || OrderHasTypeInteger == true</test>
			<error>
				<message>Entry Order in FunctionType0 has type %1 instead of type Integer</message>
				<arguments>
					<argument>OrderType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Order-Integer" testNumber="6"/>
			<description>Entry Order with type Integer in FunctionType0 shall have one of values: 1, 3</description>
			<test>OrderHasTypeInteger != true || OrderIntegerValue == 1 || OrderIntegerValue == 3</test>
			<error>
				<message>Entry Order with type Integer in FunctionType0 has incorrect value %1 instead of 1, 3</message>
				<arguments>
					<argument>OrderIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Range" testNumber="8"/>
			<description>Entry Range in FunctionType0 shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Range" testNumber="7"/>
			<description>Entry Range in FunctionType0 is required</description>
			<test>containsRange == true</test>
			<error>
				<message>Entry Range in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in FunctionType0 shall satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</description>
			<test>RangeHasTypeArray != true || ((RangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Range with type Array in FunctionType0 does not satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Size" testNumber="8"/>
			<description>Entry Size in FunctionType0 shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in FunctionType0 has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Size" testNumber="7"/>
			<description>Entry Size in FunctionType0 is required</description>
			<test>containsSize == true</test>
			<error>
				<message>Entry Size in FunctionType0 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType0">
			<id specification="PDF_1_4" clause="FunctionType0-Size-Array" testNumber="9"/>
			<description>Entry Size with type Array in FunctionType0 shall satisfy special case: fn:Eval(fn:ArrayLength(Domain) == (2 * fn:ArrayLength(Size)))</description>
			<test>SizeHasTypeArray != true || (DomainHasTypeArray == false || DomainArraySize == (2 * SizeArraySize))</test>
			<error>
				<message>Entry Size with type Array in FunctionType0 does not satisfy special case: fn:Eval(fn:ArrayLength(Domain) == (2 * fn:ArrayLength(Size)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2" testNumber="1"/>
			<description>FunctionType2 shall not contain entries except C0, C1, Domain, FunctionType, N, Range</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C0' &amp;&amp; elem != 'C1' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'N' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FunctionType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C0' &amp;&amp; elem != 'C1' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'N' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-C0" testNumber="8"/>
			<description>Entry C0 in FunctionType2 shall have type Array</description>
			<test>containsC0 == false || C0HasTypeArray == true</test>
			<error>
				<message>Entry C0 in FunctionType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>C0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-C0-Array" testNumber="9"/>
			<description>Entry C0 with type Array in FunctionType2 shall satisfy special case: fn:Eval(fn:ArrayLength(C0) == fn:ArrayLength(C1))</description>
			<test>C0HasTypeArray != true || (C1HasTypeArray == false || C0ArraySize == C1ArraySize)</test>
			<error>
				<message>Entry C0 with type Array in FunctionType2 does not satisfy special case: fn:Eval(fn:ArrayLength(C0) == fn:ArrayLength(C1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-C1" testNumber="8"/>
			<description>Entry C1 in FunctionType2 shall have type Array</description>
			<test>containsC1 == false || C1HasTypeArray == true</test>
			<error>
				<message>Entry C1 in FunctionType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>C1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-C1-Array" testNumber="9"/>
			<description>Entry C1 with type Array in FunctionType2 shall satisfy special case: fn:Eval(fn:ArrayLength(C1) == fn:ArrayLength(C0))</description>
			<test>C1HasTypeArray != true || (C0HasTypeArray == false || C1ArraySize == C0ArraySize)</test>
			<error>
				<message>Entry C1 with type Array in FunctionType2 does not satisfy special case: fn:Eval(fn:ArrayLength(C1) == fn:ArrayLength(C0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-Domain" testNumber="8"/>
			<description>Entry Domain in FunctionType2 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in FunctionType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-Domain" testNumber="7"/>
			<description>Entry Domain in FunctionType2 is required</description>
			<test>containsDomain == true</test>
			<error>
				<message>Entry Domain in FunctionType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-Domain-Array" testNumber="9"/>
			<description>Entry Domain with type Array in FunctionType2 shall satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</description>
			<test>DomainHasTypeArray != true || ((DomainArraySize % 2) == 0)</test>
			<error>
				<message>Entry Domain with type Array in FunctionType2 does not satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-FunctionType" testNumber="8"/>
			<description>Entry FunctionType in FunctionType2 shall have type Integer</description>
			<test>containsFunctionType == false || FunctionTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FunctionType in FunctionType2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FunctionTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-FunctionType" testNumber="7"/>
			<description>Entry FunctionType in FunctionType2 is required</description>
			<test>containsFunctionType == true</test>
			<error>
				<message>Entry FunctionType in FunctionType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-FunctionType-Integer" testNumber="6"/>
			<description>Entry FunctionType with type Integer in FunctionType2 shall have value 2</description>
			<test>FunctionTypeHasTypeInteger != true || FunctionTypeIntegerValue == 2</test>
			<error>
				<message>Entry FunctionType with type Integer in FunctionType2 has incorrect value %1 instead of 2</message>
				<arguments>
					<argument>FunctionTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-N" testNumber="8"/>
			<description>Entry N in FunctionType2 shall have type Number</description>
			<test>containsN == false || NHasTypeNumber == true</test>
			<error>
				<message>Entry N in FunctionType2 has type %1 instead of type Number</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-N" testNumber="7"/>
			<description>Entry N in FunctionType2 is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in FunctionType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-Range" testNumber="8"/>
			<description>Entry Range in FunctionType2 shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in FunctionType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType2">
			<id specification="PDF_1_4" clause="FunctionType2-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in FunctionType2 shall satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</description>
			<test>RangeHasTypeArray != true || ((RangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Range with type Array in FunctionType2 does not satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3" testNumber="1"/>
			<description>FunctionType3 shall not contain entries except Bounds, Domain, Encode, FunctionType, Functions, Range</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Bounds' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Functions' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FunctionType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Bounds' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Encode' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Functions' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Bounds" testNumber="8"/>
			<description>Entry Bounds in FunctionType3 shall have type Array</description>
			<test>containsBounds == false || BoundsHasTypeArray == true</test>
			<error>
				<message>Entry Bounds in FunctionType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>BoundsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Bounds" testNumber="7"/>
			<description>Entry Bounds in FunctionType3 is required</description>
			<test>containsBounds == true</test>
			<error>
				<message>Entry Bounds in FunctionType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Bounds-Array" testNumber="9"/>
			<description>Entry Bounds with type Array in FunctionType3 shall satisfy special case: fn:Eval(fn:ArrayLength(Bounds) == (fn:ArrayLength(Functions) - 1))</description>
			<test>BoundsHasTypeArray != true || (FunctionsHasTypeArray == false || BoundsArraySize == (FunctionsArraySize - 1))</test>
			<error>
				<message>Entry Bounds with type Array in FunctionType3 does not satisfy special case: fn:Eval(fn:ArrayLength(Bounds) == (fn:ArrayLength(Functions) - 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Domain" testNumber="8"/>
			<description>Entry Domain in FunctionType3 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in FunctionType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Domain" testNumber="7"/>
			<description>Entry Domain in FunctionType3 is required</description>
			<test>containsDomain == true</test>
			<error>
				<message>Entry Domain in FunctionType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Domain-Array" testNumber="9"/>
			<description>Entry Domain with type Array in FunctionType3 shall satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</description>
			<test>DomainHasTypeArray != true || ((DomainArraySize % 2) == 0)</test>
			<error>
				<message>Entry Domain with type Array in FunctionType3 does not satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Encode" testNumber="8"/>
			<description>Entry Encode in FunctionType3 shall have type Array</description>
			<test>containsEncode == false || EncodeHasTypeArray == true</test>
			<error>
				<message>Entry Encode in FunctionType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>EncodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Encode" testNumber="7"/>
			<description>Entry Encode in FunctionType3 is required</description>
			<test>containsEncode == true</test>
			<error>
				<message>Entry Encode in FunctionType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Encode-Array" testNumber="9"/>
			<description>Entry Encode with type Array in FunctionType3 shall satisfy special case: fn:Eval((fn:ArrayLength(Encode) mod 2) == 0)</description>
			<test>EncodeHasTypeArray != true || ((EncodeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Encode with type Array in FunctionType3 does not satisfy special case: fn:Eval((fn:ArrayLength(Encode) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-FunctionType" testNumber="8"/>
			<description>Entry FunctionType in FunctionType3 shall have type Integer</description>
			<test>containsFunctionType == false || FunctionTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FunctionType in FunctionType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FunctionTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-FunctionType" testNumber="7"/>
			<description>Entry FunctionType in FunctionType3 is required</description>
			<test>containsFunctionType == true</test>
			<error>
				<message>Entry FunctionType in FunctionType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-FunctionType-Integer" testNumber="6"/>
			<description>Entry FunctionType with type Integer in FunctionType3 shall have value 3</description>
			<test>FunctionTypeHasTypeInteger != true || FunctionTypeIntegerValue == 3</test>
			<error>
				<message>Entry FunctionType with type Integer in FunctionType3 has incorrect value %1 instead of 3</message>
				<arguments>
					<argument>FunctionTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Functions" testNumber="8"/>
			<description>Entry Functions in FunctionType3 shall have type Array</description>
			<test>containsFunctions == false || FunctionsHasTypeArray == true</test>
			<error>
				<message>Entry Functions in FunctionType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>FunctionsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Functions" testNumber="7"/>
			<description>Entry Functions in FunctionType3 is required</description>
			<test>containsFunctions == true</test>
			<error>
				<message>Entry Functions in FunctionType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Functions-Array" testNumber="9"/>
			<description>Entry Functions with type Array in FunctionType3 shall satisfy special case: fn:Eval(fn:ArrayLength(Functions) == (fn:ArrayLength(Bounds) + 1))</description>
			<test>FunctionsHasTypeArray != true || (BoundsHasTypeArray == false || FunctionsArraySize == (BoundsArraySize + 1))</test>
			<error>
				<message>Entry Functions with type Array in FunctionType3 does not satisfy special case: fn:Eval(fn:ArrayLength(Functions) == (fn:ArrayLength(Bounds) + 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Range" testNumber="8"/>
			<description>Entry Range in FunctionType3 shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in FunctionType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType3">
			<id specification="PDF_1_4" clause="FunctionType3-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in FunctionType3 shall satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</description>
			<test>RangeHasTypeArray != true || ((RangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Range with type Array in FunctionType3 does not satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4" testNumber="1"/>
			<description>FunctionType4 shall not contain entries except DecodeParms, Domain, F, FDecodeParms, FFilter, Filter, FunctionType, Length, Range</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>FunctionType4 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FunctionType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4" testNumber="22"/>
			<description>FunctionType4 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>FunctionType4 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in FunctionType4 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in FunctionType4 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in FunctionType4 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in FunctionType4 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in FunctionType4 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in FunctionType4 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Domain" testNumber="8"/>
			<description>Entry Domain in FunctionType4 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in FunctionType4 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Domain" testNumber="7"/>
			<description>Entry Domain in FunctionType4 is required</description>
			<test>containsDomain == true</test>
			<error>
				<message>Entry Domain in FunctionType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Domain-Array" testNumber="9"/>
			<description>Entry Domain with type Array in FunctionType4 shall satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</description>
			<test>DomainHasTypeArray != true || ((DomainArraySize % 2) == 0)</test>
			<error>
				<message>Entry Domain with type Array in FunctionType4 does not satisfy special case: fn:Eval((fn:ArrayLength(Domain) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-F" testNumber="8"/>
			<description>Entry F in FunctionType4 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in FunctionType4 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in FunctionType4 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in FunctionType4 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in FunctionType4 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in FunctionType4 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in FunctionType4 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in FunctionType4 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FFilter" testNumber="8"/>
			<description>Entry FFilter in FunctionType4 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in FunctionType4 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in FunctionType4 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in FunctionType4 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in FunctionType4 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in FunctionType4 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Filter" testNumber="8"/>
			<description>Entry Filter in FunctionType4 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in FunctionType4 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in FunctionType4 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in FunctionType4 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in FunctionType4 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in FunctionType4 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FunctionType" testNumber="8"/>
			<description>Entry FunctionType in FunctionType4 shall have type Integer</description>
			<test>containsFunctionType == false || FunctionTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FunctionType in FunctionType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FunctionTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FunctionType" testNumber="7"/>
			<description>Entry FunctionType in FunctionType4 is required</description>
			<test>containsFunctionType == true</test>
			<error>
				<message>Entry FunctionType in FunctionType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-FunctionType-Integer" testNumber="6"/>
			<description>Entry FunctionType with type Integer in FunctionType4 shall have value 4</description>
			<test>FunctionTypeHasTypeInteger != true || FunctionTypeIntegerValue == 4</test>
			<error>
				<message>Entry FunctionType with type Integer in FunctionType4 has incorrect value %1 instead of 4</message>
				<arguments>
					<argument>FunctionTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Length" testNumber="8"/>
			<description>Entry Length in FunctionType4 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in FunctionType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Length" testNumber="7"/>
			<description>Entry Length in FunctionType4 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in FunctionType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Range" testNumber="8"/>
			<description>Entry Range in FunctionType4 shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in FunctionType4 has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Range" testNumber="7"/>
			<description>Entry Range in FunctionType4 is required</description>
			<test>containsRange == true</test>
			<error>
				<message>Entry Range in FunctionType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AFunctionType4">
			<id specification="PDF_1_4" clause="FunctionType4-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in FunctionType4 shall satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</description>
			<test>RangeHasTypeArray != true || ((RangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry Range with type Array in FunctionType4 does not satisfy special case: fn:Eval((fn:ArrayLength(Range) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray" testNumber="2"/>
			<description>GammaArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>GammaArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-0" testNumber="8"/>
			<description>Entry 0 in GammaArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt;= 0</test>
			<error>
				<message>Entry 0 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@0 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-1" testNumber="8"/>
			<description>Entry 1 in GammaArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue &gt;= 0</test>
			<error>
				<message>Entry 1 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-2" testNumber="8"/>
			<description>Entry 2 in GammaArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in GammaArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGammaArray">
			<id specification="PDF_1_4" clause="GammaArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in GammaArray shall satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt;= 0</test>
			<error>
				<message>Entry 2 with type Number in GammaArray does not satisfy possible value predicate: fn:Eval(@2 &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter" testNumber="1"/>
			<description>GraphicsStateParameter shall not contain entries except AAPL:AA, AAPL:ST, AIS, BG, BG2, BM, CA, D, FL, Font, HT, HTP, LC, LJ, LW, ML, OP, OPM, RI, SA, SM, SMask, TK, TR, TR2, Type, UCR, UCR2, ca, op</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AAPL:AA' &amp;&amp; elem != 'AAPL:ST' &amp;&amp; elem != 'AIS' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'BG2' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'D' &amp;&amp; elem != 'FL' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'HT' &amp;&amp; elem != 'HTO' &amp;&amp; elem != 'HTP' &amp;&amp; elem != 'LC' &amp;&amp; elem != 'LJ' &amp;&amp; elem != 'LW' &amp;&amp; elem != 'ML' &amp;&amp; elem != 'OP' &amp;&amp; elem != 'OPM' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'SA' &amp;&amp; elem != 'SM' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'TK' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'TR2' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UCR' &amp;&amp; elem != 'UCR2' &amp;&amp; elem != 'UseBlackPtComp' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'op' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>GraphicsStateParameter contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AAPL:AA' &amp;&amp; elem != 'AAPL:ST' &amp;&amp; elem != 'AIS' &amp;&amp; elem != 'BG' &amp;&amp; elem != 'BG2' &amp;&amp; elem != 'BM' &amp;&amp; elem != 'CA' &amp;&amp; elem != 'D' &amp;&amp; elem != 'FL' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'HT' &amp;&amp; elem != 'HTO' &amp;&amp; elem != 'HTP' &amp;&amp; elem != 'LC' &amp;&amp; elem != 'LJ' &amp;&amp; elem != 'LW' &amp;&amp; elem != 'ML' &amp;&amp; elem != 'OP' &amp;&amp; elem != 'OPM' &amp;&amp; elem != 'RI' &amp;&amp; elem != 'SA' &amp;&amp; elem != 'SM' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'TK' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'TR2' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UCR' &amp;&amp; elem != 'UCR2' &amp;&amp; elem != 'UseBlackPtComp' &amp;&amp; elem != 'ca' &amp;&amp; elem != 'op' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter" testNumber="22"/>
			<description>GraphicsStateParameter shall not contain entries HTO, UseBlackPtComp in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'HTO' || elem == 'UseBlackPtComp').length == 0</test>
			<error>
				<message>GraphicsStateParameter contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'HTO' || elem == 'UseBlackPtComp').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-AAPL:AA" testNumber="8"/>
			<description>Entry AAPL:AA in GraphicsStateParameter shall have type Boolean</description>
			<test>containsAAPLAA == false || AAPLAAHasTypeBoolean == true</test>
			<error>
				<message>Entry AAPL:AA in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AAPLAAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-AAPL:AA" testNumber="23"/>
			<description>Entry AAPL:AA in GraphicsStateParameter can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsAAPLAA == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry AAPL:AA in GraphicsStateParameter is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-AAPL:ST" testNumber="8"/>
			<description>Entry AAPL:ST in GraphicsStateParameter shall have one of types: Dictionary, Name</description>
			<test>containsAAPLST == false || AAPLSTHasTypeDictionary == true || AAPLSTHasTypeName == true</test>
			<error>
				<message>Entry AAPL:ST in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>AAPLSTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-AAPL:ST" testNumber="23"/>
			<description>Entry AAPL:ST in GraphicsStateParameter can only be present, if satisfy predicate fn:Extension(AAPL, 1.2)</description>
			<test>containsAAPLST == false || hasExtensionAAPL == true</test>
			<error>
				<message>Entry AAPL:ST in GraphicsStateParameter is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-AIS" testNumber="8"/>
			<description>Entry AIS in GraphicsStateParameter shall have type Boolean</description>
			<test>containsAIS == false || AISHasTypeBoolean == true</test>
			<error>
				<message>Entry AIS in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AISType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG-Dictionary" testNumber="17"/>
			<description>Entry BG with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>BGHasTypeDictionary != true || BG_size == 1</test>
			<error>
				<message>Entry BG with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG-Stream" testNumber="17"/>
			<description>Entry BG with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>BGHasTypeStream != true || BG_size == 1</test>
			<error>
				<message>Entry BG with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG" testNumber="8"/>
			<description>Entry BG in GraphicsStateParameter shall have one of types: Dictionary, Stream</description>
			<test>containsBG == false || BGHasTypeDictionary == true || BGHasTypeStream == true</test>
			<error>
				<message>Entry BG in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>BGType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG-Stream" testNumber="10"/>
			<description>Entry BG with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>BGHasTypeStream != true || isBGIndirect == true</test>
			<error>
				<message>Entry BG with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG2-Dictionary" testNumber="17"/>
			<description>Entry BG2 with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>BG2HasTypeDictionary != true || BG2_size == 1</test>
			<error>
				<message>Entry BG2 with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG2-Stream" testNumber="17"/>
			<description>Entry BG2 with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>BG2HasTypeStream != true || BG2_size == 1</test>
			<error>
				<message>Entry BG2 with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG2" testNumber="8"/>
			<description>Entry BG2 in GraphicsStateParameter shall have one of types: Dictionary, Name, Stream</description>
			<test>containsBG2 == false || BG2HasTypeDictionary == true || BG2HasTypeName == true || BG2HasTypeStream == true</test>
			<error>
				<message>Entry BG2 in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>BG2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BG2-Stream" testNumber="10"/>
			<description>Entry BG2 with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>BG2HasTypeStream != true || isBG2Indirect == true</test>
			<error>
				<message>Entry BG2 with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BM" testNumber="8"/>
			<description>Entry BM in GraphicsStateParameter shall have one of types: Array, Name</description>
			<test>containsBM == false || BMHasTypeArray == true || BMHasTypeName == true</test>
			<error>
				<message>Entry BM in GraphicsStateParameter has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>BMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BM-Name" testNumber="19"/>
			<description>Entry BM with type Name in GraphicsStateParameter should not have deprecated value Compatible</description>
			<test>BMNameValue != "Compatible"</test>
			<error>
				<message>Entry BM with type Name in GraphicsStateParameter has deprecated value Compatible</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-BM-Name" testNumber="6"/>
			<description>Entry BM with type Name in GraphicsStateParameter shall have one of values: Screen, ColorDodge, Saturation, Color, Luminosity, Darken, Difference, Compatible, Normal, SoftLight, ColorBurn, Multiply, Exclusion, HardLight, Hue, Overlay, Lighten</description>
			<test>BMHasTypeName != true || BMNameValue == "Compatible" || BMNameValue == "Normal" || BMNameValue == "Multiply" || BMNameValue == "Screen" || BMNameValue == "Difference" || BMNameValue == "Darken" || BMNameValue == "Lighten" || BMNameValue == "ColorDodge" || BMNameValue == "ColorBurn" || BMNameValue == "Exclusion" || BMNameValue == "HardLight" || BMNameValue == "Overlay" || BMNameValue == "SoftLight" || BMNameValue == "Luminosity" || BMNameValue == "Hue" || BMNameValue == "Saturation" || BMNameValue == "Color"</test>
			<error>
				<message>Entry BM with type Name in GraphicsStateParameter has incorrect value %1 instead of Screen, ColorDodge, Saturation, Color, Luminosity, Darken, Difference, Compatible, Normal, SoftLight, ColorBurn, Multiply, Exclusion, HardLight, Hue, Overlay, Lighten</message>
				<arguments>
					<argument>BMNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-CA" testNumber="8"/>
			<description>Entry CA in GraphicsStateParameter shall have type Number</description>
			<test>containsCA == false || CAHasTypeNumber == true</test>
			<error>
				<message>Entry CA in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>CAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-CA-Number" testNumber="14"/>
			<description>Entry CA with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@CA &gt;= 0) &amp;&amp; (@CA &lt;= 1))</description>
			<test>CAHasTypeNumber != true || (CANumberValue &gt;= 0) &amp;&amp; (CANumberValue &lt;= 1)</test>
			<error>
				<message>Entry CA with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@CA &gt;= 0) &amp;&amp; (@CA &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-D" testNumber="8"/>
			<description>Entry D in GraphicsStateParameter shall have type Array</description>
			<test>containsD == false || DHasTypeArray == true</test>
			<error>
				<message>Entry D in GraphicsStateParameter has type %1 instead of type Array</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-FL" testNumber="8"/>
			<description>Entry FL in GraphicsStateParameter shall have type Number</description>
			<test>containsFL == false || FLHasTypeNumber == true</test>
			<error>
				<message>Entry FL in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>FLType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-FL-Number" testNumber="14"/>
			<description>Entry FL with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval(@FL &gt; 0)</description>
			<test>FLHasTypeNumber != true || FLNumberValue &gt; 0</test>
			<error>
				<message>Entry FL with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval(@FL &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-Font" testNumber="8"/>
			<description>Entry Font in GraphicsStateParameter shall have type Array</description>
			<test>containsFont == false || FontHasTypeArray == true</test>
			<error>
				<message>Entry Font in GraphicsStateParameter has type %1 instead of type Array</message>
				<arguments>
					<argument>FontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HT-Dictionary" testNumber="17"/>
			<description>Entry HT with type Dictionary in GraphicsStateParameter shall be one of objects HalftoneType1, HalftoneType5</description>
			<test>HTHasTypeDictionary != true || HT_size == 1</test>
			<error>
				<message>Entry HT with type Dictionary in GraphicsStateParameter is not one of objects HalftoneType1, HalftoneType5</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HT-Stream" testNumber="17"/>
			<description>Entry HT with type Stream in GraphicsStateParameter shall be one of objects HalftoneType6, HalftoneType10, HalftoneType16</description>
			<test>HTHasTypeStream != true || HT_size == 1</test>
			<error>
				<message>Entry HT with type Stream in GraphicsStateParameter is not one of objects HalftoneType6, HalftoneType10, HalftoneType16</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HT" testNumber="8"/>
			<description>Entry HT in GraphicsStateParameter shall have one of types: Dictionary, Name, Stream</description>
			<test>containsHT == false || HTHasTypeDictionary == true || HTHasTypeName == true || HTHasTypeStream == true</test>
			<error>
				<message>Entry HT in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>HTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HT-Stream" testNumber="10"/>
			<description>Entry HT with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>HTHasTypeStream != true || isHTIndirect == true</test>
			<error>
				<message>Entry HT with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HTP" testNumber="8"/>
			<description>Entry HTP in GraphicsStateParameter shall have type Array</description>
			<test>containsHTP == false || HTPHasTypeArray == true</test>
			<error>
				<message>Entry HTP in GraphicsStateParameter has type %1 instead of type Array</message>
				<arguments>
					<argument>HTPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-HTP" testNumber="5"/>
			<description>Entry HTP in GraphicsStateParameter is deprecated since PDF 1.3</description>
			<test>containsHTP == false</test>
			<error>
				<message>Entry HTP in GraphicsStateParameter is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LC" testNumber="8"/>
			<description>Entry LC in GraphicsStateParameter shall have type Integer</description>
			<test>containsLC == false || LCHasTypeInteger == true</test>
			<error>
				<message>Entry LC in GraphicsStateParameter has type %1 instead of type Integer</message>
				<arguments>
					<argument>LCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LC-Integer" testNumber="14"/>
			<description>Entry LC with type Integer in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@LC &gt;= 0) &amp;&amp; (@LC &lt;= 2))</description>
			<test>LCHasTypeInteger != true || (LCIntegerValue &gt;= 0) &amp;&amp; (LCIntegerValue &lt;= 2)</test>
			<error>
				<message>Entry LC with type Integer in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@LC &gt;= 0) &amp;&amp; (@LC &lt;= 2))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LJ" testNumber="8"/>
			<description>Entry LJ in GraphicsStateParameter shall have type Integer</description>
			<test>containsLJ == false || LJHasTypeInteger == true</test>
			<error>
				<message>Entry LJ in GraphicsStateParameter has type %1 instead of type Integer</message>
				<arguments>
					<argument>LJType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LJ-Integer" testNumber="14"/>
			<description>Entry LJ with type Integer in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@LJ &gt;= 0) &amp;&amp; (@LJ &lt;= 2))</description>
			<test>LJHasTypeInteger != true || (LJIntegerValue &gt;= 0) &amp;&amp; (LJIntegerValue &lt;= 2)</test>
			<error>
				<message>Entry LJ with type Integer in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@LJ &gt;= 0) &amp;&amp; (@LJ &lt;= 2))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LW" testNumber="8"/>
			<description>Entry LW in GraphicsStateParameter shall have type Number</description>
			<test>containsLW == false || LWHasTypeNumber == true</test>
			<error>
				<message>Entry LW in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>LWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-LW-Number" testNumber="14"/>
			<description>Entry LW with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval(@LW &gt;= 0)</description>
			<test>LWHasTypeNumber != true || LWNumberValue &gt;= 0</test>
			<error>
				<message>Entry LW with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval(@LW &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-ML" testNumber="8"/>
			<description>Entry ML in GraphicsStateParameter shall have type Number</description>
			<test>containsML == false || MLHasTypeNumber == true</test>
			<error>
				<message>Entry ML in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>MLType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-ML-Number" testNumber="14"/>
			<description>Entry ML with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval(@ML &gt;= 1)</description>
			<test>MLHasTypeNumber != true || MLNumberValue &gt;= 1</test>
			<error>
				<message>Entry ML with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval(@ML &gt;= 1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-OP" testNumber="8"/>
			<description>Entry OP in GraphicsStateParameter shall have type Boolean</description>
			<test>containsOP == false || OPHasTypeBoolean == true</test>
			<error>
				<message>Entry OP in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-OPM" testNumber="8"/>
			<description>Entry OPM in GraphicsStateParameter shall have type Integer</description>
			<test>containsOPM == false || OPMHasTypeInteger == true</test>
			<error>
				<message>Entry OPM in GraphicsStateParameter has type %1 instead of type Integer</message>
				<arguments>
					<argument>OPMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-OPM-Integer" testNumber="14"/>
			<description>Entry OPM with type Integer in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@OPM &gt;= 0) &amp;&amp; (@OPM &lt;= 1))</description>
			<test>OPMHasTypeInteger != true || (OPMIntegerValue &gt;= 0) &amp;&amp; (OPMIntegerValue &lt;= 1)</test>
			<error>
				<message>Entry OPM with type Integer in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@OPM &gt;= 0) &amp;&amp; (@OPM &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-RI" testNumber="8"/>
			<description>Entry RI in GraphicsStateParameter shall have type Name</description>
			<test>containsRI == false || RIHasTypeName == true</test>
			<error>
				<message>Entry RI in GraphicsStateParameter has type %1 instead of type Name</message>
				<arguments>
					<argument>RIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-RI-Name" testNumber="6"/>
			<description>Entry RI with type Name in GraphicsStateParameter shall have one of values: AbsoluteColorimetric, Perceptual, Saturation, RelativeColorimetric</description>
			<test>RIHasTypeName != true || RINameValue == "AbsoluteColorimetric" || RINameValue == "RelativeColorimetric" || RINameValue == "Saturation" || RINameValue == "Perceptual"</test>
			<error>
				<message>Entry RI with type Name in GraphicsStateParameter has incorrect value %1 instead of AbsoluteColorimetric, Perceptual, Saturation, RelativeColorimetric</message>
				<arguments>
					<argument>RINameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SA" testNumber="8"/>
			<description>Entry SA in GraphicsStateParameter shall have type Boolean</description>
			<test>containsSA == false || SAHasTypeBoolean == true</test>
			<error>
				<message>Entry SA in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SM" testNumber="8"/>
			<description>Entry SM in GraphicsStateParameter shall have type Number</description>
			<test>containsSM == false || SMHasTypeNumber == true</test>
			<error>
				<message>Entry SM in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>SMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SM-Number" testNumber="14"/>
			<description>Entry SM with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@SM &gt;= 0) &amp;&amp; (@SM &lt;= 1))</description>
			<test>SMHasTypeNumber != true || (SMNumberValue &gt;= 0) &amp;&amp; (SMNumberValue &lt;= 1)</test>
			<error>
				<message>Entry SM with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@SM &gt;= 0) &amp;&amp; (@SM &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SMask-Dictionary" testNumber="17"/>
			<description>Entry SMask with type Dictionary in GraphicsStateParameter shall be one of objects SoftMaskAlpha, SoftMaskLuminosity</description>
			<test>SMaskHasTypeDictionary != true || SMask_size == 1</test>
			<error>
				<message>Entry SMask with type Dictionary in GraphicsStateParameter is not one of objects SoftMaskAlpha, SoftMaskLuminosity</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SMask" testNumber="8"/>
			<description>Entry SMask in GraphicsStateParameter shall have one of types: Dictionary, Name</description>
			<test>containsSMask == false || SMaskHasTypeDictionary == true || SMaskHasTypeName == true</test>
			<error>
				<message>Entry SMask in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name</message>
				<arguments>
					<argument>SMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-SMask-Name" testNumber="6"/>
			<description>Entry SMask with type Name in GraphicsStateParameter shall have value None</description>
			<test>SMaskHasTypeName != true || SMaskNameValue == "None"</test>
			<error>
				<message>Entry SMask with type Name in GraphicsStateParameter has incorrect value %1 instead of None</message>
				<arguments>
					<argument>SMaskNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TK" testNumber="8"/>
			<description>Entry TK in GraphicsStateParameter shall have type Boolean</description>
			<test>containsTK == false || TKHasTypeBoolean == true</test>
			<error>
				<message>Entry TK in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>TKType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR-Dictionary" testNumber="17"/>
			<description>Entry TR with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>TRHasTypeDictionary != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR-Stream" testNumber="17"/>
			<description>Entry TR with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>TRHasTypeStream != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR" testNumber="8"/>
			<description>Entry TR in GraphicsStateParameter shall have one of types: Array, Dictionary, Name, Stream</description>
			<test>containsTR == false || TRHasTypeArray == true || TRHasTypeDictionary == true || TRHasTypeName == true || TRHasTypeStream == true</test>
			<error>
				<message>Entry TR in GraphicsStateParameter has type %1 instead of one of types: Array, Dictionary, Name, Stream</message>
				<arguments>
					<argument>TRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR-Stream" testNumber="10"/>
			<description>Entry TR with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>TRHasTypeStream != true || isTRIndirect == true</test>
			<error>
				<message>Entry TR with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR2-Dictionary" testNumber="17"/>
			<description>Entry TR2 with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>TR2HasTypeDictionary != true || TR2_size == 1</test>
			<error>
				<message>Entry TR2 with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR2-Stream" testNumber="17"/>
			<description>Entry TR2 with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>TR2HasTypeStream != true || TR2_size == 1</test>
			<error>
				<message>Entry TR2 with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR2" testNumber="8"/>
			<description>Entry TR2 in GraphicsStateParameter shall have one of types: Array, Dictionary, Name, Stream</description>
			<test>containsTR2 == false || TR2HasTypeArray == true || TR2HasTypeDictionary == true || TR2HasTypeName == true || TR2HasTypeStream == true</test>
			<error>
				<message>Entry TR2 in GraphicsStateParameter has type %1 instead of one of types: Array, Dictionary, Name, Stream</message>
				<arguments>
					<argument>TR2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-TR2-Stream" testNumber="10"/>
			<description>Entry TR2 with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>TR2HasTypeStream != true || isTR2Indirect == true</test>
			<error>
				<message>Entry TR2 with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-Type" testNumber="8"/>
			<description>Entry Type in GraphicsStateParameter shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in GraphicsStateParameter has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in GraphicsStateParameter shall have value ExtGState</description>
			<test>TypeHasTypeName != true || TypeNameValue == "ExtGState"</test>
			<error>
				<message>Entry Type with type Name in GraphicsStateParameter has incorrect value %1 instead of ExtGState</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR-Dictionary" testNumber="17"/>
			<description>Entry UCR with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>UCRHasTypeDictionary != true || UCR_size == 1</test>
			<error>
				<message>Entry UCR with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR-Stream" testNumber="17"/>
			<description>Entry UCR with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>UCRHasTypeStream != true || UCR_size == 1</test>
			<error>
				<message>Entry UCR with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR" testNumber="8"/>
			<description>Entry UCR in GraphicsStateParameter shall have one of types: Dictionary, Stream</description>
			<test>containsUCR == false || UCRHasTypeDictionary == true || UCRHasTypeStream == true</test>
			<error>
				<message>Entry UCR in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>UCRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR-Stream" testNumber="10"/>
			<description>Entry UCR with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>UCRHasTypeStream != true || isUCRIndirect == true</test>
			<error>
				<message>Entry UCR with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR2-Dictionary" testNumber="17"/>
			<description>Entry UCR2 with type Dictionary in GraphicsStateParameter shall be one of objects FunctionType2, FunctionType3</description>
			<test>UCR2HasTypeDictionary != true || UCR2_size == 1</test>
			<error>
				<message>Entry UCR2 with type Dictionary in GraphicsStateParameter is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR2-Stream" testNumber="17"/>
			<description>Entry UCR2 with type Stream in GraphicsStateParameter shall be one of objects FunctionType0, FunctionType4</description>
			<test>UCR2HasTypeStream != true || UCR2_size == 1</test>
			<error>
				<message>Entry UCR2 with type Stream in GraphicsStateParameter is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR2" testNumber="8"/>
			<description>Entry UCR2 in GraphicsStateParameter shall have one of types: Dictionary, Name, Stream</description>
			<test>containsUCR2 == false || UCR2HasTypeDictionary == true || UCR2HasTypeName == true || UCR2HasTypeStream == true</test>
			<error>
				<message>Entry UCR2 in GraphicsStateParameter has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>UCR2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-UCR2-Stream" testNumber="10"/>
			<description>Entry UCR2 with type Stream in GraphicsStateParameter shall be indirect</description>
			<test>UCR2HasTypeStream != true || isUCR2Indirect == true</test>
			<error>
				<message>Entry UCR2 with type Stream in GraphicsStateParameter is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-ca" testNumber="8"/>
			<description>Entry ca in GraphicsStateParameter shall have type Number</description>
			<test>containsca == false || caHasTypeNumber == true</test>
			<error>
				<message>Entry ca in GraphicsStateParameter has type %1 instead of type Number</message>
				<arguments>
					<argument>caType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-ca-Number" testNumber="14"/>
			<description>Entry ca with type Number in GraphicsStateParameter shall satisfy possible value predicate: fn:Eval((@ca &gt;= 0) &amp;&amp; (@ca &lt;= 1))</description>
			<test>caHasTypeNumber != true || (caNumberValue &gt;= 0) &amp;&amp; (caNumberValue &lt;= 1)</test>
			<error>
				<message>Entry ca with type Number in GraphicsStateParameter does not satisfy possible value predicate: fn:Eval((@ca &gt;= 0) &amp;&amp; (@ca &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameter">
			<id specification="PDF_1_4" clause="GraphicsStateParameter-op" testNumber="8"/>
			<description>Entry op in GraphicsStateParameter shall have type Boolean</description>
			<test>containsop == false || opHasTypeBoolean == true</test>
			<error>
				<message>Entry op in GraphicsStateParameter has type %1 instead of type Boolean</message>
				<arguments>
					<argument>opType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGraphicsStateParameterMapEntry">
			<id specification="PDF_1_4" clause="GraphicsStateParameterMapEntry" testNumber="8"/>
			<description>Entry in GraphicsStateParameterMap shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in GraphicsStateParameterMap has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes" testNumber="1"/>
			<description>GroupAttributes shall not contain entries except CS, I, K, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CS' &amp;&amp; elem != 'I' &amp;&amp; elem != 'K' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>GroupAttributes contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CS' &amp;&amp; elem != 'I' &amp;&amp; elem != 'K' &amp;&amp; elem != 'S' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-CS-Array" testNumber="17"/>
			<description>Entry CS with type Array in GroupAttributes shall be one of objects CalGrayColorSpace, CalRGBColorSpace, ICCBasedColorSpace</description>
			<test>CSHasTypeArray != true || CS_size == 1</test>
			<error>
				<message>Entry CS with type Array in GroupAttributes is not one of objects CalGrayColorSpace, CalRGBColorSpace, ICCBasedColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-CS" testNumber="8"/>
			<description>Entry CS in GroupAttributes shall have one of types: Array, Name</description>
			<test>containsCS == false || CSHasTypeArray == true || CSHasTypeName == true</test>
			<error>
				<message>Entry CS in GroupAttributes has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>CSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-CS-Name" testNumber="6"/>
			<description>Entry CS with type Name in GroupAttributes shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>CSHasTypeName != true || CSNameValue == "DeviceCMYK" || CSNameValue == "DeviceRGB" || CSNameValue == "DeviceGray"</test>
			<error>
				<message>Entry CS with type Name in GroupAttributes has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>CSNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-I" testNumber="8"/>
			<description>Entry I in GroupAttributes shall have type Boolean</description>
			<test>containsI == false || IHasTypeBoolean == true</test>
			<error>
				<message>Entry I in GroupAttributes has type %1 instead of type Boolean</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-K" testNumber="8"/>
			<description>Entry K in GroupAttributes shall have type Boolean</description>
			<test>containsK == false || KHasTypeBoolean == true</test>
			<error>
				<message>Entry K in GroupAttributes has type %1 instead of type Boolean</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-S" testNumber="8"/>
			<description>Entry S in GroupAttributes shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in GroupAttributes has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-S" testNumber="7"/>
			<description>Entry S in GroupAttributes is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in GroupAttributes is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-S-Name" testNumber="6"/>
			<description>Entry S with type Name in GroupAttributes shall have value Transparency</description>
			<test>SHasTypeName != true || SNameValue == "Transparency"</test>
			<error>
				<message>Entry S with type Name in GroupAttributes has incorrect value %1 instead of Transparency</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-Type" testNumber="8"/>
			<description>Entry Type in GroupAttributes shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in GroupAttributes has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AGroupAttributes">
			<id specification="PDF_1_4" clause="GroupAttributes-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in GroupAttributes shall have value Group</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Group"</test>
			<error>
				<message>Entry Type with type Name in GroupAttributes has incorrect value %1 instead of Group</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1" testNumber="1"/>
			<description>HalftoneType1 shall not contain entries except AccurateScreens, Angle, Frequency, HalftoneName, HalftoneType, SpotFunction, TransferFunction, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AccurateScreens' &amp;&amp; elem != 'Angle' &amp;&amp; elem != 'Frequency' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'SpotFunction' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AccurateScreens' &amp;&amp; elem != 'Angle' &amp;&amp; elem != 'Frequency' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'SpotFunction' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-AccurateScreens" testNumber="8"/>
			<description>Entry AccurateScreens in HalftoneType1 shall have type Boolean</description>
			<test>containsAccurateScreens == false || AccurateScreensHasTypeBoolean == true</test>
			<error>
				<message>Entry AccurateScreens in HalftoneType1 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AccurateScreensType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Angle" testNumber="8"/>
			<description>Entry Angle in HalftoneType1 shall have type Number</description>
			<test>containsAngle == false || AngleHasTypeNumber == true</test>
			<error>
				<message>Entry Angle in HalftoneType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>AngleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Angle" testNumber="7"/>
			<description>Entry Angle in HalftoneType1 is required</description>
			<test>containsAngle == true</test>
			<error>
				<message>Entry Angle in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Frequency" testNumber="8"/>
			<description>Entry Frequency in HalftoneType1 shall have type Number</description>
			<test>containsFrequency == false || FrequencyHasTypeNumber == true</test>
			<error>
				<message>Entry Frequency in HalftoneType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>FrequencyType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Frequency" testNumber="7"/>
			<description>Entry Frequency in HalftoneType1 is required</description>
			<test>containsFrequency == true</test>
			<error>
				<message>Entry Frequency in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Frequency-Number" testNumber="14"/>
			<description>Entry Frequency with type Number in HalftoneType1 shall satisfy possible value predicate: fn:Eval(@Frequency &gt;= 0)</description>
			<test>FrequencyHasTypeNumber != true || FrequencyNumberValue &gt;= 0</test>
			<error>
				<message>Entry Frequency with type Number in HalftoneType1 does not satisfy possible value predicate: fn:Eval(@Frequency &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType1 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType1 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType1 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType1 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType1 shall have value 1</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 1</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction-Dictionary" testNumber="17"/>
			<description>Entry SpotFunction with type Dictionary in HalftoneType1 shall be one of objects FunctionType2, FunctionType3</description>
			<test>SpotFunctionHasTypeDictionary != true || SpotFunction_size == 1</test>
			<error>
				<message>Entry SpotFunction with type Dictionary in HalftoneType1 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction-Stream" testNumber="17"/>
			<description>Entry SpotFunction with type Stream in HalftoneType1 shall be one of objects FunctionType0, FunctionType4</description>
			<test>SpotFunctionHasTypeStream != true || SpotFunction_size == 1</test>
			<error>
				<message>Entry SpotFunction with type Stream in HalftoneType1 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction" testNumber="8"/>
			<description>Entry SpotFunction in HalftoneType1 shall have one of types: Array, Dictionary, Name, Stream</description>
			<test>containsSpotFunction == false || SpotFunctionHasTypeArray == true || SpotFunctionHasTypeDictionary == true || SpotFunctionHasTypeName == true || SpotFunctionHasTypeStream == true</test>
			<error>
				<message>Entry SpotFunction in HalftoneType1 has type %1 instead of one of types: Array, Dictionary, Name, Stream</message>
				<arguments>
					<argument>SpotFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction" testNumber="7"/>
			<description>Entry SpotFunction in HalftoneType1 is required</description>
			<test>containsSpotFunction == true</test>
			<error>
				<message>Entry SpotFunction in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction-Name" testNumber="6"/>
			<description>Entry SpotFunction with type Name in HalftoneType1 shall have one of values: Ellipse, LineX, SimpleDot, LineY, Cross, InvertedDouble, Diamond, InvertedDoubleDot, Square, Double, InvertedEllipseC, InvertedEllipseA, Line, CosineDot, InvertedSimpleDot, Round, EllipseA, DoubleDot, EllipseC, Rhomboid, EllipseB</description>
			<test>SpotFunctionHasTypeName != true || SpotFunctionNameValue == "SimpleDot" || SpotFunctionNameValue == "InvertedSimpleDot" || SpotFunctionNameValue == "DoubleDot" || SpotFunctionNameValue == "InvertedDoubleDot" || SpotFunctionNameValue == "CosineDot" || SpotFunctionNameValue == "Double" || SpotFunctionNameValue == "InvertedDouble" || SpotFunctionNameValue == "Line" || SpotFunctionNameValue == "LineX" || SpotFunctionNameValue == "LineY" || SpotFunctionNameValue == "Round" || SpotFunctionNameValue == "Ellipse" || SpotFunctionNameValue == "EllipseA" || SpotFunctionNameValue == "InvertedEllipseA" || SpotFunctionNameValue == "EllipseB" || SpotFunctionNameValue == "EllipseC" || SpotFunctionNameValue == "InvertedEllipseC" || SpotFunctionNameValue == "Square" || SpotFunctionNameValue == "Cross" || SpotFunctionNameValue == "Rhomboid" || SpotFunctionNameValue == "Diamond"</test>
			<error>
				<message>Entry SpotFunction with type Name in HalftoneType1 has incorrect value %1 instead of Ellipse, LineX, SimpleDot, LineY, Cross, InvertedDouble, Diamond, InvertedDoubleDot, Square, Double, InvertedEllipseC, InvertedEllipseA, Line, CosineDot, InvertedSimpleDot, Round, EllipseA, DoubleDot, EllipseC, Rhomboid, EllipseB</message>
				<arguments>
					<argument>SpotFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-SpotFunction-Stream" testNumber="10"/>
			<description>Entry SpotFunction with type Stream in HalftoneType1 shall be indirect</description>
			<test>SpotFunctionHasTypeStream != true || isSpotFunctionIndirect == true</test>
			<error>
				<message>Entry SpotFunction with type Stream in HalftoneType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction-Dictionary" testNumber="17"/>
			<description>Entry TransferFunction with type Dictionary in HalftoneType1 shall be one of objects FunctionType2, FunctionType3</description>
			<test>TransferFunctionHasTypeDictionary != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Dictionary in HalftoneType1 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction-Stream" testNumber="17"/>
			<description>Entry TransferFunction with type Stream in HalftoneType1 shall be one of objects FunctionType0, FunctionType4</description>
			<test>TransferFunctionHasTypeStream != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType1 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType1 shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeDictionary == true || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType1 has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction" testNumber="11"/>
			<description>Entry TransferFunction in HalftoneType1 is required, when parent::@HalftoneType == 5</description>
			<test>parentHalftoneTypeHasTypeInteger == false || (containsTransferFunction == true || (parentHalftoneTypeIntegerValue != 5))</test>
			<error>
				<message>Entry TransferFunction in HalftoneType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType1 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType1 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType1 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType1">
			<id specification="PDF_1_4" clause="HalftoneType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType1 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType1 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10" testNumber="1"/>
			<description>HalftoneType10 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, HalftoneName, HalftoneType, Length, TransferFunction, Type, Xsquare, Ysquare</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Xsquare' &amp;&amp; elem != 'Ysquare' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType10 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Xsquare' &amp;&amp; elem != 'Ysquare' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10" testNumber="22"/>
			<description>HalftoneType10 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>HalftoneType10 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in HalftoneType10 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in HalftoneType10 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in HalftoneType10 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in HalftoneType10 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in HalftoneType10 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in HalftoneType10 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-F" testNumber="8"/>
			<description>Entry F in HalftoneType10 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in HalftoneType10 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in HalftoneType10 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in HalftoneType10 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in HalftoneType10 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in HalftoneType10 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in HalftoneType10 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in HalftoneType10 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FFilter" testNumber="8"/>
			<description>Entry FFilter in HalftoneType10 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in HalftoneType10 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in HalftoneType10 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in HalftoneType10 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in HalftoneType10 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in HalftoneType10 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Filter" testNumber="8"/>
			<description>Entry Filter in HalftoneType10 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in HalftoneType10 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in HalftoneType10 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in HalftoneType10 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in HalftoneType10 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in HalftoneType10 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType10 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType10 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType10 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType10 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType10 shall have value 10</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 10</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType10 has incorrect value %1 instead of 10</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Length" testNumber="8"/>
			<description>Entry Length in HalftoneType10 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Length" testNumber="7"/>
			<description>Entry Length in HalftoneType10 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction-Dictionary" testNumber="17"/>
			<description>Entry TransferFunction with type Dictionary in HalftoneType10 shall be one of objects FunctionType2, FunctionType3</description>
			<test>TransferFunctionHasTypeDictionary != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Dictionary in HalftoneType10 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction-Stream" testNumber="17"/>
			<description>Entry TransferFunction with type Stream in HalftoneType10 shall be one of objects FunctionType0, FunctionType4</description>
			<test>TransferFunctionHasTypeStream != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType10 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType10 shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeDictionary == true || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType10 has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction" testNumber="11"/>
			<description>Entry TransferFunction in HalftoneType10 is required, when parent::@HalftoneType == 5</description>
			<test>parentHalftoneTypeHasTypeInteger == false || (containsTransferFunction == true || (parentHalftoneTypeIntegerValue != 5))</test>
			<error>
				<message>Entry TransferFunction in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType10 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType10 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType10 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType10 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType10 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType10 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType10 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType10 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Xsquare" testNumber="8"/>
			<description>Entry Xsquare in HalftoneType10 shall have type Integer</description>
			<test>containsXsquare == false || XsquareHasTypeInteger == true</test>
			<error>
				<message>Entry Xsquare in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>XsquareType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Xsquare" testNumber="7"/>
			<description>Entry Xsquare in HalftoneType10 is required</description>
			<test>containsXsquare == true</test>
			<error>
				<message>Entry Xsquare in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Xsquare-Integer" testNumber="14"/>
			<description>Entry Xsquare with type Integer in HalftoneType10 shall satisfy possible value predicate: fn:Eval(@Xsquare &gt; 0)</description>
			<test>XsquareHasTypeInteger != true || XsquareIntegerValue &gt; 0</test>
			<error>
				<message>Entry Xsquare with type Integer in HalftoneType10 does not satisfy possible value predicate: fn:Eval(@Xsquare &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Ysquare" testNumber="8"/>
			<description>Entry Ysquare in HalftoneType10 shall have type Integer</description>
			<test>containsYsquare == false || YsquareHasTypeInteger == true</test>
			<error>
				<message>Entry Ysquare in HalftoneType10 has type %1 instead of type Integer</message>
				<arguments>
					<argument>YsquareType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Ysquare" testNumber="7"/>
			<description>Entry Ysquare in HalftoneType10 is required</description>
			<test>containsYsquare == true</test>
			<error>
				<message>Entry Ysquare in HalftoneType10 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType10">
			<id specification="PDF_1_4" clause="HalftoneType10-Ysquare-Integer" testNumber="14"/>
			<description>Entry Ysquare with type Integer in HalftoneType10 shall satisfy possible value predicate: fn:Eval(@Ysquare &gt; 0)</description>
			<test>YsquareHasTypeInteger != true || YsquareIntegerValue &gt; 0</test>
			<error>
				<message>Entry Ysquare with type Integer in HalftoneType10 does not satisfy possible value predicate: fn:Eval(@Ysquare &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16" testNumber="1"/>
			<description>HalftoneType16 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, HalftoneName, HalftoneType, Height, Height2, Length, TransferFunction, Type, Width, Width2</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Height2' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'Width2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType16 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Height2' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'Width2' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16" testNumber="22"/>
			<description>HalftoneType16 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>HalftoneType16 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in HalftoneType16 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in HalftoneType16 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in HalftoneType16 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in HalftoneType16 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in HalftoneType16 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in HalftoneType16 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-F" testNumber="8"/>
			<description>Entry F in HalftoneType16 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in HalftoneType16 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in HalftoneType16 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in HalftoneType16 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in HalftoneType16 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in HalftoneType16 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in HalftoneType16 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in HalftoneType16 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FFilter" testNumber="8"/>
			<description>Entry FFilter in HalftoneType16 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in HalftoneType16 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in HalftoneType16 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in HalftoneType16 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in HalftoneType16 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in HalftoneType16 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Filter" testNumber="8"/>
			<description>Entry Filter in HalftoneType16 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in HalftoneType16 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in HalftoneType16 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in HalftoneType16 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in HalftoneType16 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in HalftoneType16 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType16 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType16 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType16 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType16 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType16 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType16 shall have value 16</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 16</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType16 has incorrect value %1 instead of 16</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height" testNumber="8"/>
			<description>Entry Height in HalftoneType16 shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height" testNumber="7"/>
			<description>Entry Height in HalftoneType16 is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in HalftoneType16 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height-Integer" testNumber="14"/>
			<description>Entry Height with type Integer in HalftoneType16 shall satisfy possible value predicate: fn:Eval(@Height &gt; 0)</description>
			<test>HeightHasTypeInteger != true || HeightIntegerValue &gt; 0</test>
			<error>
				<message>Entry Height with type Integer in HalftoneType16 does not satisfy possible value predicate: fn:Eval(@Height &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height2" testNumber="8"/>
			<description>Entry Height2 in HalftoneType16 shall have type Integer</description>
			<test>containsHeight2 == false || Height2HasTypeInteger == true</test>
			<error>
				<message>Entry Height2 in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Height2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height2-Integer" testNumber="14"/>
			<description>Entry Height2 with type Integer in HalftoneType16 shall satisfy possible value predicate: fn:Eval(@Height2 &gt; 0)</description>
			<test>Height2HasTypeInteger != true || Height2IntegerValue &gt; 0</test>
			<error>
				<message>Entry Height2 with type Integer in HalftoneType16 does not satisfy possible value predicate: fn:Eval(@Height2 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Height2-Integer" testNumber="9"/>
			<description>Entry Height2 with type Integer in HalftoneType16 shall satisfy special case: fn:IsPresent(Width2)</description>
			<test>Height2HasTypeInteger != true || (containsWidth2 == true)</test>
			<error>
				<message>Entry Height2 with type Integer in HalftoneType16 does not satisfy special case: fn:IsPresent(Width2)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Length" testNumber="8"/>
			<description>Entry Length in HalftoneType16 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Length" testNumber="7"/>
			<description>Entry Length in HalftoneType16 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in HalftoneType16 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction-Dictionary" testNumber="17"/>
			<description>Entry TransferFunction with type Dictionary in HalftoneType16 shall be one of objects FunctionType2, FunctionType3</description>
			<test>TransferFunctionHasTypeDictionary != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Dictionary in HalftoneType16 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction-Stream" testNumber="17"/>
			<description>Entry TransferFunction with type Stream in HalftoneType16 shall be one of objects FunctionType0, FunctionType4</description>
			<test>TransferFunctionHasTypeStream != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType16 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType16 shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeDictionary == true || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType16 has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction" testNumber="11"/>
			<description>Entry TransferFunction in HalftoneType16 is required, when parent::@HalftoneType == 5</description>
			<test>parentHalftoneTypeHasTypeInteger == false || (containsTransferFunction == true || (parentHalftoneTypeIntegerValue != 5))</test>
			<error>
				<message>Entry TransferFunction in HalftoneType16 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType16 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType16 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType16 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType16 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType16 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType16 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType16 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType16 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Width" testNumber="8"/>
			<description>Entry Width in HalftoneType16 shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Width" testNumber="7"/>
			<description>Entry Width in HalftoneType16 is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in HalftoneType16 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Width-Integer" testNumber="14"/>
			<description>Entry Width with type Integer in HalftoneType16 shall satisfy possible value predicate: fn:Eval(@Width &gt; 0)</description>
			<test>WidthHasTypeInteger != true || WidthIntegerValue &gt; 0</test>
			<error>
				<message>Entry Width with type Integer in HalftoneType16 does not satisfy possible value predicate: fn:Eval(@Width &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Width2" testNumber="8"/>
			<description>Entry Width2 in HalftoneType16 shall have type Integer</description>
			<test>containsWidth2 == false || Width2HasTypeInteger == true</test>
			<error>
				<message>Entry Width2 in HalftoneType16 has type %1 instead of type Integer</message>
				<arguments>
					<argument>Width2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType16">
			<id specification="PDF_1_4" clause="HalftoneType16-Width2-Integer" testNumber="14"/>
			<description>Entry Width2 with type Integer in HalftoneType16 shall satisfy possible value predicate: fn:Eval(@Width2 &gt; 0)</description>
			<test>Width2HasTypeInteger != true || Width2IntegerValue &gt; 0</test>
			<error>
				<message>Entry Width2 with type Integer in HalftoneType16 does not satisfy possible value predicate: fn:Eval(@Width2 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Default-Stream" testNumber="17"/>
			<description>Entry Default with type Stream in HalftoneType5 shall be one of objects HalftoneType6, HalftoneType10, HalftoneType16</description>
			<test>DefaultHasTypeStream != true || Default_size == 1</test>
			<error>
				<message>Entry Default with type Stream in HalftoneType5 is not one of objects HalftoneType6, HalftoneType10, HalftoneType16</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Default" testNumber="8"/>
			<description>Entry Default in HalftoneType5 shall have one of types: Dictionary, Stream</description>
			<test>containsDefault == false || DefaultHasTypeDictionary == true || DefaultHasTypeStream == true</test>
			<error>
				<message>Entry Default in HalftoneType5 has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>DefaultType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Default" testNumber="7"/>
			<description>Entry Default in HalftoneType5 is required</description>
			<test>containsDefault == true</test>
			<error>
				<message>Entry Default in HalftoneType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Default-Stream" testNumber="10"/>
			<description>Entry Default with type Stream in HalftoneType5 shall be indirect</description>
			<test>DefaultHasTypeStream != true || isDefaultIndirect == true</test>
			<error>
				<message>Entry Default with type Stream in HalftoneType5 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType5 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType5 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType5 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType5 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType5 shall have value 5</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 5</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType5 has incorrect value %1 instead of 5</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType5 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType5 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5">
			<id specification="PDF_1_4" clause="HalftoneType5-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType5 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType5 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_4" clause="HalftoneType5Entry-Stream" testNumber="17"/>
			<description>Entry with type Stream in HalftoneType5 shall be one of objects HalftoneType6, HalftoneType10, HalftoneType16</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in HalftoneType5 is not one of objects HalftoneType6, HalftoneType10, HalftoneType16</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_4" clause="HalftoneType5Entry" testNumber="8"/>
			<description>Entry in HalftoneType5 shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in HalftoneType5 has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType5Entry">
			<id specification="PDF_1_4" clause="HalftoneType5Entry-Stream" testNumber="10"/>
			<description>Entry with type Stream in HalftoneType5 shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in HalftoneType5 is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6" testNumber="1"/>
			<description>HalftoneType6 shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, HalftoneName, HalftoneType, Height, Length, TransferFunction, Type, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>HalftoneType6 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'HalftoneName' &amp;&amp; elem != 'HalftoneType' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'TransferFunction' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6" testNumber="22"/>
			<description>HalftoneType6 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>HalftoneType6 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in HalftoneType6 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in HalftoneType6 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in HalftoneType6 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in HalftoneType6 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in HalftoneType6 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in HalftoneType6 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-F" testNumber="8"/>
			<description>Entry F in HalftoneType6 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in HalftoneType6 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in HalftoneType6 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in HalftoneType6 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in HalftoneType6 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in HalftoneType6 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in HalftoneType6 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in HalftoneType6 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FFilter" testNumber="8"/>
			<description>Entry FFilter in HalftoneType6 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in HalftoneType6 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in HalftoneType6 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in HalftoneType6 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in HalftoneType6 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in HalftoneType6 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Filter" testNumber="8"/>
			<description>Entry Filter in HalftoneType6 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in HalftoneType6 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in HalftoneType6 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in HalftoneType6 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in HalftoneType6 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in HalftoneType6 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-HalftoneName" testNumber="8"/>
			<description>Entry HalftoneName in HalftoneType6 shall have type StringByte</description>
			<test>containsHalftoneName == false || HalftoneNameHasTypeStringByte == true</test>
			<error>
				<message>Entry HalftoneName in HalftoneType6 has type %1 instead of type StringByte</message>
				<arguments>
					<argument>HalftoneNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-HalftoneType" testNumber="8"/>
			<description>Entry HalftoneType in HalftoneType6 shall have type Integer</description>
			<test>containsHalftoneType == false || HalftoneTypeHasTypeInteger == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HalftoneTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-HalftoneType" testNumber="7"/>
			<description>Entry HalftoneType in HalftoneType6 is required</description>
			<test>containsHalftoneType == true</test>
			<error>
				<message>Entry HalftoneType in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-HalftoneType-Integer" testNumber="6"/>
			<description>Entry HalftoneType with type Integer in HalftoneType6 shall have value 6</description>
			<test>HalftoneTypeHasTypeInteger != true || HalftoneTypeIntegerValue == 6</test>
			<error>
				<message>Entry HalftoneType with type Integer in HalftoneType6 has incorrect value %1 instead of 6</message>
				<arguments>
					<argument>HalftoneTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Height" testNumber="8"/>
			<description>Entry Height in HalftoneType6 shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Height" testNumber="7"/>
			<description>Entry Height in HalftoneType6 is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Height-Integer" testNumber="14"/>
			<description>Entry Height with type Integer in HalftoneType6 shall satisfy possible value predicate: fn:Eval(@Height &gt;= 0)</description>
			<test>HeightHasTypeInteger != true || HeightIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Height with type Integer in HalftoneType6 does not satisfy possible value predicate: fn:Eval(@Height &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Length" testNumber="8"/>
			<description>Entry Length in HalftoneType6 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Length" testNumber="7"/>
			<description>Entry Length in HalftoneType6 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-TransferFunction-Dictionary" testNumber="17"/>
			<description>Entry TransferFunction with type Dictionary in HalftoneType6 shall be one of objects FunctionType2, FunctionType3</description>
			<test>TransferFunctionHasTypeDictionary != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Dictionary in HalftoneType6 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-TransferFunction-Stream" testNumber="17"/>
			<description>Entry TransferFunction with type Stream in HalftoneType6 shall be one of objects FunctionType0, FunctionType4</description>
			<test>TransferFunctionHasTypeStream != true || TransferFunction_size == 1</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType6 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-TransferFunction" testNumber="8"/>
			<description>Entry TransferFunction in HalftoneType6 shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTransferFunction == false || TransferFunctionHasTypeDictionary == true || TransferFunctionHasTypeName == true || TransferFunctionHasTypeStream == true</test>
			<error>
				<message>Entry TransferFunction in HalftoneType6 has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TransferFunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-TransferFunction-Name" testNumber="6"/>
			<description>Entry TransferFunction with type Name in HalftoneType6 shall have value Identity</description>
			<test>TransferFunctionHasTypeName != true || TransferFunctionNameValue == "Identity"</test>
			<error>
				<message>Entry TransferFunction with type Name in HalftoneType6 has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TransferFunctionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-TransferFunction-Stream" testNumber="10"/>
			<description>Entry TransferFunction with type Stream in HalftoneType6 shall be indirect</description>
			<test>TransferFunctionHasTypeStream != true || isTransferFunctionIndirect == true</test>
			<error>
				<message>Entry TransferFunction with type Stream in HalftoneType6 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Type" testNumber="8"/>
			<description>Entry Type in HalftoneType6 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in HalftoneType6 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in HalftoneType6 shall have value Halftone</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Halftone"</test>
			<error>
				<message>Entry Type with type Name in HalftoneType6 has incorrect value %1 instead of Halftone</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Width" testNumber="8"/>
			<description>Entry Width in HalftoneType6 shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in HalftoneType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Width" testNumber="7"/>
			<description>Entry Width in HalftoneType6 is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in HalftoneType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AHalftoneType6">
			<id specification="PDF_1_4" clause="HalftoneType6-Width-Integer" testNumber="14"/>
			<description>Entry Width with type Integer in HalftoneType6 shall satisfy possible value predicate: fn:Eval(@Width &gt; 0)</description>
			<test>WidthHasTypeInteger != true || WidthIntegerValue &gt; 0</test>
			<error>
				<message>Entry Width with type Integer in HalftoneType6 does not satisfy possible value predicate: fn:Eval(@Width &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCBasedColorSpace">
			<id specification="PDF_1_4" clause="ICCBasedColorSpace" testNumber="2"/>
			<description>ICCBasedColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>ICCBasedColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCBasedColorSpace">
			<id specification="PDF_1_4" clause="ICCBasedColorSpace-0" testNumber="8"/>
			<description>Entry 0 in ICCBasedColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in ICCBasedColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCBasedColorSpace">
			<id specification="PDF_1_4" clause="ICCBasedColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in ICCBasedColorSpace shall have value ICCBased</description>
			<test>entry0HasTypeName != true || entry0NameValue == "ICCBased"</test>
			<error>
				<message>Entry 0 with type Name in ICCBasedColorSpace has incorrect value %1 instead of ICCBased</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCBasedColorSpace">
			<id specification="PDF_1_4" clause="ICCBasedColorSpace-1" testNumber="8"/>
			<description>Entry 1 in ICCBasedColorSpace shall have type Stream</description>
			<test>size &lt;= 1 || entry1HasTypeStream == true</test>
			<error>
				<message>Entry 1 in ICCBasedColorSpace has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCBasedColorSpace">
			<id specification="PDF_1_4" clause="ICCBasedColorSpace-1-Stream" testNumber="10"/>
			<description>Entry 1 with type Stream in ICCBasedColorSpace shall be indirect</description>
			<test>entry1HasTypeStream != true || isentry1Indirect == true</test>
			<error>
				<message>Entry 1 with type Stream in ICCBasedColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream" testNumber="1"/>
			<description>ICCProfileStream shall not contain entries except Alternate, DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Metadata, N, Range</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Alternate' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'N' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ICCProfileStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Alternate' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'N' &amp;&amp; elem != 'Range' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream" testNumber="22"/>
			<description>ICCProfileStream shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ICCProfileStream contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Alternate-Array" testNumber="17"/>
			<description>Entry Alternate with type Array in ICCProfileStream shall be one of objects CalGrayColorSpace, CalRGBColorSpace, DeviceNColorSpace, IndexedColorSpace, LabColorSpace, SeparationColorSpace</description>
			<test>AlternateHasTypeArray != true || Alternate_size == 1</test>
			<error>
				<message>Entry Alternate with type Array in ICCProfileStream is not one of objects CalGrayColorSpace, CalRGBColorSpace, DeviceNColorSpace, IndexedColorSpace, LabColorSpace, SeparationColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Alternate" testNumber="8"/>
			<description>Entry Alternate in ICCProfileStream shall have one of types: Array, Name</description>
			<test>containsAlternate == false || AlternateHasTypeArray == true || AlternateHasTypeName == true</test>
			<error>
				<message>Entry Alternate in ICCProfileStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>AlternateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Alternate-Name" testNumber="6"/>
			<description>Entry Alternate with type Name in ICCProfileStream shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>AlternateHasTypeName != true || AlternateNameValue == "DeviceGray" || AlternateNameValue == "DeviceRGB" || AlternateNameValue == "DeviceCMYK"</test>
			<error>
				<message>Entry Alternate with type Name in ICCProfileStream has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>AlternateNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ICCProfileStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ICCProfileStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ICCProfileStream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ICCProfileStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ICCProfileStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ICCProfileStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-F" testNumber="8"/>
			<description>Entry F in ICCProfileStream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ICCProfileStream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ICCProfileStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ICCProfileStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ICCProfileStream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ICCProfileStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ICCProfileStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ICCProfileStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FFilter" testNumber="8"/>
			<description>Entry FFilter in ICCProfileStream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ICCProfileStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ICCProfileStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ICCProfileStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ICCProfileStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ICCProfileStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Filter" testNumber="8"/>
			<description>Entry Filter in ICCProfileStream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ICCProfileStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ICCProfileStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ICCProfileStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ICCProfileStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ICCProfileStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Length" testNumber="8"/>
			<description>Entry Length in ICCProfileStream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ICCProfileStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Length" testNumber="7"/>
			<description>Entry Length in ICCProfileStream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ICCProfileStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Metadata" testNumber="8"/>
			<description>Entry Metadata in ICCProfileStream shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in ICCProfileStream has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in ICCProfileStream shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in ICCProfileStream is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-N" testNumber="8"/>
			<description>Entry N in ICCProfileStream shall have type Integer</description>
			<test>containsN == false || NHasTypeInteger == true</test>
			<error>
				<message>Entry N in ICCProfileStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-N" testNumber="7"/>
			<description>Entry N in ICCProfileStream is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in ICCProfileStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-N-Integer" testNumber="6"/>
			<description>Entry N with type Integer in ICCProfileStream shall have one of values: 1, 3, 4</description>
			<test>NHasTypeInteger != true || NIntegerValue == 1 || NIntegerValue == 3 || NIntegerValue == 4</test>
			<error>
				<message>Entry N with type Integer in ICCProfileStream has incorrect value %1 instead of 1, 3, 4</message>
				<arguments>
					<argument>NIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Range" testNumber="8"/>
			<description>Entry Range in ICCProfileStream shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in ICCProfileStream has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AICCProfileStream">
			<id specification="PDF_1_4" clause="ICCProfileStream-Range-Array" testNumber="9"/>
			<description>Entry Range with type Array in ICCProfileStream shall satisfy special case: fn:Eval(fn:ArrayLength(Range) == (2 * @N))</description>
			<test>RangeHasTypeArray != true || (NHasTypeInteger == false || RangeArraySize == (2 * NIntegerValue))</test>
			<error>
				<message>Entry Range with type Array in ICCProfileStream does not satisfy special case: fn:Eval(fn:ArrayLength(Range) == (2 * @N))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit" testNumber="1"/>
			<description>IconFit shall not contain entries except A, S, SW</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'FB' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SW' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>IconFit contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'FB' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SW' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit" testNumber="22"/>
			<description>IconFit shall not contain entry FB in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsFB == false</test>
			<error>
				<message>IconFit contains entry FB</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-A" testNumber="8"/>
			<description>Entry A in IconFit shall have type Array</description>
			<test>containsA == false || AHasTypeArray == true</test>
			<error>
				<message>Entry A in IconFit has type %1 instead of type Array</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-A-Array" testNumber="9"/>
			<description>Entry A with type Array in IconFit shall satisfy special case: fn:Eval((A::@0 &gt;= 0) &amp;&amp; (A::@0 &lt;= 1) &amp;&amp; (A::@1 &gt;= 0) &amp;&amp; (A::@1 &lt;= 1))</description>
			<test>AHasTypeArray != true || ((A0HasTypeNumber == false || (A0NumberValue &gt;= 0) &amp;&amp; (A0NumberValue &lt;= 1)) &amp;&amp; (A1HasTypeNumber == false || (A1NumberValue &gt;= 0)) &amp;&amp; (A1HasTypeNumber == false || (A1NumberValue &lt;= 1)))</test>
			<error>
				<message>Entry A with type Array in IconFit does not satisfy special case: fn:Eval((A::@0 &gt;= 0) &amp;&amp; (A::@0 &lt;= 1) &amp;&amp; (A::@1 &gt;= 0) &amp;&amp; (A::@1 &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-S" testNumber="8"/>
			<description>Entry S in IconFit shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in IconFit has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-S-Name" testNumber="6"/>
			<description>Entry S with type Name in IconFit shall have one of values: P, A</description>
			<test>SHasTypeName != true || SNameValue == "A" || SNameValue == "P"</test>
			<error>
				<message>Entry S with type Name in IconFit has incorrect value %1 instead of P, A</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-SW" testNumber="8"/>
			<description>Entry SW in IconFit shall have type Name</description>
			<test>containsSW == false || SWHasTypeName == true</test>
			<error>
				<message>Entry SW in IconFit has type %1 instead of type Name</message>
				<arguments>
					<argument>SWType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIconFit">
			<id specification="PDF_1_4" clause="IconFit-SW-Name" testNumber="6"/>
			<description>Entry SW with type Name in IconFit shall have one of values: A, B, S, N</description>
			<test>SWHasTypeName != true || SWNameValue == "A" || SWNameValue == "B" || SWNameValue == "S" || SWNameValue == "N"</test>
			<error>
				<message>Entry SW with type Name in IconFit has incorrect value %1 instead of A, B, S, N</message>
				<arguments>
					<argument>SWNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace" testNumber="2"/>
			<description>IndexedColorSpace shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>IndexedColorSpace contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-0" testNumber="8"/>
			<description>Entry 0 in IndexedColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in IndexedColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in IndexedColorSpace shall have value Indexed</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Indexed"</test>
			<error>
				<message>Entry 0 with type Name in IndexedColorSpace has incorrect value %1 instead of Indexed</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-1-Array" testNumber="17"/>
			<description>Entry 1 with type Array in IndexedColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>entry1HasTypeArray != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Array in IndexedColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-1" testNumber="8"/>
			<description>Entry 1 in IndexedColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 1 || entry1HasTypeArray == true || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in IndexedColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in IndexedColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry1HasTypeName != true || entry1NameValue == "DeviceCMYK" || entry1NameValue == "DeviceRGB" || entry1NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 1 with type Name in IndexedColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-2" testNumber="8"/>
			<description>Entry 2 in IndexedColorSpace shall have type Integer</description>
			<test>size &lt;= 2 || entry2HasTypeInteger == true</test>
			<error>
				<message>Entry 2 in IndexedColorSpace has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-2-Integer" testNumber="14"/>
			<description>Entry 2 with type Integer in IndexedColorSpace shall satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 255))</description>
			<test>entry2HasTypeInteger != true || (entry2IntegerValue &gt;= 0) &amp;&amp; (entry2IntegerValue &lt;= 255)</test>
			<error>
				<message>Entry 2 with type Integer in IndexedColorSpace does not satisfy possible value predicate: fn:Eval((@2 &gt;= 0) &amp;&amp; (@2 &lt;= 255))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-3" testNumber="8"/>
			<description>Entry 3 in IndexedColorSpace shall have one of types: Stream, String</description>
			<test>size &lt;= 3 || entry3HasTypeStream == true || entry3HasTypeString == true</test>
			<error>
				<message>Entry 3 in IndexedColorSpace has type %1 instead of one of types: Stream, String</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AIndexedColorSpace">
			<id specification="PDF_1_4" clause="IndexedColorSpace-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in IndexedColorSpace shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in IndexedColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm" testNumber="1"/>
			<description>InteractiveForm shall not contain entries except CO, DA, DR, Fields, NeedAppearances, Q, SigFlags</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CO' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DR' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'NeedAppearances' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'SigFlags' &amp;&amp; elem != 'XFA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>InteractiveForm contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CO' &amp;&amp; elem != 'DA' &amp;&amp; elem != 'DR' &amp;&amp; elem != 'Fields' &amp;&amp; elem != 'NeedAppearances' &amp;&amp; elem != 'Q' &amp;&amp; elem != 'SigFlags' &amp;&amp; elem != 'XFA' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm" testNumber="22"/>
			<description>InteractiveForm shall not contain entry XFA in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsXFA == false</test>
			<error>
				<message>InteractiveForm contains entry XFA</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-CO" testNumber="8"/>
			<description>Entry CO in InteractiveForm shall have type Array</description>
			<test>containsCO == false || COHasTypeArray == true</test>
			<error>
				<message>Entry CO in InteractiveForm has type %1 instead of type Array</message>
				<arguments>
					<argument>COType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-DA" testNumber="8"/>
			<description>Entry DA in InteractiveForm shall have type StringByte</description>
			<test>containsDA == false || DAHasTypeStringByte == true</test>
			<error>
				<message>Entry DA in InteractiveForm has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-DR" testNumber="8"/>
			<description>Entry DR in InteractiveForm shall have type Dictionary</description>
			<test>containsDR == false || DRHasTypeDictionary == true</test>
			<error>
				<message>Entry DR in InteractiveForm has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>DRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-DR-Dictionary" testNumber="9"/>
			<description>Entry DR with type Dictionary in InteractiveForm shall satisfy special case: fn:Eval(fn:IsPresent(DR::Font::*))</description>
			<test>DRHasTypeDictionary != true || (containsDRFontAny == true)</test>
			<error>
				<message>Entry DR with type Dictionary in InteractiveForm does not satisfy special case: fn:Eval(fn:IsPresent(DR::Font::*))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-Fields" testNumber="8"/>
			<description>Entry Fields in InteractiveForm shall have type Array</description>
			<test>containsFields == false || FieldsHasTypeArray == true</test>
			<error>
				<message>Entry Fields in InteractiveForm has type %1 instead of type Array</message>
				<arguments>
					<argument>FieldsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-Fields" testNumber="7"/>
			<description>Entry Fields in InteractiveForm is required</description>
			<test>containsFields == true</test>
			<error>
				<message>Entry Fields in InteractiveForm is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-NeedAppearances" testNumber="8"/>
			<description>Entry NeedAppearances in InteractiveForm shall have type Boolean</description>
			<test>containsNeedAppearances == false || NeedAppearancesHasTypeBoolean == true</test>
			<error>
				<message>Entry NeedAppearances in InteractiveForm has type %1 instead of type Boolean</message>
				<arguments>
					<argument>NeedAppearancesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-Q" testNumber="8"/>
			<description>Entry Q in InteractiveForm shall have type Integer</description>
			<test>containsQ == false || QHasTypeInteger == true</test>
			<error>
				<message>Entry Q in InteractiveForm has type %1 instead of type Integer</message>
				<arguments>
					<argument>QType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-Q-Integer" testNumber="6"/>
			<description>Entry Q with type Integer in InteractiveForm shall have one of values: 0, 1, 2</description>
			<test>QHasTypeInteger != true || QIntegerValue == 0 || QIntegerValue == 1 || QIntegerValue == 2</test>
			<error>
				<message>Entry Q with type Integer in InteractiveForm has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>QIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-SigFlags" testNumber="8"/>
			<description>Entry SigFlags in InteractiveForm shall have type Bitmask</description>
			<test>containsSigFlags == false || SigFlagsHasTypeBitmask == true</test>
			<error>
				<message>Entry SigFlags in InteractiveForm has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>SigFlagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AInteractiveForm">
			<id specification="PDF_1_4" clause="InteractiveForm-SigFlags-Bitmask" testNumber="9"/>
			<description>Entry SigFlags with type Bitmask in InteractiveForm shall satisfy special case: fn:Eval(fn:BitsClear(3, 32))</description>
			<test>SigFlagsHasTypeBitmask != true || ((SigFlagsBitmaskValue &gt;&gt; 2 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (SigFlagsBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry SigFlags with type Bitmask in InteractiveForm does not satisfy special case: fn:Eval(fn:BitsClear(3, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_4" clause="LabColorSpace" testNumber="2"/>
			<description>LabColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>LabColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_4" clause="LabColorSpace-0" testNumber="8"/>
			<description>Entry 0 in LabColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in LabColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_4" clause="LabColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in LabColorSpace shall have value Lab</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Lab"</test>
			<error>
				<message>Entry 0 with type Name in LabColorSpace has incorrect value %1 instead of Lab</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabColorSpace">
			<id specification="PDF_1_4" clause="LabColorSpace-1" testNumber="8"/>
			<description>Entry 1 in LabColorSpace shall have type Dictionary</description>
			<test>size &lt;= 1 || entry1HasTypeDictionary == true</test>
			<error>
				<message>Entry 1 in LabColorSpace has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_4" clause="LabDict" testNumber="1"/>
			<description>LabDict shall not contain entries except BlackPoint, Range, WhitePoint</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>LabDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BlackPoint' &amp;&amp; elem != 'Range' &amp;&amp; elem != 'WhitePoint' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_4" clause="LabDict-BlackPoint" testNumber="8"/>
			<description>Entry BlackPoint in LabDict shall have type Array</description>
			<test>containsBlackPoint == false || BlackPointHasTypeArray == true</test>
			<error>
				<message>Entry BlackPoint in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>BlackPointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_4" clause="LabDict-Range" testNumber="8"/>
			<description>Entry Range in LabDict shall have type Array</description>
			<test>containsRange == false || RangeHasTypeArray == true</test>
			<error>
				<message>Entry Range in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>RangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_4" clause="LabDict-WhitePoint" testNumber="8"/>
			<description>Entry WhitePoint in LabDict shall have type Array</description>
			<test>containsWhitePoint == false || WhitePointHasTypeArray == true</test>
			<error>
				<message>Entry WhitePoint in LabDict has type %1 instead of type Array</message>
				<arguments>
					<argument>WhitePointType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabDict">
			<id specification="PDF_1_4" clause="LabDict-WhitePoint" testNumber="7"/>
			<description>Entry WhitePoint in LabDict is required</description>
			<test>containsWhitePoint == true</test>
			<error>
				<message>Entry WhitePoint in LabDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray" testNumber="2"/>
			<description>LabRangeArray shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>LabRangeArray contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-0" testNumber="8"/>
			<description>Entry 0 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@0 &lt;= @1)</description>
			<test>entry0HasTypeNumber != true || (entry1HasTypeNumber == false || entry0NumberValue &lt;= entry1NumberValue)</test>
			<error>
				<message>Entry 0 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@0 &lt;= @1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-1" testNumber="8"/>
			<description>Entry 1 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-1-Number" testNumber="14"/>
			<description>Entry 1 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@1 &gt;= @0)</description>
			<test>entry1HasTypeNumber != true || (entry0HasTypeNumber == false || entry1NumberValue &gt;= entry0NumberValue)</test>
			<error>
				<message>Entry 1 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@1 &gt;= @0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-2" testNumber="8"/>
			<description>Entry 2 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@2 &lt;= @3)</description>
			<test>entry2HasTypeNumber != true || (entry3HasTypeNumber == false || entry2NumberValue &lt;= entry3NumberValue)</test>
			<error>
				<message>Entry 2 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@2 &lt;= @3)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-3" testNumber="8"/>
			<description>Entry 3 in LabRangeArray shall have type Number</description>
			<test>size &lt;= 3 || entry3HasTypeNumber == true</test>
			<error>
				<message>Entry 3 in LabRangeArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALabRangeArray">
			<id specification="PDF_1_4" clause="LabRangeArray-3-Number" testNumber="14"/>
			<description>Entry 3 with type Number in LabRangeArray shall satisfy possible value predicate: fn:Eval(@3 &gt;= @2)</description>
			<test>entry3HasTypeNumber != true || (entry2HasTypeNumber == false || entry3NumberValue &gt;= entry2NumberValue)</test>
			<error>
				<message>Entry 3 with type Number in LabRangeArray does not satisfy possible value predicate: fn:Eval(@3 &gt;= @2)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict" testNumber="1"/>
			<description>LinearizationParameterDict shall not contain entries except E, H, L, Linearized, N, O, P, T</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'E' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'Linearized' &amp;&amp; elem != 'N' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'T' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>LinearizationParameterDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'E' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'Linearized' &amp;&amp; elem != 'N' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'T' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-E" testNumber="8"/>
			<description>Entry E in LinearizationParameterDict shall have type Integer</description>
			<test>containsE == false || EHasTypeInteger == true</test>
			<error>
				<message>Entry E in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-E" testNumber="7"/>
			<description>Entry E in LinearizationParameterDict is required</description>
			<test>containsE == true</test>
			<error>
				<message>Entry E in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-E-Integer" testNumber="10"/>
			<description>Entry E with type Integer in LinearizationParameterDict shall be direct</description>
			<test>EHasTypeInteger != true || isEIndirect == false</test>
			<error>
				<message>Entry E with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-E-Integer" testNumber="14"/>
			<description>Entry E with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval((@E &gt; 0) &amp;&amp; (@E &lt;= @L))</description>
			<test>EHasTypeInteger != true || (EIntegerValue &gt; 0) &amp;&amp; (LHasTypeInteger == false || (EIntegerValue &lt;= LIntegerValue))</test>
			<error>
				<message>Entry E with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval((@E &gt; 0) &amp;&amp; (@E &lt;= @L))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-H-Array" testNumber="17"/>
			<description>Entry H with type Array in LinearizationParameterDict shall be one of objects ArrayOf_2Integers, ArrayOf_4Integers</description>
			<test>HHasTypeArray != true || H_size == 1</test>
			<error>
				<message>Entry H with type Array in LinearizationParameterDict is not one of objects ArrayOf_2Integers, ArrayOf_4Integers</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-H" testNumber="8"/>
			<description>Entry H in LinearizationParameterDict shall have type Array</description>
			<test>containsH == false || HHasTypeArray == true</test>
			<error>
				<message>Entry H in LinearizationParameterDict has type %1 instead of type Array</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-H" testNumber="7"/>
			<description>Entry H in LinearizationParameterDict is required</description>
			<test>containsH == true</test>
			<error>
				<message>Entry H in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-H-Array" testNumber="10"/>
			<description>Entry H with type Array in LinearizationParameterDict shall be direct</description>
			<test>HHasTypeArray != true || isHIndirect == false</test>
			<error>
				<message>Entry H with type Array in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-L" testNumber="8"/>
			<description>Entry L in LinearizationParameterDict shall have type Integer</description>
			<test>containsL == false || LHasTypeInteger == true</test>
			<error>
				<message>Entry L in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>LType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-L" testNumber="7"/>
			<description>Entry L in LinearizationParameterDict is required</description>
			<test>containsL == true</test>
			<error>
				<message>Entry L in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-L-Integer" testNumber="10"/>
			<description>Entry L with type Integer in LinearizationParameterDict shall be direct</description>
			<test>LHasTypeInteger != true || isLIndirect == false</test>
			<error>
				<message>Entry L with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-L-Integer" testNumber="14"/>
			<description>Entry L with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@L &gt; 0)</description>
			<test>LHasTypeInteger != true || LIntegerValue &gt; 0</test>
			<error>
				<message>Entry L with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@L &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-Linearized" testNumber="8"/>
			<description>Entry Linearized in LinearizationParameterDict shall have type Number</description>
			<test>containsLinearized == false || LinearizedHasTypeNumber == true</test>
			<error>
				<message>Entry Linearized in LinearizationParameterDict has type %1 instead of type Number</message>
				<arguments>
					<argument>LinearizedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-Linearized" testNumber="7"/>
			<description>Entry Linearized in LinearizationParameterDict is required</description>
			<test>containsLinearized == true</test>
			<error>
				<message>Entry Linearized in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-Linearized-Number" testNumber="10"/>
			<description>Entry Linearized with type Number in LinearizationParameterDict shall be direct</description>
			<test>LinearizedHasTypeNumber != true || isLinearizedIndirect == false</test>
			<error>
				<message>Entry Linearized with type Number in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-Linearized-Number" testNumber="6"/>
			<description>Entry Linearized with type Number in LinearizationParameterDict shall have value 1.0</description>
			<test>LinearizedHasTypeNumber != true || LinearizedNumberValue == 1.0</test>
			<error>
				<message>Entry Linearized with type Number in LinearizationParameterDict has incorrect value %1 instead of 1.0</message>
				<arguments>
					<argument>LinearizedNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-N" testNumber="8"/>
			<description>Entry N in LinearizationParameterDict shall have type Integer</description>
			<test>containsN == false || NHasTypeInteger == true</test>
			<error>
				<message>Entry N in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>NType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-N" testNumber="7"/>
			<description>Entry N in LinearizationParameterDict is required</description>
			<test>containsN == true</test>
			<error>
				<message>Entry N in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-N-Integer" testNumber="10"/>
			<description>Entry N with type Integer in LinearizationParameterDict shall be direct</description>
			<test>NHasTypeInteger != true || isNIndirect == false</test>
			<error>
				<message>Entry N with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-N-Integer" testNumber="14"/>
			<description>Entry N with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@N &gt; 0)</description>
			<test>NHasTypeInteger != true || NIntegerValue &gt; 0</test>
			<error>
				<message>Entry N with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@N &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-O" testNumber="8"/>
			<description>Entry O in LinearizationParameterDict shall have type Integer</description>
			<test>containsO == false || OHasTypeInteger == true</test>
			<error>
				<message>Entry O in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-O" testNumber="7"/>
			<description>Entry O in LinearizationParameterDict is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-O-Integer" testNumber="10"/>
			<description>Entry O with type Integer in LinearizationParameterDict shall be direct</description>
			<test>OHasTypeInteger != true || isOIndirect == false</test>
			<error>
				<message>Entry O with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-O-Integer" testNumber="14"/>
			<description>Entry O with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@O &gt; 0)</description>
			<test>OHasTypeInteger != true || OIntegerValue &gt; 0</test>
			<error>
				<message>Entry O with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@O &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-P" testNumber="8"/>
			<description>Entry P in LinearizationParameterDict shall have type Integer</description>
			<test>containsP == false || PHasTypeInteger == true</test>
			<error>
				<message>Entry P in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-P-Integer" testNumber="10"/>
			<description>Entry P with type Integer in LinearizationParameterDict shall be direct</description>
			<test>PHasTypeInteger != true || isPIndirect == false</test>
			<error>
				<message>Entry P with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-P-Integer" testNumber="14"/>
			<description>Entry P with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@P &gt;= 0)</description>
			<test>PHasTypeInteger != true || PIntegerValue &gt;= 0</test>
			<error>
				<message>Entry P with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@P &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-T" testNumber="8"/>
			<description>Entry T in LinearizationParameterDict shall have type Integer</description>
			<test>containsT == false || THasTypeInteger == true</test>
			<error>
				<message>Entry T in LinearizationParameterDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-T" testNumber="7"/>
			<description>Entry T in LinearizationParameterDict is required</description>
			<test>containsT == true</test>
			<error>
				<message>Entry T in LinearizationParameterDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-T-Integer" testNumber="10"/>
			<description>Entry T with type Integer in LinearizationParameterDict shall be direct</description>
			<test>THasTypeInteger != true || isTIndirect == false</test>
			<error>
				<message>Entry T with type Integer in LinearizationParameterDict is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ALinearizationParameterDict">
			<id specification="PDF_1_4" clause="LinearizationParameterDict-T-Integer" testNumber="14"/>
			<description>Entry T with type Integer in LinearizationParameterDict shall satisfy possible value predicate: fn:Eval(@T &gt; 0)</description>
			<test>THasTypeInteger != true || TIntegerValue &gt; 0</test>
			<error>
				<message>Entry T with type Integer in LinearizationParameterDict does not satisfy possible value predicate: fn:Eval(@T &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMac">
			<id specification="PDF_1_4" clause="Mac" testNumber="1"/>
			<description>Mac shall not contain entries except Creator, ResFork, Subtype</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Creator' &amp;&amp; elem != 'ResFork' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Mac contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Creator' &amp;&amp; elem != 'ResFork' &amp;&amp; elem != 'Subtype' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMac">
			<id specification="PDF_1_4" clause="Mac-Creator" testNumber="8"/>
			<description>Entry Creator in Mac shall have type Integer</description>
			<test>containsCreator == false || CreatorHasTypeInteger == true</test>
			<error>
				<message>Entry Creator in Mac has type %1 instead of type Integer</message>
				<arguments>
					<argument>CreatorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMac">
			<id specification="PDF_1_4" clause="Mac-ResFork" testNumber="8"/>
			<description>Entry ResFork in Mac shall have type Stream</description>
			<test>containsResFork == false || ResForkHasTypeStream == true</test>
			<error>
				<message>Entry ResFork in Mac has type %1 instead of type Stream</message>
				<arguments>
					<argument>ResForkType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMac">
			<id specification="PDF_1_4" clause="Mac-ResFork-Stream" testNumber="10"/>
			<description>Entry ResFork with type Stream in Mac shall be indirect</description>
			<test>ResForkHasTypeStream != true || isResForkIndirect == true</test>
			<error>
				<message>Entry ResFork with type Stream in Mac is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMac">
			<id specification="PDF_1_4" clause="Mac-Subtype" testNumber="8"/>
			<description>Entry Subtype in Mac shall have type Integer</description>
			<test>containsSubtype == false || SubtypeHasTypeInteger == true</test>
			<error>
				<message>Entry Subtype in Mac has type %1 instead of type Integer</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkInfo">
			<id specification="PDF_1_4" clause="MarkInfo" testNumber="1"/>
			<description>MarkInfo shall not contain entries except Marked</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Marked' &amp;&amp; elem != 'Suspects' &amp;&amp; elem != 'UserProperties' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MarkInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Marked' &amp;&amp; elem != 'Suspects' &amp;&amp; elem != 'UserProperties' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkInfo">
			<id specification="PDF_1_4" clause="MarkInfo" testNumber="22"/>
			<description>MarkInfo shall not contain entries Suspects, UserProperties in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Suspects' || elem == 'UserProperties').length == 0</test>
			<error>
				<message>MarkInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Suspects' || elem == 'UserProperties').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkInfo">
			<id specification="PDF_1_4" clause="MarkInfo-Marked" testNumber="8"/>
			<description>Entry Marked in MarkInfo shall have type Boolean</description>
			<test>containsMarked == false || MarkedHasTypeBoolean == true</test>
			<error>
				<message>Entry Marked in MarkInfo has type %1 instead of type Boolean</message>
				<arguments>
					<argument>MarkedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference" testNumber="1"/>
			<description>MarkedContentReference shall not contain entries except MCID, Pg, Stm, StmOwn, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'MCID' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Stm' &amp;&amp; elem != 'StmOwn' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MarkedContentReference contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'MCID' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Stm' &amp;&amp; elem != 'StmOwn' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-MCID" testNumber="8"/>
			<description>Entry MCID in MarkedContentReference shall have type Integer</description>
			<test>containsMCID == false || MCIDHasTypeInteger == true</test>
			<error>
				<message>Entry MCID in MarkedContentReference has type %1 instead of type Integer</message>
				<arguments>
					<argument>MCIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-MCID" testNumber="7"/>
			<description>Entry MCID in MarkedContentReference is required</description>
			<test>containsMCID == true</test>
			<error>
				<message>Entry MCID in MarkedContentReference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Pg" testNumber="8"/>
			<description>Entry Pg in MarkedContentReference shall have type Dictionary</description>
			<test>containsPg == false || PgHasTypeDictionary == true</test>
			<error>
				<message>Entry Pg in MarkedContentReference has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PgType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Pg-Dictionary" testNumber="10"/>
			<description>Entry Pg with type Dictionary in MarkedContentReference shall be indirect</description>
			<test>PgHasTypeDictionary != true || isPgIndirect == true</test>
			<error>
				<message>Entry Pg with type Dictionary in MarkedContentReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Stm" testNumber="8"/>
			<description>Entry Stm in MarkedContentReference shall have type Stream</description>
			<test>containsStm == false || StmHasTypeStream == true</test>
			<error>
				<message>Entry Stm in MarkedContentReference has type %1 instead of type Stream</message>
				<arguments>
					<argument>StmType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Stm-Stream" testNumber="10"/>
			<description>Entry Stm with type Stream in MarkedContentReference shall be indirect</description>
			<test>StmHasTypeStream != true || isStmIndirect == true</test>
			<error>
				<message>Entry Stm with type Stream in MarkedContentReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-StmOwn" testNumber="8"/>
			<description>Entry StmOwn in MarkedContentReference shall have one of types: Array, Dictionary, Stream</description>
			<test>containsStmOwn == false || StmOwnHasTypeArray == true || StmOwnHasTypeDictionary == true || StmOwnHasTypeStream == true</test>
			<error>
				<message>Entry StmOwn in MarkedContentReference has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>StmOwnType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-StmOwn-Array" testNumber="10"/>
			<description>Entry StmOwn with type Array in MarkedContentReference shall be indirect</description>
			<test>StmOwnHasTypeArray != true || isStmOwnIndirect == true</test>
			<error>
				<message>Entry StmOwn with type Array in MarkedContentReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-StmOwn-Dictionary" testNumber="10"/>
			<description>Entry StmOwn with type Dictionary in MarkedContentReference shall be indirect</description>
			<test>StmOwnHasTypeDictionary != true || isStmOwnIndirect == true</test>
			<error>
				<message>Entry StmOwn with type Dictionary in MarkedContentReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-StmOwn-Stream" testNumber="10"/>
			<description>Entry StmOwn with type Stream in MarkedContentReference shall be indirect</description>
			<test>StmOwnHasTypeStream != true || isStmOwnIndirect == true</test>
			<error>
				<message>Entry StmOwn with type Stream in MarkedContentReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Type" testNumber="8"/>
			<description>Entry Type in MarkedContentReference shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in MarkedContentReference has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Type" testNumber="7"/>
			<description>Entry Type in MarkedContentReference is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in MarkedContentReference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMarkedContentReference">
			<id specification="PDF_1_4" clause="MarkedContentReference-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in MarkedContentReference shall have value MCR</description>
			<test>TypeHasTypeName != true || TypeNameValue == "MCR"</test>
			<error>
				<message>Entry Type with type Name in MarkedContentReference has incorrect value %1 instead of MCR</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata" testNumber="1"/>
			<description>Metadata shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Metadata contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata" testNumber="22"/>
			<description>Metadata shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>Metadata contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in Metadata shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in Metadata is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in Metadata shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in Metadata has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in Metadata shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in Metadata does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-F" testNumber="8"/>
			<description>Entry F in Metadata shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Metadata has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in Metadata shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in Metadata is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in Metadata shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in Metadata has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in Metadata shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in Metadata does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FFilter" testNumber="8"/>
			<description>Entry FFilter in Metadata shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in Metadata has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in Metadata shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in Metadata does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in Metadata shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in Metadata has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Filter" testNumber="8"/>
			<description>Entry Filter in Metadata shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in Metadata has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in Metadata shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in Metadata does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in Metadata shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in Metadata has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Length" testNumber="8"/>
			<description>Entry Length in Metadata shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in Metadata has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Length" testNumber="7"/>
			<description>Entry Length in Metadata is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in Metadata is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Subtype" testNumber="8"/>
			<description>Entry Subtype in Metadata shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in Metadata has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Subtype" testNumber="7"/>
			<description>Entry Subtype in Metadata is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in Metadata is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in Metadata shall have value XML</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "XML"</test>
			<error>
				<message>Entry Subtype with type Name in Metadata has incorrect value %1 instead of XML</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Type" testNumber="8"/>
			<description>Entry Type in Metadata shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Metadata has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Type" testNumber="7"/>
			<description>Entry Type in Metadata is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in Metadata is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMetadata">
			<id specification="PDF_1_4" clause="Metadata-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Metadata shall have value Metadata</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Metadata"</test>
			<error>
				<message>Entry Type with type Name in Metadata has incorrect value %1 instead of Metadata</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam" testNumber="1"/>
			<description>MicrosoftWindowsLaunchParam shall not contain entries except D, F, O, P</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MicrosoftWindowsLaunchParam contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'D' &amp;&amp; elem != 'F' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-D" testNumber="8"/>
			<description>Entry D in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsD == false || DHasTypeStringByte == true</test>
			<error>
				<message>Entry D in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-F" testNumber="8"/>
			<description>Entry F in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsF == false || FHasTypeStringByte == true</test>
			<error>
				<message>Entry F in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-F" testNumber="7"/>
			<description>Entry F in MicrosoftWindowsLaunchParam is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in MicrosoftWindowsLaunchParam is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-O" testNumber="8"/>
			<description>Entry O in MicrosoftWindowsLaunchParam shall have type StringAscii</description>
			<test>containsO == false || OHasTypeStringAscii == true</test>
			<error>
				<message>Entry O in MicrosoftWindowsLaunchParam has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-O-StringAscii" testNumber="6"/>
			<description>Entry O with type StringAscii in MicrosoftWindowsLaunchParam shall have one of values: print, open</description>
			<test>OHasTypeStringAscii != true || OStringAsciiValue == "open" || OStringAsciiValue == "print"</test>
			<error>
				<message>Entry O with type StringAscii in MicrosoftWindowsLaunchParam has incorrect value %1 instead of print, open</message>
				<arguments>
					<argument>OStringAsciiValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMicrosoftWindowsLaunchParam">
			<id specification="PDF_1_4" clause="MicrosoftWindowsLaunchParam-P" testNumber="8"/>
			<description>Entry P in MicrosoftWindowsLaunchParam shall have type StringByte</description>
			<test>containsP == false || PHasTypeStringByte == true</test>
			<error>
				<message>Entry P in MicrosoftWindowsLaunchParam has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie" testNumber="1"/>
			<description>Movie shall not contain entries except Aspect, F, Poster, Rotate</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Aspect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Poster' &amp;&amp; elem != 'Rotate' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Movie contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Aspect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'Poster' &amp;&amp; elem != 'Rotate' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-Aspect" testNumber="8"/>
			<description>Entry Aspect in Movie shall have type Array</description>
			<test>containsAspect == false || AspectHasTypeArray == true</test>
			<error>
				<message>Entry Aspect in Movie has type %1 instead of type Array</message>
				<arguments>
					<argument>AspectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-F" testNumber="8"/>
			<description>Entry F in Movie shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Movie has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-F" testNumber="7"/>
			<description>Entry F in Movie is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in Movie is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-Poster" testNumber="8"/>
			<description>Entry Poster in Movie shall have one of types: Boolean, Stream</description>
			<test>containsPoster == false || PosterHasTypeBoolean == true || PosterHasTypeStream == true</test>
			<error>
				<message>Entry Poster in Movie has type %1 instead of one of types: Boolean, Stream</message>
				<arguments>
					<argument>PosterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-Poster-Stream" testNumber="10"/>
			<description>Entry Poster with type Stream in Movie shall be indirect</description>
			<test>PosterHasTypeStream != true || isPosterIndirect == true</test>
			<error>
				<message>Entry Poster with type Stream in Movie is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-Rotate" testNumber="8"/>
			<description>Entry Rotate in Movie shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in Movie has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovie">
			<id specification="PDF_1_4" clause="Movie-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in Movie shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in Movie does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation" testNumber="1"/>
			<description>MovieActivation shall not contain entries except Duration, FWPosition, FWScale, Mode, Rate, ShowControls, Start, Synchronous, Volume</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Duration' &amp;&amp; elem != 'FWPosition' &amp;&amp; elem != 'FWScale' &amp;&amp; elem != 'Mode' &amp;&amp; elem != 'Rate' &amp;&amp; elem != 'ShowControls' &amp;&amp; elem != 'Start' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Volume' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>MovieActivation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Duration' &amp;&amp; elem != 'FWPosition' &amp;&amp; elem != 'FWScale' &amp;&amp; elem != 'Mode' &amp;&amp; elem != 'Rate' &amp;&amp; elem != 'ShowControls' &amp;&amp; elem != 'Start' &amp;&amp; elem != 'Synchronous' &amp;&amp; elem != 'Volume' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Duration" testNumber="8"/>
			<description>Entry Duration in MovieActivation shall have one of types: Array, Integer, StringByte</description>
			<test>containsDuration == false || DurationHasTypeArray == true || DurationHasTypeInteger == true || DurationHasTypeStringByte == true</test>
			<error>
				<message>Entry Duration in MovieActivation has type %1 instead of one of types: Array, Integer, StringByte</message>
				<arguments>
					<argument>DurationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Duration-Integer" testNumber="9"/>
			<description>Entry Duration with type Integer in MovieActivation shall satisfy special case: fn:Eval(@Duration &gt; 0)</description>
			<test>DurationHasTypeInteger != true || (DurationIntegerValue &gt; 0)</test>
			<error>
				<message>Entry Duration with type Integer in MovieActivation does not satisfy special case: fn:Eval(@Duration &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Duration-StringByte" testNumber="9"/>
			<description>Entry Duration with type StringByte in MovieActivation shall satisfy special case: fn:Eval(fn:StringLength(Duration) == 8)</description>
			<test>DurationHasTypeStringByte != true || (DurationStringSize == 8)</test>
			<error>
				<message>Entry Duration with type StringByte in MovieActivation does not satisfy special case: fn:Eval(fn:StringLength(Duration) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-FWPosition" testNumber="8"/>
			<description>Entry FWPosition in MovieActivation shall have type Array</description>
			<test>containsFWPosition == false || FWPositionHasTypeArray == true</test>
			<error>
				<message>Entry FWPosition in MovieActivation has type %1 instead of type Array</message>
				<arguments>
					<argument>FWPositionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-FWPosition-Array" testNumber="9"/>
			<description>Entry FWPosition with type Array in MovieActivation shall satisfy special case: fn:Eval((FWPosition::@0 &gt;= 0.0) &amp;&amp; (FWPosition::@0 &lt;= 1.0) &amp;&amp; (FWPosition::@1 &gt;= 0.0) &amp;&amp; (FWPosition::@1 &lt;= 1.0))</description>
			<test>FWPositionHasTypeArray != true || ((FWPosition0HasTypeNumber == false || (FWPosition0NumberValue &gt;= 0.0) &amp;&amp; (FWPosition0NumberValue &lt;= 1.0)) &amp;&amp; (FWPosition1HasTypeNumber == false || (FWPosition1NumberValue &gt;= 0.0)) &amp;&amp; (FWPosition1HasTypeNumber == false || (FWPosition1NumberValue &lt;= 1.0)))</test>
			<error>
				<message>Entry FWPosition with type Array in MovieActivation does not satisfy special case: fn:Eval((FWPosition::@0 &gt;= 0.0) &amp;&amp; (FWPosition::@0 &lt;= 1.0) &amp;&amp; (FWPosition::@1 &gt;= 0.0) &amp;&amp; (FWPosition::@1 &lt;= 1.0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-FWScale" testNumber="8"/>
			<description>Entry FWScale in MovieActivation shall have type Array</description>
			<test>containsFWScale == false || FWScaleHasTypeArray == true</test>
			<error>
				<message>Entry FWScale in MovieActivation has type %1 instead of type Array</message>
				<arguments>
					<argument>FWScaleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-FWScale-Array" testNumber="9"/>
			<description>Entry FWScale with type Array in MovieActivation shall satisfy special case: fn:Eval((FWScale::@0 &gt; 0) &amp;&amp; (FWScale::@1 &gt; 0))</description>
			<test>FWScaleHasTypeArray != true || ((FWScale0HasTypeInteger == false || (FWScale0IntegerValue &gt; 0)) &amp;&amp; (FWScale1HasTypeInteger == false || (FWScale1IntegerValue &gt; 0)))</test>
			<error>
				<message>Entry FWScale with type Array in MovieActivation does not satisfy special case: fn:Eval((FWScale::@0 &gt; 0) &amp;&amp; (FWScale::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Mode" testNumber="8"/>
			<description>Entry Mode in MovieActivation shall have type Name</description>
			<test>containsMode == false || ModeHasTypeName == true</test>
			<error>
				<message>Entry Mode in MovieActivation has type %1 instead of type Name</message>
				<arguments>
					<argument>ModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Mode-Name" testNumber="6"/>
			<description>Entry Mode with type Name in MovieActivation shall have one of values: Palindrome, Once, Repeat, Open</description>
			<test>ModeHasTypeName != true || ModeNameValue == "Once" || ModeNameValue == "Open" || ModeNameValue == "Repeat" || ModeNameValue == "Palindrome"</test>
			<error>
				<message>Entry Mode with type Name in MovieActivation has incorrect value %1 instead of Palindrome, Once, Repeat, Open</message>
				<arguments>
					<argument>ModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Rate" testNumber="8"/>
			<description>Entry Rate in MovieActivation shall have type Number</description>
			<test>containsRate == false || RateHasTypeNumber == true</test>
			<error>
				<message>Entry Rate in MovieActivation has type %1 instead of type Number</message>
				<arguments>
					<argument>RateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-ShowControls" testNumber="8"/>
			<description>Entry ShowControls in MovieActivation shall have type Boolean</description>
			<test>containsShowControls == false || ShowControlsHasTypeBoolean == true</test>
			<error>
				<message>Entry ShowControls in MovieActivation has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ShowControlsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Start" testNumber="8"/>
			<description>Entry Start in MovieActivation shall have one of types: Array, Integer, StringByte</description>
			<test>containsStart == false || StartHasTypeArray == true || StartHasTypeInteger == true || StartHasTypeStringByte == true</test>
			<error>
				<message>Entry Start in MovieActivation has type %1 instead of one of types: Array, Integer, StringByte</message>
				<arguments>
					<argument>StartType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Start-Integer" testNumber="9"/>
			<description>Entry Start with type Integer in MovieActivation shall satisfy special case: fn:Eval(@Start &gt;= 0)</description>
			<test>StartHasTypeInteger != true || (StartIntegerValue &gt;= 0)</test>
			<error>
				<message>Entry Start with type Integer in MovieActivation does not satisfy special case: fn:Eval(@Start &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Start-StringByte" testNumber="9"/>
			<description>Entry Start with type StringByte in MovieActivation shall satisfy special case: fn:Eval(fn:StringLength(Start) == 8)</description>
			<test>StartHasTypeStringByte != true || (StartStringSize == 8)</test>
			<error>
				<message>Entry Start with type StringByte in MovieActivation does not satisfy special case: fn:Eval(fn:StringLength(Start) == 8)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Synchronous" testNumber="8"/>
			<description>Entry Synchronous in MovieActivation shall have type Boolean</description>
			<test>containsSynchronous == false || SynchronousHasTypeBoolean == true</test>
			<error>
				<message>Entry Synchronous in MovieActivation has type %1 instead of type Boolean</message>
				<arguments>
					<argument>SynchronousType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Volume" testNumber="8"/>
			<description>Entry Volume in MovieActivation shall have type Number</description>
			<test>containsVolume == false || VolumeHasTypeNumber == true</test>
			<error>
				<message>Entry Volume in MovieActivation has type %1 instead of type Number</message>
				<arguments>
					<argument>VolumeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AMovieActivation">
			<id specification="PDF_1_4" clause="MovieActivation-Volume-Number" testNumber="14"/>
			<description>Entry Volume with type Number in MovieActivation shall satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</description>
			<test>VolumeHasTypeNumber != true || (VolumeNumberValue &gt;= -1) &amp;&amp; (VolumeNumberValue &lt;= 1)</test>
			<error>
				<message>Entry Volume with type Number in MovieActivation does not satisfy possible value predicate: fn:Eval((@Volume &gt;= -1) &amp;&amp; (@Volume &lt;= 1))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name" testNumber="1"/>
			<description>Name shall not contain entries except AP, AlternatePresentations, Dests, EmbeddedFiles, IDS, JavaScript, Pages, Templates, URLS</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AP' &amp;&amp; elem != 'AlternatePresentations' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'EmbeddedFiles' &amp;&amp; elem != 'IDS' &amp;&amp; elem != 'JavaScript' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Renditions' &amp;&amp; elem != 'Templates' &amp;&amp; elem != 'URLS' &amp;&amp; elem != 'XFAResources' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Name contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AP' &amp;&amp; elem != 'AlternatePresentations' &amp;&amp; elem != 'Dests' &amp;&amp; elem != 'EmbeddedFiles' &amp;&amp; elem != 'IDS' &amp;&amp; elem != 'JavaScript' &amp;&amp; elem != 'Pages' &amp;&amp; elem != 'Renditions' &amp;&amp; elem != 'Templates' &amp;&amp; elem != 'URLS' &amp;&amp; elem != 'XFAResources' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name" testNumber="22"/>
			<description>Name shall not contain entries Renditions, XFAResources in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Renditions' || elem == 'XFAResources').length == 0</test>
			<error>
				<message>Name contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Renditions' || elem == 'XFAResources').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-AP" testNumber="8"/>
			<description>Entry AP in Name shall have type NameTree</description>
			<test>containsAP == false || APHasTypeNameTree == true</test>
			<error>
				<message>Entry AP in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>APType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-APTreeNode" testNumber="8"/>
			<description>Entry APTreeNode in Name shall have type NameTree</description>
			<test>containsAPTreeNode == false || APTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry APTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>APTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-AlternatePresentations" testNumber="8"/>
			<description>Entry AlternatePresentations in Name shall have type NameTree</description>
			<test>containsAlternatePresentations == false || AlternatePresentationsHasTypeNameTree == true</test>
			<error>
				<message>Entry AlternatePresentations in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>AlternatePresentationsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-AlternatePresentationsTreeNode" testNumber="8"/>
			<description>Entry AlternatePresentationsTreeNode in Name shall have type NameTree</description>
			<test>containsAlternatePresentationsTreeNode == false || AlternatePresentationsTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry AlternatePresentationsTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>AlternatePresentationsTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-Dests" testNumber="8"/>
			<description>Entry Dests in Name shall have type NameTree</description>
			<test>containsDests == false || DestsHasTypeNameTree == true</test>
			<error>
				<message>Entry Dests in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>DestsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-DestsTreeNode" testNumber="8"/>
			<description>Entry DestsTreeNode in Name shall have type NameTree</description>
			<test>containsDestsTreeNode == false || DestsTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry DestsTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>DestsTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-EmbeddedFiles" testNumber="8"/>
			<description>Entry EmbeddedFiles in Name shall have type NameTree</description>
			<test>containsEmbeddedFiles == false || EmbeddedFilesHasTypeNameTree == true</test>
			<error>
				<message>Entry EmbeddedFiles in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>EmbeddedFilesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-EmbeddedFilesTreeNode" testNumber="8"/>
			<description>Entry EmbeddedFilesTreeNode in Name shall have type NameTree</description>
			<test>containsEmbeddedFilesTreeNode == false || EmbeddedFilesTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry EmbeddedFilesTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>EmbeddedFilesTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-IDS" testNumber="8"/>
			<description>Entry IDS in Name shall have type NameTree</description>
			<test>containsIDS == false || IDSHasTypeNameTree == true</test>
			<error>
				<message>Entry IDS in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>IDSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-IDSTreeNode" testNumber="8"/>
			<description>Entry IDSTreeNode in Name shall have type NameTree</description>
			<test>containsIDSTreeNode == false || IDSTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry IDSTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>IDSTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-JavaScript" testNumber="8"/>
			<description>Entry JavaScript in Name shall have type NameTree</description>
			<test>containsJavaScript == false || JavaScriptHasTypeNameTree == true</test>
			<error>
				<message>Entry JavaScript in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>JavaScriptType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-JavaScriptTreeNode" testNumber="8"/>
			<description>Entry JavaScriptTreeNode in Name shall have type NameTree</description>
			<test>containsJavaScriptTreeNode == false || JavaScriptTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry JavaScriptTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>JavaScriptTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-Pages" testNumber="8"/>
			<description>Entry Pages in Name shall have type NameTree</description>
			<test>containsPages == false || PagesHasTypeNameTree == true</test>
			<error>
				<message>Entry Pages in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>PagesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-PagesTreeNode" testNumber="8"/>
			<description>Entry PagesTreeNode in Name shall have type NameTree</description>
			<test>containsPagesTreeNode == false || PagesTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry PagesTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>PagesTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-Templates" testNumber="8"/>
			<description>Entry Templates in Name shall have type NameTree</description>
			<test>containsTemplates == false || TemplatesHasTypeNameTree == true</test>
			<error>
				<message>Entry Templates in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>TemplatesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-TemplatesTreeNode" testNumber="8"/>
			<description>Entry TemplatesTreeNode in Name shall have type NameTree</description>
			<test>containsTemplatesTreeNode == false || TemplatesTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry TemplatesTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>TemplatesTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-URLS" testNumber="8"/>
			<description>Entry URLS in Name shall have type NameTree</description>
			<test>containsURLS == false || URLSHasTypeNameTree == true</test>
			<error>
				<message>Entry URLS in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>URLSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AName">
			<id specification="PDF_1_4" clause="Name-URLSTreeNode" testNumber="8"/>
			<description>Entry URLSTreeNode in Name shall have type NameTree</description>
			<test>containsURLSTreeNode == false || URLSTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry URLSTreeNode in Name has type %1 instead of type NameTree</message>
				<arguments>
					<argument>URLSTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeAPEntry">
			<id specification="PDF_1_4" clause="NameNameTreeAPEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in NameNameTreeAP shall be one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in NameNameTreeAP is not one of objects XObjectFormType1, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeAPEntry">
			<id specification="PDF_1_4" clause="NameNameTreeAPEntry" testNumber="8"/>
			<description>Entry in NameNameTreeAP shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeAP has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeAlternatePresentationsEntry">
			<id specification="PDF_1_4" clause="NameNameTreeAlternatePresentationsEntry" testNumber="8"/>
			<description>Entry in NameNameTreeAlternatePresentations shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeAlternatePresentations has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeDestsEntry">
			<id specification="PDF_1_4" clause="NameNameTreeDestsEntry-Array" testNumber="17"/>
			<description>Entry with type Array in NameNameTreeDests shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>HasTypeArray != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Array in NameNameTreeDests is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeDestsEntry">
			<id specification="PDF_1_4" clause="NameNameTreeDestsEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in NameNameTreeDests shall be one of objects ActionGoTo, ActionGoToR, DestDict</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in NameNameTreeDests is not one of objects ActionGoTo, ActionGoToR, DestDict</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeDestsEntry">
			<id specification="PDF_1_4" clause="NameNameTreeDestsEntry" testNumber="8"/>
			<description>Entry in NameNameTreeDests shall have one of types: Array, Dictionary</description>
			<test>HasTypeArray == true || HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeDests has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeEmbeddedFilesEntry">
			<id specification="PDF_1_4" clause="NameNameTreeEmbeddedFilesEntry" testNumber="8"/>
			<description>Entry in NameNameTreeEmbeddedFiles shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeEmbeddedFiles has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeIDSEntry">
			<id specification="PDF_1_4" clause="NameNameTreeIDSEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in NameNameTreeIDS shall be one of objects WebCaptureImageSet, WebCapturePageSet</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in NameNameTreeIDS is not one of objects WebCaptureImageSet, WebCapturePageSet</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeIDSEntry">
			<id specification="PDF_1_4" clause="NameNameTreeIDSEntry" testNumber="8"/>
			<description>Entry in NameNameTreeIDS shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeIDS has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeJavaScriptEntry">
			<id specification="PDF_1_4" clause="NameNameTreeJavaScriptEntry" testNumber="8"/>
			<description>Entry in NameNameTreeJavaScript shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeJavaScript has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreePagesEntry">
			<id specification="PDF_1_4" clause="NameNameTreePagesEntry" testNumber="8"/>
			<description>Entry in NameNameTreePages shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreePages has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeTemplatesEntry">
			<id specification="PDF_1_4" clause="NameNameTreeTemplatesEntry" testNumber="8"/>
			<description>Entry in NameNameTreeTemplates shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeTemplates has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeURLSEntry">
			<id specification="PDF_1_4" clause="NameNameTreeURLSEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in NameNameTreeURLS shall be one of objects WebCaptureImageSet, WebCapturePageSet</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in NameNameTreeURLS is not one of objects WebCaptureImageSet, WebCapturePageSet</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameNameTreeURLSEntry">
			<id specification="PDF_1_4" clause="NameNameTreeURLSEntry" testNumber="8"/>
			<description>Entry in NameNameTreeURLS shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameNameTreeURLS has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode" testNumber="1"/>
			<description>NameTreeNode shall not contain entries except Kids, Limits, Names</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Kids' &amp;&amp; elem != 'Limits' &amp;&amp; elem != 'Names' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>NameTreeNode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Kids' &amp;&amp; elem != 'Limits' &amp;&amp; elem != 'Names' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Kids" testNumber="8"/>
			<description>Entry Kids in NameTreeNode shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in NameTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Kids" testNumber="11"/>
			<description>Entry Kids in NameTreeNode is required, when fn:Not(fn:IsPresent(Names))</description>
			<test>containsKids == true || (containsNames == true)</test>
			<error>
				<message>Entry Kids in NameTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Kids-Array" testNumber="9"/>
			<description>Entry Kids with type Array in NameTreeNode shall satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Names)))</description>
			<test>KidsHasTypeArray != true || ((containsNames != true) || containsKids != true)</test>
			<error>
				<message>Entry Kids with type Array in NameTreeNode does not satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Names)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Limits" testNumber="8"/>
			<description>Entry Limits in NameTreeNode shall have type Array</description>
			<test>containsLimits == false || LimitsHasTypeArray == true</test>
			<error>
				<message>Entry Limits in NameTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>LimitsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Names" testNumber="8"/>
			<description>Entry Names in NameTreeNode shall have type Array</description>
			<test>containsNames == false || NamesHasTypeArray == true</test>
			<error>
				<message>Entry Names in NameTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>NamesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Names" testNumber="11"/>
			<description>Entry Names in NameTreeNode is required, when fn:Not(fn:IsPresent(Kids))</description>
			<test>containsNames == true || (containsKids == true)</test>
			<error>
				<message>Entry Names in NameTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNode">
			<id specification="PDF_1_4" clause="NameTreeNode-Names-Array" testNumber="9"/>
			<description>Entry Names with type Array in NameTreeNode shall satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Kids)))</description>
			<test>NamesHasTypeArray != true || ((containsKids != true) || containsNames != true)</test>
			<error>
				<message>Entry Names with type Array in NameTreeNode does not satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Kids)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NameTreeNodeLimitsArray" testNumber="2"/>
			<description>NameTreeNodeLimitsArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>NameTreeNodeLimitsArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NameTreeNodeLimitsArray-0" testNumber="8"/>
			<description>Entry 0 in NameTreeNodeLimitsArray shall have type String</description>
			<test>size &lt;= 0 || entry0HasTypeString == true</test>
			<error>
				<message>Entry 0 in NameTreeNodeLimitsArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NameTreeNodeLimitsArray-1" testNumber="8"/>
			<description>Entry 1 in NameTreeNodeLimitsArray shall have type String</description>
			<test>size &lt;= 1 || entry1HasTypeString == true</test>
			<error>
				<message>Entry 1 in NameTreeNodeLimitsArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeNamesArray">
			<id specification="PDF_1_4" clause="NameTreeNodeNamesArray" testNumber="3"/>
			<description>NameTreeNodeNamesArray shall contain 2 * n elements</description>
			<test>size % 2 == 0</test>
			<error>
				<message>NameTreeNodeNamesArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeNamesArraySubArray">
			<id specification="PDF_1_4" clause="NameTreeNodeNamesArraySubArray" testNumber="2"/>
			<description>NameTreeNodeNamesArraySubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>NameTreeNodeNamesArraySubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodeNamesArraySubArray">
			<id specification="PDF_1_4" clause="NameTreeNodeNamesArraySubArray-0" testNumber="8"/>
			<description>Entry 0 in NameTreeNodeNamesArraySubArray shall have type String</description>
			<test>size &lt;= 0 || entry0HasTypeString == true</test>
			<error>
				<message>Entry 0 in NameTreeNodeNamesArraySubArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANameTreeNodesArrayEntry">
			<id specification="PDF_1_4" clause="NameTreeNodesArrayEntry" testNumber="8"/>
			<description>Entry in NameTreeNodesArray shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NameTreeNodesArray has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode" testNumber="1"/>
			<description>NumberTreeNode shall not contain entries except Kids, Limits, Nums</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Kids' &amp;&amp; elem != 'Limits' &amp;&amp; elem != 'Nums' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>NumberTreeNode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Kids' &amp;&amp; elem != 'Limits' &amp;&amp; elem != 'Nums' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Kids" testNumber="8"/>
			<description>Entry Kids in NumberTreeNode shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in NumberTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Kids" testNumber="11"/>
			<description>Entry Kids in NumberTreeNode is required, when fn:Not(fn:IsPresent(Nums))</description>
			<test>containsKids == true || (containsNums == true)</test>
			<error>
				<message>Entry Kids in NumberTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Kids-Array" testNumber="9"/>
			<description>Entry Kids with type Array in NumberTreeNode shall satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Nums)))</description>
			<test>KidsHasTypeArray != true || ((containsNums != true) || containsKids != true)</test>
			<error>
				<message>Entry Kids with type Array in NumberTreeNode does not satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Nums)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Limits" testNumber="8"/>
			<description>Entry Limits in NumberTreeNode shall have type Array</description>
			<test>containsLimits == false || LimitsHasTypeArray == true</test>
			<error>
				<message>Entry Limits in NumberTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>LimitsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Nums" testNumber="8"/>
			<description>Entry Nums in NumberTreeNode shall have type Array</description>
			<test>containsNums == false || NumsHasTypeArray == true</test>
			<error>
				<message>Entry Nums in NumberTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>NumsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Nums" testNumber="11"/>
			<description>Entry Nums in NumberTreeNode is required, when fn:Not(fn:IsPresent(Kids))</description>
			<test>containsNums == true || (containsKids == true)</test>
			<error>
				<message>Entry Nums in NumberTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNode">
			<id specification="PDF_1_4" clause="NumberTreeNode-Nums-Array" testNumber="9"/>
			<description>Entry Nums with type Array in NumberTreeNode shall satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Kids))) &amp;&amp; fn:ArraySortAscending(Nums, 2)</description>
			<test>NumsHasTypeArray != true || (((containsKids != true) || containsNums != true) &amp;&amp; isNumsArraySortAscending2 == true)</test>
			<error>
				<message>Entry Nums with type Array in NumberTreeNode does not satisfy special case: fn:Not(fn:IsPresent(fn:IsPresent(Kids))) &amp;&amp; fn:ArraySortAscending(Nums, 2)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeLimitsArray" testNumber="2"/>
			<description>NumberTreeNodeLimitsArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>NumberTreeNodeLimitsArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeLimitsArray-0" testNumber="8"/>
			<description>Entry 0 in NumberTreeNodeLimitsArray shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in NumberTreeNodeLimitsArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeLimitsArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeLimitsArray-1" testNumber="8"/>
			<description>Entry 1 in NumberTreeNodeLimitsArray shall have type Integer</description>
			<test>size &lt;= 1 || entry1HasTypeInteger == true</test>
			<error>
				<message>Entry 1 in NumberTreeNodeLimitsArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeNumsArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeNumsArray" testNumber="3"/>
			<description>NumberTreeNodeNumsArray shall contain 2 * n elements</description>
			<test>size % 2 == 0</test>
			<error>
				<message>NumberTreeNodeNumsArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeNumsArraySubArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeNumsArraySubArray" testNumber="2"/>
			<description>NumberTreeNodeNumsArraySubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>NumberTreeNodeNumsArraySubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodeNumsArraySubArray">
			<id specification="PDF_1_4" clause="NumberTreeNodeNumsArraySubArray-0" testNumber="8"/>
			<description>Entry 0 in NumberTreeNodeNumsArraySubArray shall have type Integer</description>
			<test>size &lt;= 0 || entry0HasTypeInteger == true</test>
			<error>
				<message>Entry 0 in NumberTreeNodeNumsArraySubArray has type %1 instead of type Integer</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ANumberTreeNodesArrayEntry">
			<id specification="PDF_1_4" clause="NumberTreeNodesArrayEntry" testNumber="8"/>
			<description>Entry in NumberTreeNodesArray shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in NumberTreeNodesArray has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArray" testNumber="3"/>
			<description>OOAdditionalStmsArray shall contain 2 * n elements</description>
			<test>size % 2 == 0</test>
			<error>
				<message>OOAdditionalStmsArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArraySubArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArraySubArray" testNumber="2"/>
			<description>OOAdditionalStmsArraySubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>OOAdditionalStmsArraySubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArraySubArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArraySubArray-0" testNumber="8"/>
			<description>Entry 0 in OOAdditionalStmsArraySubArray shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in OOAdditionalStmsArraySubArray has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArraySubArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArraySubArray-0-Name" testNumber="10"/>
			<description>Entry 0 with type Name in OOAdditionalStmsArraySubArray shall be direct</description>
			<test>entry0HasTypeName != true || isentry0Indirect == false</test>
			<error>
				<message>Entry 0 with type Name in OOAdditionalStmsArraySubArray is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArraySubArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArraySubArray-1" testNumber="8"/>
			<description>Entry 1 in OOAdditionalStmsArraySubArray shall have type Stream</description>
			<test>size &lt;= 1 || entry1HasTypeStream == true</test>
			<error>
				<message>Entry 1 in OOAdditionalStmsArraySubArray has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOOAdditionalStmsArraySubArray">
			<id specification="PDF_1_4" clause="OOAdditionalStmsArraySubArray-1-Stream" testNumber="10"/>
			<description>Entry 1 with type Stream in OOAdditionalStmsArraySubArray shall be indirect</description>
			<test>entry1HasTypeStream != true || isentry1Indirect == true</test>
			<error>
				<message>Entry 1 with type Stream in OOAdditionalStmsArraySubArray is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13">
			<id specification="PDF_1_4" clause="OPIVersion13" testNumber="1"/>
			<description>OPIVersion13 shall not contain entries except 1.3</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != '1.3' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion13 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != '1.3' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13">
			<id specification="PDF_1_4" clause="OPIVersion13-1.3" testNumber="8"/>
			<description>Entry 1.3 in OPIVersion13 shall have type Dictionary</description>
			<test>contains13 == false || entry13HasTypeDictionary == true</test>
			<error>
				<message>Entry 1.3 in OPIVersion13 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry13Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict" testNumber="1"/>
			<description>OPIVersion13Dict shall not contain entries except Color, ColorType, Comments, CropFixed, CropRect, F, GrayMap, ID, ImageType, Overprint, Position, Resolution, Size, Tags, Tint, Transparency, Type, Version</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Color' &amp;&amp; elem != 'ColorType' &amp;&amp; elem != 'Comments' &amp;&amp; elem != 'CropFixed' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'GrayMap' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageType' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Position' &amp;&amp; elem != 'Resolution' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Tint' &amp;&amp; elem != 'Transparency' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion13Dict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Color' &amp;&amp; elem != 'ColorType' &amp;&amp; elem != 'Comments' &amp;&amp; elem != 'CropFixed' &amp;&amp; elem != 'CropRect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'GrayMap' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageType' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Position' &amp;&amp; elem != 'Resolution' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Tint' &amp;&amp; elem != 'Transparency' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Color" testNumber="8"/>
			<description>Entry Color in OPIVersion13Dict shall have type Array</description>
			<test>containsColor == false || ColorHasTypeArray == true</test>
			<error>
				<message>Entry Color in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ColorType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-ColorType" testNumber="8"/>
			<description>Entry ColorType in OPIVersion13Dict shall have type Name</description>
			<test>containsColorType == false || ColorTypeHasTypeName == true</test>
			<error>
				<message>Entry ColorType in OPIVersion13Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>ColorTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Comments" testNumber="8"/>
			<description>Entry Comments in OPIVersion13Dict shall have type StringText</description>
			<test>containsComments == false || CommentsHasTypeStringText == true</test>
			<error>
				<message>Entry Comments in OPIVersion13Dict has type %1 instead of type StringText</message>
				<arguments>
					<argument>CommentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-CropFixed" testNumber="8"/>
			<description>Entry CropFixed in OPIVersion13Dict shall have type Array</description>
			<test>containsCropFixed == false || CropFixedHasTypeArray == true</test>
			<error>
				<message>Entry CropFixed in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>CropFixedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-CropRect" testNumber="8"/>
			<description>Entry CropRect in OPIVersion13Dict shall have type Rectangle</description>
			<test>containsCropRect == false || CropRectHasTypeRectangle == true</test>
			<error>
				<message>Entry CropRect in OPIVersion13Dict has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropRectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-F" testNumber="8"/>
			<description>Entry F in OPIVersion13Dict shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in OPIVersion13Dict has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-F" testNumber="7"/>
			<description>Entry F in OPIVersion13Dict is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in OPIVersion13Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-GrayMap" testNumber="8"/>
			<description>Entry GrayMap in OPIVersion13Dict shall have type Array</description>
			<test>containsGrayMap == false || GrayMapHasTypeArray == true</test>
			<error>
				<message>Entry GrayMap in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>GrayMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-GrayMap-Array" testNumber="9"/>
			<description>Entry GrayMap with type Array in OPIVersion13Dict shall satisfy special case: fn:Eval((fn:ArrayLength(GrayMap) mod 2) == 0)</description>
			<test>GrayMapHasTypeArray != true || ((GrayMapArraySize % 2) == 0)</test>
			<error>
				<message>Entry GrayMap with type Array in OPIVersion13Dict does not satisfy special case: fn:Eval((fn:ArrayLength(GrayMap) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-ID" testNumber="8"/>
			<description>Entry ID in OPIVersion13Dict shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in OPIVersion13Dict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-ImageType" testNumber="8"/>
			<description>Entry ImageType in OPIVersion13Dict shall have type Array</description>
			<test>containsImageType == false || ImageTypeHasTypeArray == true</test>
			<error>
				<message>Entry ImageType in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ImageTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Overprint" testNumber="8"/>
			<description>Entry Overprint in OPIVersion13Dict shall have type Boolean</description>
			<test>containsOverprint == false || OverprintHasTypeBoolean == true</test>
			<error>
				<message>Entry Overprint in OPIVersion13Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OverprintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Position" testNumber="8"/>
			<description>Entry Position in OPIVersion13Dict shall have type Array</description>
			<test>containsPosition == false || PositionHasTypeArray == true</test>
			<error>
				<message>Entry Position in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>PositionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Resolution" testNumber="8"/>
			<description>Entry Resolution in OPIVersion13Dict shall have type Array</description>
			<test>containsResolution == false || ResolutionHasTypeArray == true</test>
			<error>
				<message>Entry Resolution in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>ResolutionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Size" testNumber="8"/>
			<description>Entry Size in OPIVersion13Dict shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Tags" testNumber="8"/>
			<description>Entry Tags in OPIVersion13Dict shall have type Array</description>
			<test>containsTags == false || TagsHasTypeArray == true</test>
			<error>
				<message>Entry Tags in OPIVersion13Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>TagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Tint" testNumber="8"/>
			<description>Entry Tint in OPIVersion13Dict shall have type Number</description>
			<test>containsTint == false || TintHasTypeNumber == true</test>
			<error>
				<message>Entry Tint in OPIVersion13Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>TintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Transparency" testNumber="8"/>
			<description>Entry Transparency in OPIVersion13Dict shall have type Boolean</description>
			<test>containsTransparency == false || TransparencyHasTypeBoolean == true</test>
			<error>
				<message>Entry Transparency in OPIVersion13Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>TransparencyType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Type" testNumber="8"/>
			<description>Entry Type in OPIVersion13Dict shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in OPIVersion13Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in OPIVersion13Dict shall have value OPI</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OPI"</test>
			<error>
				<message>Entry Type with type Name in OPIVersion13Dict has incorrect value %1 instead of OPI</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Version" testNumber="8"/>
			<description>Entry Version in OPIVersion13Dict shall have type Number</description>
			<test>containsVersion == false || VersionHasTypeNumber == true</test>
			<error>
				<message>Entry Version in OPIVersion13Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Version" testNumber="7"/>
			<description>Entry Version in OPIVersion13Dict is required</description>
			<test>containsVersion == true</test>
			<error>
				<message>Entry Version in OPIVersion13Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion13Dict">
			<id specification="PDF_1_4" clause="OPIVersion13Dict-Version-Number" testNumber="6"/>
			<description>Entry Version with type Number in OPIVersion13Dict shall have value 1.3</description>
			<test>VersionHasTypeNumber != true || VersionNumberValue == 1.3</test>
			<error>
				<message>Entry Version with type Number in OPIVersion13Dict has incorrect value %1 instead of 1.3</message>
				<arguments>
					<argument>VersionNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20">
			<id specification="PDF_1_4" clause="OPIVersion20" testNumber="1"/>
			<description>OPIVersion20 shall not contain entries except 2.0</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != '2.0' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion20 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != '2.0' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20">
			<id specification="PDF_1_4" clause="OPIVersion20-2.0" testNumber="8"/>
			<description>Entry 2.0 in OPIVersion20 shall have type Dictionary</description>
			<test>contains20 == false || entry20HasTypeDictionary == true</test>
			<error>
				<message>Entry 2.0 in OPIVersion20 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entry20Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict" testNumber="1"/>
			<description>OPIVersion20Dict shall not contain entries except CropRect, F, IncludedImageDimensions, IncludedImageQuality, Inks, MainImage, Overprint, Size, Tags, Type, Version</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CropRect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IncludedImageDimensions' &amp;&amp; elem != 'IncludedImageQuality' &amp;&amp; elem != 'Inks' &amp;&amp; elem != 'MainImage' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OPIVersion20Dict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CropRect' &amp;&amp; elem != 'F' &amp;&amp; elem != 'IncludedImageDimensions' &amp;&amp; elem != 'IncludedImageQuality' &amp;&amp; elem != 'Inks' &amp;&amp; elem != 'MainImage' &amp;&amp; elem != 'Overprint' &amp;&amp; elem != 'Size' &amp;&amp; elem != 'Tags' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Version' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-CropRect" testNumber="8"/>
			<description>Entry CropRect in OPIVersion20Dict shall have type Rectangle</description>
			<test>containsCropRect == false || CropRectHasTypeRectangle == true</test>
			<error>
				<message>Entry CropRect in OPIVersion20Dict has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropRectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-CropRect" testNumber="11"/>
			<description>Entry CropRect in OPIVersion20Dict is required, when fn:IsPresent(Size)</description>
			<test>containsCropRect == true || (containsSize != true)</test>
			<error>
				<message>Entry CropRect in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-F" testNumber="8"/>
			<description>Entry F in OPIVersion20Dict shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in OPIVersion20Dict has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-F" testNumber="7"/>
			<description>Entry F in OPIVersion20Dict is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-IncludedImageDimensions" testNumber="8"/>
			<description>Entry IncludedImageDimensions in OPIVersion20Dict shall have type Array</description>
			<test>containsIncludedImageDimensions == false || IncludedImageDimensionsHasTypeArray == true</test>
			<error>
				<message>Entry IncludedImageDimensions in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>IncludedImageDimensionsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-IncludedImageDimensions-Array" testNumber="9"/>
			<description>Entry IncludedImageDimensions with type Array in OPIVersion20Dict shall satisfy special case: fn:Eval((IncludedImageDimensions::@0 &gt; 0) &amp;&amp; (IncludedImageDimensions::@1 &gt; 0))</description>
			<test>IncludedImageDimensionsHasTypeArray != true || ((IncludedImageDimensions0HasTypeInteger == false || (IncludedImageDimensions0IntegerValue &gt; 0)) &amp;&amp; (IncludedImageDimensions1HasTypeInteger == false || (IncludedImageDimensions1IntegerValue &gt; 0)))</test>
			<error>
				<message>Entry IncludedImageDimensions with type Array in OPIVersion20Dict does not satisfy special case: fn:Eval((IncludedImageDimensions::@0 &gt; 0) &amp;&amp; (IncludedImageDimensions::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-IncludedImageQuality" testNumber="8"/>
			<description>Entry IncludedImageQuality in OPIVersion20Dict shall have type Number</description>
			<test>containsIncludedImageQuality == false || IncludedImageQualityHasTypeNumber == true</test>
			<error>
				<message>Entry IncludedImageQuality in OPIVersion20Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>IncludedImageQualityType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-IncludedImageQuality-Number" testNumber="6"/>
			<description>Entry IncludedImageQuality with type Number in OPIVersion20Dict shall have one of values: 1, 2, 3</description>
			<test>IncludedImageQualityHasTypeNumber != true || IncludedImageQualityNumberValue == 1 || IncludedImageQualityNumberValue == 2 || IncludedImageQualityNumberValue == 3</test>
			<error>
				<message>Entry IncludedImageQuality with type Number in OPIVersion20Dict has incorrect value %1 instead of 1, 2, 3</message>
				<arguments>
					<argument>IncludedImageQualityNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Inks" testNumber="8"/>
			<description>Entry Inks in OPIVersion20Dict shall have one of types: Array, Name</description>
			<test>containsInks == false || InksHasTypeArray == true || InksHasTypeName == true</test>
			<error>
				<message>Entry Inks in OPIVersion20Dict has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>InksType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Inks-Name" testNumber="6"/>
			<description>Entry Inks with type Name in OPIVersion20Dict shall have one of values: registration, full_color</description>
			<test>InksHasTypeName != true || InksNameValue == "full_color" || InksNameValue == "registration"</test>
			<error>
				<message>Entry Inks with type Name in OPIVersion20Dict has incorrect value %1 instead of registration, full_color</message>
				<arguments>
					<argument>InksNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-MainImage" testNumber="8"/>
			<description>Entry MainImage in OPIVersion20Dict shall have type StringByte</description>
			<test>containsMainImage == false || MainImageHasTypeStringByte == true</test>
			<error>
				<message>Entry MainImage in OPIVersion20Dict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>MainImageType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Overprint" testNumber="8"/>
			<description>Entry Overprint in OPIVersion20Dict shall have type Boolean</description>
			<test>containsOverprint == false || OverprintHasTypeBoolean == true</test>
			<error>
				<message>Entry Overprint in OPIVersion20Dict has type %1 instead of type Boolean</message>
				<arguments>
					<argument>OverprintType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Size" testNumber="8"/>
			<description>Entry Size in OPIVersion20Dict shall have type Array</description>
			<test>containsSize == false || SizeHasTypeArray == true</test>
			<error>
				<message>Entry Size in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>SizeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Size" testNumber="11"/>
			<description>Entry Size in OPIVersion20Dict is required, when fn:IsPresent(CropRect)</description>
			<test>containsSize == true || (containsCropRect != true)</test>
			<error>
				<message>Entry Size in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Size-Array" testNumber="9"/>
			<description>Entry Size with type Array in OPIVersion20Dict shall satisfy special case: fn:Eval((Size::@0 &gt; 0) &amp;&amp; (Size::@1 &gt; 0))</description>
			<test>SizeHasTypeArray != true || ((Size0HasTypeNumber == false || (Size0NumberValue &gt; 0)) &amp;&amp; (Size1HasTypeNumber == false || (Size1NumberValue &gt; 0)))</test>
			<error>
				<message>Entry Size with type Array in OPIVersion20Dict does not satisfy special case: fn:Eval((Size::@0 &gt; 0) &amp;&amp; (Size::@1 &gt; 0))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Tags" testNumber="8"/>
			<description>Entry Tags in OPIVersion20Dict shall have type Array</description>
			<test>containsTags == false || TagsHasTypeArray == true</test>
			<error>
				<message>Entry Tags in OPIVersion20Dict has type %1 instead of type Array</message>
				<arguments>
					<argument>TagsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Type" testNumber="8"/>
			<description>Entry Type in OPIVersion20Dict shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in OPIVersion20Dict has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in OPIVersion20Dict shall have value OPI</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OPI"</test>
			<error>
				<message>Entry Type with type Name in OPIVersion20Dict has incorrect value %1 instead of OPI</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Version" testNumber="8"/>
			<description>Entry Version in OPIVersion20Dict shall have type Number</description>
			<test>containsVersion == false || VersionHasTypeNumber == true</test>
			<error>
				<message>Entry Version in OPIVersion20Dict has type %1 instead of type Number</message>
				<arguments>
					<argument>VersionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Version" testNumber="7"/>
			<description>Entry Version in OPIVersion20Dict is required</description>
			<test>containsVersion == true</test>
			<error>
				<message>Entry Version in OPIVersion20Dict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOPIVersion20Dict">
			<id specification="PDF_1_4" clause="OPIVersion20Dict-Version-Number" testNumber="6"/>
			<description>Entry Version with type Number in OPIVersion20Dict shall have value 2.0</description>
			<test>VersionHasTypeNumber != true || VersionNumberValue == 2.0</test>
			<error>
				<message>Entry Version with type Number in OPIVersion20Dict has incorrect value %1 instead of 2.0</message>
				<arguments>
					<argument>VersionNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference" testNumber="1"/>
			<description>ObjectReference shall not contain entries except Obj, Pg, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Obj' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ObjectReference contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Obj' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj-Stream" testNumber="17"/>
			<description>Entry Obj with type Stream in ObjectReference shall be one of objects XObjectFormType1, XObjectImage</description>
			<test>ObjHasTypeStream != true || Obj_size == 1</test>
			<error>
				<message>Entry Obj with type Stream in ObjectReference is not one of objects XObjectFormType1, XObjectImage</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj" testNumber="8"/>
			<description>Entry Obj in ObjectReference shall have one of types: Array, Dictionary, Stream</description>
			<test>containsObj == false || ObjHasTypeArray == true || ObjHasTypeDictionary == true || ObjHasTypeStream == true</test>
			<error>
				<message>Entry Obj in ObjectReference has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>ObjType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj" testNumber="7"/>
			<description>Entry Obj in ObjectReference is required</description>
			<test>containsObj == true</test>
			<error>
				<message>Entry Obj in ObjectReference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj-Array" testNumber="10"/>
			<description>Entry Obj with type Array in ObjectReference shall be indirect</description>
			<test>ObjHasTypeArray != true || isObjIndirect == true</test>
			<error>
				<message>Entry Obj with type Array in ObjectReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj-Dictionary" testNumber="10"/>
			<description>Entry Obj with type Dictionary in ObjectReference shall be indirect</description>
			<test>ObjHasTypeDictionary != true || isObjIndirect == true</test>
			<error>
				<message>Entry Obj with type Dictionary in ObjectReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Obj-Stream" testNumber="10"/>
			<description>Entry Obj with type Stream in ObjectReference shall be indirect</description>
			<test>ObjHasTypeStream != true || isObjIndirect == true</test>
			<error>
				<message>Entry Obj with type Stream in ObjectReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Pg" testNumber="8"/>
			<description>Entry Pg in ObjectReference shall have type Dictionary</description>
			<test>containsPg == false || PgHasTypeDictionary == true</test>
			<error>
				<message>Entry Pg in ObjectReference has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PgType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Pg-Dictionary" testNumber="10"/>
			<description>Entry Pg with type Dictionary in ObjectReference shall be indirect</description>
			<test>PgHasTypeDictionary != true || isPgIndirect == true</test>
			<error>
				<message>Entry Pg with type Dictionary in ObjectReference is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Type" testNumber="8"/>
			<description>Entry Type in ObjectReference shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ObjectReference has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Type" testNumber="7"/>
			<description>Entry Type in ObjectReference is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in ObjectReference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AObjectReference">
			<id specification="PDF_1_4" clause="ObjectReference-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ObjectReference shall have value OBJR</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OBJR"</test>
			<error>
				<message>Entry Type with type Name in ObjectReference has incorrect value %1 instead of OBJR</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline" testNumber="1"/>
			<description>Outline shall not contain entries except Count, First, Last, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Outline contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'First' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Count" testNumber="8"/>
			<description>Entry Count in Outline shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in Outline has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in Outline shall satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Count with type Integer in Outline does not satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-First" testNumber="8"/>
			<description>Entry First in Outline shall have type Dictionary</description>
			<test>containsFirst == false || FirstHasTypeDictionary == true</test>
			<error>
				<message>Entry First in Outline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FirstType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-First-Dictionary" testNumber="10"/>
			<description>Entry First with type Dictionary in Outline shall be indirect</description>
			<test>FirstHasTypeDictionary != true || isFirstIndirect == true</test>
			<error>
				<message>Entry First with type Dictionary in Outline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Last" testNumber="8"/>
			<description>Entry Last in Outline shall have type Dictionary</description>
			<test>containsLast == false || LastHasTypeDictionary == true</test>
			<error>
				<message>Entry Last in Outline has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>LastType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Last-Dictionary" testNumber="10"/>
			<description>Entry Last with type Dictionary in Outline shall be indirect</description>
			<test>LastHasTypeDictionary != true || isLastIndirect == true</test>
			<error>
				<message>Entry Last with type Dictionary in Outline is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Type" testNumber="8"/>
			<description>Entry Type in Outline shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Outline has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutline">
			<id specification="PDF_1_4" clause="Outline-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Outline shall have value Outlines</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Outlines"</test>
			<error>
				<message>Entry Type with type Name in Outline has incorrect value %1 instead of Outlines</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem" testNumber="1"/>
			<description>OutlineItem shall not contain entries except A, C, Count, Dest, F, First, Last, Next, Parent, Prev, SE, Title</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'F' &amp;&amp; elem != 'First' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'SE' &amp;&amp; elem != 'Title' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OutlineItem contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'C' &amp;&amp; elem != 'Count' &amp;&amp; elem != 'Dest' &amp;&amp; elem != 'F' &amp;&amp; elem != 'First' &amp;&amp; elem != 'Last' &amp;&amp; elem != 'Next' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Prev' &amp;&amp; elem != 'SE' &amp;&amp; elem != 'Title' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-A-Dictionary" testNumber="17"/>
			<description>Entry A with type Dictionary in OutlineItem shall be one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</description>
			<test>AHasTypeDictionary != true || A_size == 1</test>
			<error>
				<message>Entry A with type Dictionary in OutlineItem is not one of objects ActionGoTo, ActionGoToR, ActionLaunch, ActionThread, ActionURI, ActionSound, ActionMovie, ActionHide, ActionNamed, ActionSubmitForm, ActionResetForm, ActionImportData, ActionECMAScript</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-A" testNumber="8"/>
			<description>Entry A in OutlineItem shall have type Dictionary</description>
			<test>containsA == false || AHasTypeDictionary == true</test>
			<error>
				<message>Entry A in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-A-Dictionary" testNumber="9"/>
			<description>Entry A with type Dictionary in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(Dest))</description>
			<test>AHasTypeDictionary != true || (containsDest != true)</test>
			<error>
				<message>Entry A with type Dictionary in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(Dest))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-C" testNumber="8"/>
			<description>Entry C in OutlineItem shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in OutlineItem has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Count" testNumber="8"/>
			<description>Entry Count in OutlineItem shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in OutlineItem has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Dest-Array" testNumber="17"/>
			<description>Entry Dest with type Array in OutlineItem shall be one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</description>
			<test>DestHasTypeArray != true || Dest_size == 1</test>
			<error>
				<message>Entry Dest with type Array in OutlineItem is not one of objects DestXYZArray, Dest0Array, Dest1Array, Dest4Array</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Dest" testNumber="8"/>
			<description>Entry Dest in OutlineItem shall have one of types: Array, Name, StringByte</description>
			<test>containsDest == false || DestHasTypeArray == true || DestHasTypeName == true || DestHasTypeStringByte == true</test>
			<error>
				<message>Entry Dest in OutlineItem has type %1 instead of one of types: Array, Name, StringByte</message>
				<arguments>
					<argument>DestType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Dest-Array" testNumber="9"/>
			<description>Entry Dest with type Array in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeArray != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type Array in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Dest-Name" testNumber="9"/>
			<description>Entry Dest with type Name in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeName != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type Name in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Dest-StringByte" testNumber="9"/>
			<description>Entry Dest with type StringByte in OutlineItem shall satisfy special case: fn:Not(fn:IsPresent(A))</description>
			<test>DestHasTypeStringByte != true || (containsA != true)</test>
			<error>
				<message>Entry Dest with type StringByte in OutlineItem does not satisfy special case: fn:Not(fn:IsPresent(A))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-F" testNumber="8"/>
			<description>Entry F in OutlineItem shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in OutlineItem has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in OutlineItem shall satisfy special case: fn:Eval(fn:BitsClear(3, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 2 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in OutlineItem does not satisfy special case: fn:Eval(fn:BitsClear(3, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-First" testNumber="8"/>
			<description>Entry First in OutlineItem shall have type Dictionary</description>
			<test>containsFirst == false || FirstHasTypeDictionary == true</test>
			<error>
				<message>Entry First in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FirstType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-First-Dictionary" testNumber="10"/>
			<description>Entry First with type Dictionary in OutlineItem shall be indirect</description>
			<test>FirstHasTypeDictionary != true || isFirstIndirect == true</test>
			<error>
				<message>Entry First with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Last" testNumber="8"/>
			<description>Entry Last in OutlineItem shall have type Dictionary</description>
			<test>containsLast == false || LastHasTypeDictionary == true</test>
			<error>
				<message>Entry Last in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>LastType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Last-Dictionary" testNumber="10"/>
			<description>Entry Last with type Dictionary in OutlineItem shall be indirect</description>
			<test>LastHasTypeDictionary != true || isLastIndirect == true</test>
			<error>
				<message>Entry Last with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Next" testNumber="8"/>
			<description>Entry Next in OutlineItem shall have type Dictionary</description>
			<test>containsNext == false || NextHasTypeDictionary == true</test>
			<error>
				<message>Entry Next in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>NextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Next-Dictionary" testNumber="10"/>
			<description>Entry Next with type Dictionary in OutlineItem shall be indirect</description>
			<test>NextHasTypeDictionary != true || isNextIndirect == true</test>
			<error>
				<message>Entry Next with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in OutlineItem shall be one of objects OutlineItem, Outline</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in OutlineItem is not one of objects OutlineItem, Outline</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Parent" testNumber="8"/>
			<description>Entry Parent in OutlineItem shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Parent" testNumber="7"/>
			<description>Entry Parent in OutlineItem is required</description>
			<test>containsParent == true</test>
			<error>
				<message>Entry Parent in OutlineItem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in OutlineItem shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Prev" testNumber="8"/>
			<description>Entry Prev in OutlineItem shall have type Dictionary</description>
			<test>containsPrev == false || PrevHasTypeDictionary == true</test>
			<error>
				<message>Entry Prev in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PrevType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Prev-Dictionary" testNumber="10"/>
			<description>Entry Prev with type Dictionary in OutlineItem shall be indirect</description>
			<test>PrevHasTypeDictionary != true || isPrevIndirect == true</test>
			<error>
				<message>Entry Prev with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-SE" testNumber="8"/>
			<description>Entry SE in OutlineItem shall have type Dictionary</description>
			<test>containsSE == false || SEHasTypeDictionary == true</test>
			<error>
				<message>Entry SE in OutlineItem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>SEType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-SE-Dictionary" testNumber="10"/>
			<description>Entry SE with type Dictionary in OutlineItem shall be indirect</description>
			<test>SEHasTypeDictionary != true || isSEIndirect == true</test>
			<error>
				<message>Entry SE with type Dictionary in OutlineItem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Title" testNumber="8"/>
			<description>Entry Title in OutlineItem shall have type StringText</description>
			<test>containsTitle == false || TitleHasTypeStringText == true</test>
			<error>
				<message>Entry Title in OutlineItem has type %1 instead of type StringText</message>
				<arguments>
					<argument>TitleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutlineItem">
			<id specification="PDF_1_4" clause="OutlineItem-Title" testNumber="7"/>
			<description>Entry Title in OutlineItem is required</description>
			<test>containsTitle == true</test>
			<error>
				<message>Entry Title in OutlineItem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents" testNumber="1"/>
			<description>OutputIntents shall not contain entries except DestOutputProfile, Info, OutputCondition, OutputConditionIdentifier, RegistryName, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DestOutputProfile' &amp;&amp; elem != 'DestOutputProfileRef' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'MixingHints' &amp;&amp; elem != 'OutputCondition' &amp;&amp; elem != 'OutputConditionIdentifier' &amp;&amp; elem != 'RegistryName' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SpectralData' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>OutputIntents contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DestOutputProfile' &amp;&amp; elem != 'DestOutputProfileRef' &amp;&amp; elem != 'Info' &amp;&amp; elem != 'MixingHints' &amp;&amp; elem != 'OutputCondition' &amp;&amp; elem != 'OutputConditionIdentifier' &amp;&amp; elem != 'RegistryName' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SpectralData' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents" testNumber="22"/>
			<description>OutputIntents shall not contain entries DestOutputProfileRef, MixingHints, SpectralData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'DestOutputProfileRef' || elem == 'MixingHints' || elem == 'SpectralData').length == 0</test>
			<error>
				<message>OutputIntents contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'DestOutputProfileRef' || elem == 'MixingHints' || elem == 'SpectralData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-DestOutputProfile" testNumber="8"/>
			<description>Entry DestOutputProfile in OutputIntents shall have type Stream</description>
			<test>containsDestOutputProfile == false || DestOutputProfileHasTypeStream == true</test>
			<error>
				<message>Entry DestOutputProfile in OutputIntents has type %1 instead of type Stream</message>
				<arguments>
					<argument>DestOutputProfileType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-DestOutputProfile-Stream" testNumber="10"/>
			<description>Entry DestOutputProfile with type Stream in OutputIntents shall be indirect</description>
			<test>DestOutputProfileHasTypeStream != true || isDestOutputProfileIndirect == true</test>
			<error>
				<message>Entry DestOutputProfile with type Stream in OutputIntents is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-Info" testNumber="8"/>
			<description>Entry Info in OutputIntents shall have type StringText</description>
			<test>containsInfo == false || InfoHasTypeStringText == true</test>
			<error>
				<message>Entry Info in OutputIntents has type %1 instead of type StringText</message>
				<arguments>
					<argument>InfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-OutputCondition" testNumber="8"/>
			<description>Entry OutputCondition in OutputIntents shall have type StringText</description>
			<test>containsOutputCondition == false || OutputConditionHasTypeStringText == true</test>
			<error>
				<message>Entry OutputCondition in OutputIntents has type %1 instead of type StringText</message>
				<arguments>
					<argument>OutputConditionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-OutputConditionIdentifier" testNumber="8"/>
			<description>Entry OutputConditionIdentifier in OutputIntents shall have type StringText</description>
			<test>containsOutputConditionIdentifier == false || OutputConditionIdentifierHasTypeStringText == true</test>
			<error>
				<message>Entry OutputConditionIdentifier in OutputIntents has type %1 instead of type StringText</message>
				<arguments>
					<argument>OutputConditionIdentifierType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-OutputConditionIdentifier" testNumber="7"/>
			<description>Entry OutputConditionIdentifier in OutputIntents is required</description>
			<test>containsOutputConditionIdentifier == true</test>
			<error>
				<message>Entry OutputConditionIdentifier in OutputIntents is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-RegistryName" testNumber="8"/>
			<description>Entry RegistryName in OutputIntents shall have type StringText</description>
			<test>containsRegistryName == false || RegistryNameHasTypeStringText == true</test>
			<error>
				<message>Entry RegistryName in OutputIntents has type %1 instead of type StringText</message>
				<arguments>
					<argument>RegistryNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-S" testNumber="8"/>
			<description>Entry S in OutputIntents shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in OutputIntents has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-S" testNumber="7"/>
			<description>Entry S in OutputIntents is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in OutputIntents is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-S-Name" testNumber="6"/>
			<description>Entry S with type Name in OutputIntents shall have one of values: ISO_PDFE1, GTS_PDFX, GTS_PDFA1</description>
			<test>SHasTypeName != true || SNameValue == "GTS_PDFX" || SNameValue == "GTS_PDFA1" || SNameValue == "ISO_PDFE1"</test>
			<error>
				<message>Entry S with type Name in OutputIntents has incorrect value %1 instead of ISO_PDFE1, GTS_PDFX, GTS_PDFA1</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-Type" testNumber="8"/>
			<description>Entry Type in OutputIntents shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in OutputIntents has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AOutputIntents">
			<id specification="PDF_1_4" clause="OutputIntents-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in OutputIntents shall have value OutputIntent</description>
			<test>TypeHasTypeName != true || TypeNameValue == "OutputIntent"</test>
			<error>
				<message>Entry Type with type Name in OutputIntents has incorrect value %1 instead of OutputIntent</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel" testNumber="1"/>
			<description>PageLabel shall not contain entries except P, S, St, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'S' &amp;&amp; elem != 'St' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageLabel contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'P' &amp;&amp; elem != 'S' &amp;&amp; elem != 'St' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-P" testNumber="8"/>
			<description>Entry P in PageLabel shall have type StringText</description>
			<test>containsP == false || PHasTypeStringText == true</test>
			<error>
				<message>Entry P in PageLabel has type %1 instead of type StringText</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-S" testNumber="8"/>
			<description>Entry S in PageLabel shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in PageLabel has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-S-Name" testNumber="6"/>
			<description>Entry S with type Name in PageLabel shall have one of values: A, a, R, r, D</description>
			<test>SHasTypeName != true || SNameValue == "D" || SNameValue == "R" || SNameValue == "r" || SNameValue == "A" || SNameValue == "a"</test>
			<error>
				<message>Entry S with type Name in PageLabel has incorrect value %1 instead of A, a, R, r, D</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-St" testNumber="8"/>
			<description>Entry St in PageLabel shall have type Integer</description>
			<test>containsSt == false || StHasTypeInteger == true</test>
			<error>
				<message>Entry St in PageLabel has type %1 instead of type Integer</message>
				<arguments>
					<argument>StType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-St-Integer" testNumber="14"/>
			<description>Entry St with type Integer in PageLabel shall satisfy possible value predicate: fn:Eval(@St &gt;= 1)</description>
			<test>StHasTypeInteger != true || StIntegerValue &gt;= 1</test>
			<error>
				<message>Entry St with type Integer in PageLabel does not satisfy possible value predicate: fn:Eval(@St &gt;= 1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-Type" testNumber="8"/>
			<description>Entry Type in PageLabel shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageLabel has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageLabel">
			<id specification="PDF_1_4" clause="PageLabel-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageLabel shall have value PageLabel</description>
			<test>TypeHasTypeName != true || TypeNameValue == "PageLabel"</test>
			<error>
				<message>Entry Type with type Name in PageLabel has incorrect value %1 instead of PageLabel</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject" testNumber="1"/>
			<description>PageObject shall not contain entries except AA, Annots, ArtBox, B, BleedBox, BoxColorInfo, Contents, CropBox, Dur, Group, Hid, ID, LastModified, MediaBox, Metadata, PZ, Parent, PieceInfo, Resources, Rotate, SeparationInfo, StructParents, Thumb, Trans, TrimBox, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Annots' &amp;&amp; elem != 'ArtBox' &amp;&amp; elem != 'B' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'BoxColorInfo' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'DPart' &amp;&amp; elem != 'Dur' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'Hid' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PZ' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PresSteps' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'SeparationInfo' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Tabs' &amp;&amp; elem != 'TemplateInstantiated' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'Trans' &amp;&amp; elem != 'TrimBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UserUnit' &amp;&amp; elem != 'VP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AA' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'Annots' &amp;&amp; elem != 'ArtBox' &amp;&amp; elem != 'B' &amp;&amp; elem != 'BleedBox' &amp;&amp; elem != 'BoxColorInfo' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'DPart' &amp;&amp; elem != 'Dur' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'Hid' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'OutputIntents' &amp;&amp; elem != 'PZ' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PresSteps' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'SeparationInfo' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Tabs' &amp;&amp; elem != 'TemplateInstantiated' &amp;&amp; elem != 'Thumb' &amp;&amp; elem != 'Trans' &amp;&amp; elem != 'TrimBox' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UserUnit' &amp;&amp; elem != 'VP' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject" testNumber="22"/>
			<description>PageObject shall not contain entries AF, DPart, OutputIntents, PresSteps, Tabs, TemplateInstantiated, UserUnit, VP in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DPart' || elem == 'OutputIntents' || elem == 'PresSteps' || elem == 'Tabs' || elem == 'TemplateInstantiated' || elem == 'UserUnit' || elem == 'VP').length == 0</test>
			<error>
				<message>PageObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DPart' || elem == 'OutputIntents' || elem == 'PresSteps' || elem == 'Tabs' || elem == 'TemplateInstantiated' || elem == 'UserUnit' || elem == 'VP').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-AA" testNumber="8"/>
			<description>Entry AA in PageObject shall have type Dictionary</description>
			<test>containsAA == false || AAHasTypeDictionary == true</test>
			<error>
				<message>Entry AA in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>AAType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Annots" testNumber="8"/>
			<description>Entry Annots in PageObject shall have type Array</description>
			<test>containsAnnots == false || AnnotsHasTypeArray == true</test>
			<error>
				<message>Entry Annots in PageObject has type %1 instead of type Array</message>
				<arguments>
					<argument>AnnotsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-ArtBox" testNumber="8"/>
			<description>Entry ArtBox in PageObject shall have type Rectangle</description>
			<test>containsArtBox == false || ArtBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry ArtBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>ArtBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-B" testNumber="8"/>
			<description>Entry B in PageObject shall have type Array</description>
			<test>containsB == false || BHasTypeArray == true</test>
			<error>
				<message>Entry B in PageObject has type %1 instead of type Array</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-B-Array" testNumber="9"/>
			<description>Entry B with type Array in PageObject shall satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</description>
			<test>BHasTypeArray != true || ((TypeNameValue != "Template") || containsB != true)</test>
			<error>
				<message>Entry B with type Array in PageObject does not satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-BleedBox" testNumber="8"/>
			<description>Entry BleedBox in PageObject shall have type Rectangle</description>
			<test>containsBleedBox == false || BleedBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BleedBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BleedBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-BoxColorInfo" testNumber="8"/>
			<description>Entry BoxColorInfo in PageObject shall have type Dictionary</description>
			<test>containsBoxColorInfo == false || BoxColorInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry BoxColorInfo in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>BoxColorInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Contents" testNumber="8"/>
			<description>Entry Contents in PageObject shall have one of types: Array, Stream</description>
			<test>containsContents == false || ContentsHasTypeArray == true || ContentsHasTypeStream == true</test>
			<error>
				<message>Entry Contents in PageObject has type %1 instead of one of types: Array, Stream</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Contents-Stream" testNumber="10"/>
			<description>Entry Contents with type Stream in PageObject shall be indirect</description>
			<test>ContentsHasTypeStream != true || isContentsIndirect == true</test>
			<error>
				<message>Entry Contents with type Stream in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageObject shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Dur" testNumber="8"/>
			<description>Entry Dur in PageObject shall have type Number</description>
			<test>containsDur == false || DurHasTypeNumber == true</test>
			<error>
				<message>Entry Dur in PageObject has type %1 instead of type Number</message>
				<arguments>
					<argument>DurType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Group" testNumber="8"/>
			<description>Entry Group in PageObject shall have type Dictionary</description>
			<test>containsGroup == false || GroupHasTypeDictionary == true</test>
			<error>
				<message>Entry Group in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>GroupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Hid" testNumber="8"/>
			<description>Entry Hid in PageObject shall have type Boolean</description>
			<test>containsHid == false || HidHasTypeBoolean == true</test>
			<error>
				<message>Entry Hid in PageObject has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HidType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Hid" testNumber="5"/>
			<description>Entry Hid in PageObject is deprecated since PDF 1.3</description>
			<test>containsHid == false</test>
			<error>
				<message>Entry Hid in PageObject is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-ID" testNumber="8"/>
			<description>Entry ID in PageObject shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in PageObject has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-LastModified" testNumber="8"/>
			<description>Entry LastModified in PageObject shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in PageObject has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-LastModified" testNumber="11"/>
			<description>Entry LastModified in PageObject is required, when fn:IsPresent(PieceInfo)</description>
			<test>containsLastModified == true || (containsPieceInfo != true)</test>
			<error>
				<message>Entry LastModified in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageObject shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-MediaBox" testNumber="7"/>
			<description>Entry MediaBox in PageObject is required</description>
			<test>containsMediaBox == true</test>
			<error>
				<message>Entry MediaBox in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Metadata" testNumber="8"/>
			<description>Entry Metadata in PageObject shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in PageObject has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in PageObject shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-PZ" testNumber="8"/>
			<description>Entry PZ in PageObject shall have type Number</description>
			<test>containsPZ == false || PZHasTypeNumber == true</test>
			<error>
				<message>Entry PZ in PageObject has type %1 instead of type Number</message>
				<arguments>
					<argument>PZType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in PageObject shall be one of objects PageTreeNode, PageTreeNodeRoot</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject is not one of objects PageTreeNode, PageTreeNodeRoot</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Parent" testNumber="8"/>
			<description>Entry Parent in PageObject shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Parent" testNumber="11"/>
			<description>Entry Parent in PageObject is required, when @Type != Template</description>
			<test>containsParent == true || (TypeNameValue == "Template")</test>
			<error>
				<message>Entry Parent in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in PageObject shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Parent-Dictionary" testNumber="9"/>
			<description>Entry Parent with type Dictionary in PageObject shall satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</description>
			<test>ParentHasTypeDictionary != true || ((TypeNameValue != "Template") || containsParent != true)</test>
			<error>
				<message>Entry Parent with type Dictionary in PageObject does not satisfy special case: fn:Not(fn:IsPresent(@Type == Template))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-PieceInfo" testNumber="8"/>
			<description>Entry PieceInfo in PageObject shall have type Dictionary</description>
			<test>containsPieceInfo == false || PieceInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry PieceInfo in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PieceInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-PieceInfo-Dictionary" testNumber="9"/>
			<description>Entry PieceInfo with type Dictionary in PageObject shall satisfy special case: fn:Eval(fn:IsPresent(LastModified))</description>
			<test>PieceInfoHasTypeDictionary != true || (containsLastModified == true)</test>
			<error>
				<message>Entry PieceInfo with type Dictionary in PageObject does not satisfy special case: fn:Eval(fn:IsPresent(LastModified))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Resources" testNumber="8"/>
			<description>Entry Resources in PageObject shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Resources" testNumber="7"/>
			<description>Entry Resources in PageObject is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageObject shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageObject shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageObject does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-SeparationInfo" testNumber="8"/>
			<description>Entry SeparationInfo in PageObject shall have type Dictionary</description>
			<test>containsSeparationInfo == false || SeparationInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry SeparationInfo in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>SeparationInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-StructParents" testNumber="8"/>
			<description>Entry StructParents in PageObject shall have type Integer</description>
			<test>containsStructParents == false || StructParentsHasTypeInteger == true</test>
			<error>
				<message>Entry StructParents in PageObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-StructParents" testNumber="11"/>
			<description>Entry StructParents in PageObject is required, when fn:PageContainsStructContentItems()</description>
			<test>containsStructParents == true || (pageContainsStructContentItems != true)</test>
			<error>
				<message>Entry StructParents in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Thumb" testNumber="8"/>
			<description>Entry Thumb in PageObject shall have type Stream</description>
			<test>containsThumb == false || ThumbHasTypeStream == true</test>
			<error>
				<message>Entry Thumb in PageObject has type %1 instead of type Stream</message>
				<arguments>
					<argument>ThumbType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Thumb-Stream" testNumber="10"/>
			<description>Entry Thumb with type Stream in PageObject shall be indirect</description>
			<test>ThumbHasTypeStream != true || isThumbIndirect == true</test>
			<error>
				<message>Entry Thumb with type Stream in PageObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Trans" testNumber="8"/>
			<description>Entry Trans in PageObject shall have type Dictionary</description>
			<test>containsTrans == false || TransHasTypeDictionary == true</test>
			<error>
				<message>Entry Trans in PageObject has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>TransType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-TrimBox" testNumber="8"/>
			<description>Entry TrimBox in PageObject shall have type Rectangle</description>
			<test>containsTrimBox == false || TrimBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry TrimBox in PageObject has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>TrimBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Type" testNumber="8"/>
			<description>Entry Type in PageObject shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageObject has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Type" testNumber="7"/>
			<description>Entry Type in PageObject is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageObject">
			<id specification="PDF_1_4" clause="PageObject-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageObject shall have one of values: Page, Template</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Page" || TypeNameValue == "Template"</test>
			<error>
				<message>Entry Type with type Name in PageObject has incorrect value %1 instead of Page, Template</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APagePieceEntry">
			<id specification="PDF_1_4" clause="PagePieceEntry" testNumber="8"/>
			<description>Entry in PagePiece shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in PagePiece has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode" testNumber="1"/>
			<description>PageTreeNode shall not contain entries except Count, CropBox, Kids, MediaBox, Parent, Resources, Rotate, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageTreeNode contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Parent' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Count" testNumber="8"/>
			<description>Entry Count in PageTreeNode shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in PageTreeNode has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Count" testNumber="7"/>
			<description>Entry Count in PageTreeNode is required</description>
			<test>containsCount == true</test>
			<error>
				<message>Entry Count in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in PageTreeNode shall satisfy possible value predicate: fn:Eval(@Count &gt; 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt; 0</test>
			<error>
				<message>Entry Count with type Integer in PageTreeNode does not satisfy possible value predicate: fn:Eval(@Count &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageTreeNode shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageTreeNode has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Kids" testNumber="8"/>
			<description>Entry Kids in PageTreeNode shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in PageTreeNode has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Kids" testNumber="7"/>
			<description>Entry Kids in PageTreeNode is required</description>
			<test>containsKids == true</test>
			<error>
				<message>Entry Kids in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Kids-Array" testNumber="9"/>
			<description>Entry Kids with type Array in PageTreeNode shall satisfy special case: fn:Eval(fn:ArrayLength(Kids) &gt; 0)</description>
			<test>KidsHasTypeArray != true || (KidsArraySize &gt; 0)</test>
			<error>
				<message>Entry Kids with type Array in PageTreeNode does not satisfy special case: fn:Eval(fn:ArrayLength(Kids) &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageTreeNode shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageTreeNode has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Parent-Dictionary" testNumber="17"/>
			<description>Entry Parent with type Dictionary in PageTreeNode shall be one of objects PageTreeNode, PageTreeNodeRoot</description>
			<test>ParentHasTypeDictionary != true || Parent_size == 1</test>
			<error>
				<message>Entry Parent with type Dictionary in PageTreeNode is not one of objects PageTreeNode, PageTreeNodeRoot</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Parent" testNumber="8"/>
			<description>Entry Parent in PageTreeNode shall have type Dictionary</description>
			<test>containsParent == false || ParentHasTypeDictionary == true</test>
			<error>
				<message>Entry Parent in PageTreeNode has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Parent" testNumber="7"/>
			<description>Entry Parent in PageTreeNode is required</description>
			<test>containsParent == true</test>
			<error>
				<message>Entry Parent in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Parent-Dictionary" testNumber="10"/>
			<description>Entry Parent with type Dictionary in PageTreeNode shall be indirect</description>
			<test>ParentHasTypeDictionary != true || isParentIndirect == true</test>
			<error>
				<message>Entry Parent with type Dictionary in PageTreeNode is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Resources" testNumber="8"/>
			<description>Entry Resources in PageTreeNode shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageTreeNode has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageTreeNode shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageTreeNode has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageTreeNode shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageTreeNode does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Type" testNumber="8"/>
			<description>Entry Type in PageTreeNode shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageTreeNode has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Type" testNumber="7"/>
			<description>Entry Type in PageTreeNode is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageTreeNode is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNode">
			<id specification="PDF_1_4" clause="PageTreeNode-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageTreeNode shall have value Pages</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pages"</test>
			<error>
				<message>Entry Type with type Name in PageTreeNode has incorrect value %1 instead of Pages</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot" testNumber="1"/>
			<description>PageTreeNodeRoot shall not contain entries except Count, CropBox, Kids, MediaBox, Resources, Rotate, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PageTreeNodeRoot contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Count' &amp;&amp; elem != 'CropBox' &amp;&amp; elem != 'Kids' &amp;&amp; elem != 'MediaBox' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'Rotate' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Count" testNumber="8"/>
			<description>Entry Count in PageTreeNodeRoot shall have type Integer</description>
			<test>containsCount == false || CountHasTypeInteger == true</test>
			<error>
				<message>Entry Count in PageTreeNodeRoot has type %1 instead of type Integer</message>
				<arguments>
					<argument>CountType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Count" testNumber="7"/>
			<description>Entry Count in PageTreeNodeRoot is required</description>
			<test>containsCount == true</test>
			<error>
				<message>Entry Count in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Count-Integer" testNumber="14"/>
			<description>Entry Count with type Integer in PageTreeNodeRoot shall satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</description>
			<test>CountHasTypeInteger != true || CountIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Count with type Integer in PageTreeNodeRoot does not satisfy possible value predicate: fn:Eval(@Count &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-CropBox" testNumber="8"/>
			<description>Entry CropBox in PageTreeNodeRoot shall have type Rectangle</description>
			<test>containsCropBox == false || CropBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry CropBox in PageTreeNodeRoot has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>CropBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Kids" testNumber="8"/>
			<description>Entry Kids in PageTreeNodeRoot shall have type Array</description>
			<test>containsKids == false || KidsHasTypeArray == true</test>
			<error>
				<message>Entry Kids in PageTreeNodeRoot has type %1 instead of type Array</message>
				<arguments>
					<argument>KidsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Kids" testNumber="7"/>
			<description>Entry Kids in PageTreeNodeRoot is required</description>
			<test>containsKids == true</test>
			<error>
				<message>Entry Kids in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-MediaBox" testNumber="8"/>
			<description>Entry MediaBox in PageTreeNodeRoot shall have type Rectangle</description>
			<test>containsMediaBox == false || MediaBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry MediaBox in PageTreeNodeRoot has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>MediaBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Resources" testNumber="8"/>
			<description>Entry Resources in PageTreeNodeRoot shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PageTreeNodeRoot has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Rotate" testNumber="8"/>
			<description>Entry Rotate in PageTreeNodeRoot shall have type Integer</description>
			<test>containsRotate == false || RotateHasTypeInteger == true</test>
			<error>
				<message>Entry Rotate in PageTreeNodeRoot has type %1 instead of type Integer</message>
				<arguments>
					<argument>RotateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Rotate-Integer" testNumber="14"/>
			<description>Entry Rotate with type Integer in PageTreeNodeRoot shall satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</description>
			<test>RotateHasTypeInteger != true || (RotateIntegerValue % 90) == 0</test>
			<error>
				<message>Entry Rotate with type Integer in PageTreeNodeRoot does not satisfy possible value predicate: fn:Eval((@Rotate mod 90) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Type" testNumber="8"/>
			<description>Entry Type in PageTreeNodeRoot shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PageTreeNodeRoot has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Type" testNumber="7"/>
			<description>Entry Type in PageTreeNodeRoot is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in PageTreeNodeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APageTreeNodeRoot">
			<id specification="PDF_1_4" clause="PageTreeNodeRoot-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PageTreeNodeRoot shall have value Pages</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pages"</test>
			<error>
				<message>Entry Type with type Name in PageTreeNodeRoot has incorrect value %1 instead of Pages</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace" testNumber="2"/>
			<description>PatternColorSpace shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>PatternColorSpace contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace-0" testNumber="8"/>
			<description>Entry 0 in PatternColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in PatternColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in PatternColorSpace shall have value Pattern</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Pattern"</test>
			<error>
				<message>Entry 0 with type Name in PatternColorSpace has incorrect value %1 instead of Pattern</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace-1-Array" testNumber="17"/>
			<description>Entry 1 with type Array in PatternColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>entry1HasTypeArray != true || entry1_size == 1</test>
			<error>
				<message>Entry 1 with type Array in PatternColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace-1" testNumber="8"/>
			<description>Entry 1 in PatternColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 1 || entry1HasTypeArray == true || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in PatternColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternColorSpace">
			<id specification="PDF_1_4" clause="PatternColorSpace-1-Name" testNumber="6"/>
			<description>Entry 1 with type Name in PatternColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry1HasTypeName != true || entry1NameValue == "DeviceCMYK" || entry1NameValue == "DeviceRGB" || entry1NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 1 with type Name in PatternColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry1NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternMapEntry">
			<id specification="PDF_1_4" clause="PatternMapEntry" testNumber="8"/>
			<description>Entry in PatternMap shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in PatternMap has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternMapEntry">
			<id specification="PDF_1_4" clause="PatternMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in PatternMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in PatternMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1" testNumber="1"/>
			<description>PatternType1 shall not contain entries except BBox, DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Matrix, PaintType, PatternType, Resources, TilingType, Type, XStep, XUID, YStep</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PaintType' &amp;&amp; elem != 'PatternType' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'TilingType' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XStep' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'YStep' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PatternType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PaintType' &amp;&amp; elem != 'PatternType' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'TilingType' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XStep' &amp;&amp; elem != 'XUID' &amp;&amp; elem != 'YStep' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1" testNumber="22"/>
			<description>PatternType1 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>PatternType1 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-BBox" testNumber="8"/>
			<description>Entry BBox in PatternType1 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in PatternType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-BBox" testNumber="7"/>
			<description>Entry BBox in PatternType1 is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in PatternType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in PatternType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in PatternType1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in PatternType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-F" testNumber="8"/>
			<description>Entry F in PatternType1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in PatternType1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in PatternType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in PatternType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in PatternType1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in PatternType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FFilter" testNumber="8"/>
			<description>Entry FFilter in PatternType1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in PatternType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in PatternType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in PatternType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Filter" testNumber="8"/>
			<description>Entry Filter in PatternType1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in PatternType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in PatternType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in PatternType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in PatternType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in PatternType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Length" testNumber="8"/>
			<description>Entry Length in PatternType1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Length" testNumber="7"/>
			<description>Entry Length in PatternType1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Matrix" testNumber="8"/>
			<description>Entry Matrix in PatternType1 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in PatternType1 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PaintType" testNumber="8"/>
			<description>Entry PaintType in PatternType1 shall have type Integer</description>
			<test>containsPaintType == false || PaintTypeHasTypeInteger == true</test>
			<error>
				<message>Entry PaintType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>PaintTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PaintType" testNumber="7"/>
			<description>Entry PaintType in PatternType1 is required</description>
			<test>containsPaintType == true</test>
			<error>
				<message>Entry PaintType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PaintType-Integer" testNumber="6"/>
			<description>Entry PaintType with type Integer in PatternType1 shall have one of values: 1, 2</description>
			<test>PaintTypeHasTypeInteger != true || PaintTypeIntegerValue == 1 || PaintTypeIntegerValue == 2</test>
			<error>
				<message>Entry PaintType with type Integer in PatternType1 has incorrect value %1 instead of 1, 2</message>
				<arguments>
					<argument>PaintTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PatternType" testNumber="8"/>
			<description>Entry PatternType in PatternType1 shall have type Integer</description>
			<test>containsPatternType == false || PatternTypeHasTypeInteger == true</test>
			<error>
				<message>Entry PatternType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>PatternTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PatternType" testNumber="7"/>
			<description>Entry PatternType in PatternType1 is required</description>
			<test>containsPatternType == true</test>
			<error>
				<message>Entry PatternType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-PatternType-Integer" testNumber="6"/>
			<description>Entry PatternType with type Integer in PatternType1 shall have value 1</description>
			<test>PatternTypeHasTypeInteger != true || PatternTypeIntegerValue == 1</test>
			<error>
				<message>Entry PatternType with type Integer in PatternType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>PatternTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Resources" testNumber="8"/>
			<description>Entry Resources in PatternType1 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in PatternType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Resources" testNumber="7"/>
			<description>Entry Resources in PatternType1 is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-TilingType" testNumber="8"/>
			<description>Entry TilingType in PatternType1 shall have type Integer</description>
			<test>containsTilingType == false || TilingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry TilingType in PatternType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>TilingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-TilingType" testNumber="7"/>
			<description>Entry TilingType in PatternType1 is required</description>
			<test>containsTilingType == true</test>
			<error>
				<message>Entry TilingType in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-TilingType-Integer" testNumber="6"/>
			<description>Entry TilingType with type Integer in PatternType1 shall have one of values: 1, 2, 3</description>
			<test>TilingTypeHasTypeInteger != true || TilingTypeIntegerValue == 1 || TilingTypeIntegerValue == 2 || TilingTypeIntegerValue == 3</test>
			<error>
				<message>Entry TilingType with type Integer in PatternType1 has incorrect value %1 instead of 1, 2, 3</message>
				<arguments>
					<argument>TilingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Type" testNumber="8"/>
			<description>Entry Type in PatternType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PatternType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PatternType1 shall have value Pattern</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pattern"</test>
			<error>
				<message>Entry Type with type Name in PatternType1 has incorrect value %1 instead of Pattern</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-XStep" testNumber="8"/>
			<description>Entry XStep in PatternType1 shall have type Number</description>
			<test>containsXStep == false || XStepHasTypeNumber == true</test>
			<error>
				<message>Entry XStep in PatternType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>XStepType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-XStep" testNumber="7"/>
			<description>Entry XStep in PatternType1 is required</description>
			<test>containsXStep == true</test>
			<error>
				<message>Entry XStep in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-XUID" testNumber="8"/>
			<description>Entry XUID in PatternType1 shall have type Array</description>
			<test>containsXUID == false || XUIDHasTypeArray == true</test>
			<error>
				<message>Entry XUID in PatternType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>XUIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-XUID" testNumber="5"/>
			<description>Entry XUID in PatternType1 is deprecated since PDF 1.3</description>
			<test>containsXUID == false</test>
			<error>
				<message>Entry XUID in PatternType1 is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-YStep" testNumber="8"/>
			<description>Entry YStep in PatternType1 shall have type Number</description>
			<test>containsYStep == false || YStepHasTypeNumber == true</test>
			<error>
				<message>Entry YStep in PatternType1 has type %1 instead of type Number</message>
				<arguments>
					<argument>YStepType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType1">
			<id specification="PDF_1_4" clause="PatternType1-YStep" testNumber="7"/>
			<description>Entry YStep in PatternType1 is required</description>
			<test>containsYStep == true</test>
			<error>
				<message>Entry YStep in PatternType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2" testNumber="1"/>
			<description>PatternType2 shall not contain entries except ExtGState, Matrix, PatternType, Shading, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ExtGState' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PatternType' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>PatternType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ExtGState' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PatternType' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-ExtGState" testNumber="8"/>
			<description>Entry ExtGState in PatternType2 shall have type Dictionary</description>
			<test>containsExtGState == false || ExtGStateHasTypeDictionary == true</test>
			<error>
				<message>Entry ExtGState in PatternType2 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ExtGStateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Matrix" testNumber="8"/>
			<description>Entry Matrix in PatternType2 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in PatternType2 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-PatternType" testNumber="8"/>
			<description>Entry PatternType in PatternType2 shall have type Integer</description>
			<test>containsPatternType == false || PatternTypeHasTypeInteger == true</test>
			<error>
				<message>Entry PatternType in PatternType2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>PatternTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-PatternType" testNumber="7"/>
			<description>Entry PatternType in PatternType2 is required</description>
			<test>containsPatternType == true</test>
			<error>
				<message>Entry PatternType in PatternType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-PatternType-Integer" testNumber="6"/>
			<description>Entry PatternType with type Integer in PatternType2 shall have value 2</description>
			<test>PatternTypeHasTypeInteger != true || PatternTypeIntegerValue == 2</test>
			<error>
				<message>Entry PatternType with type Integer in PatternType2 has incorrect value %1 instead of 2</message>
				<arguments>
					<argument>PatternTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Shading-Dictionary" testNumber="17"/>
			<description>Entry Shading with type Dictionary in PatternType2 shall be one of objects ShadingType1, ShadingType2, ShadingType3</description>
			<test>ShadingHasTypeDictionary != true || Shading_size == 1</test>
			<error>
				<message>Entry Shading with type Dictionary in PatternType2 is not one of objects ShadingType1, ShadingType2, ShadingType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Shading-Stream" testNumber="17"/>
			<description>Entry Shading with type Stream in PatternType2 shall be one of objects ShadingType4, ShadingType5, ShadingType6, ShadingType7</description>
			<test>ShadingHasTypeStream != true || Shading_size == 1</test>
			<error>
				<message>Entry Shading with type Stream in PatternType2 is not one of objects ShadingType4, ShadingType5, ShadingType6, ShadingType7</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Shading" testNumber="8"/>
			<description>Entry Shading in PatternType2 shall have one of types: Dictionary, Stream</description>
			<test>containsShading == false || ShadingHasTypeDictionary == true || ShadingHasTypeStream == true</test>
			<error>
				<message>Entry Shading in PatternType2 has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>ShadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Shading" testNumber="7"/>
			<description>Entry Shading in PatternType2 is required</description>
			<test>containsShading == true</test>
			<error>
				<message>Entry Shading in PatternType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Shading-Stream" testNumber="10"/>
			<description>Entry Shading with type Stream in PatternType2 shall be indirect</description>
			<test>ShadingHasTypeStream != true || isShadingIndirect == true</test>
			<error>
				<message>Entry Shading with type Stream in PatternType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Type" testNumber="8"/>
			<description>Entry Type in PatternType2 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in PatternType2 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="APatternType2">
			<id specification="PDF_1_4" clause="PatternType2-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in PatternType2 shall have value Pattern</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Pattern"</test>
			<error>
				<message>Entry Type with type Name in PatternType2 has incorrect value %1 instead of Pattern</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference" testNumber="1"/>
			<description>Reference shall not contain entries except F, ID, Page</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Page' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Reference contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'Page' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-F" testNumber="8"/>
			<description>Entry F in Reference shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Reference has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-F" testNumber="7"/>
			<description>Entry F in Reference is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in Reference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-ID" testNumber="8"/>
			<description>Entry ID in Reference shall have type Array</description>
			<test>containsID == false || entryIDHasTypeArray == true</test>
			<error>
				<message>Entry ID in Reference has type %1 instead of type Array</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-Page" testNumber="8"/>
			<description>Entry Page in Reference shall have one of types: Integer, StringText</description>
			<test>containsPage == false || PageHasTypeInteger == true || PageHasTypeStringText == true</test>
			<error>
				<message>Entry Page in Reference has type %1 instead of one of types: Integer, StringText</message>
				<arguments>
					<argument>PageType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-Page" testNumber="7"/>
			<description>Entry Page in Reference is required</description>
			<test>containsPage == true</test>
			<error>
				<message>Entry Page in Reference is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AReference">
			<id specification="PDF_1_4" clause="Reference-Page-Integer" testNumber="14"/>
			<description>Entry Page with type Integer in Reference shall satisfy possible value predicate: fn:Eval(@Page &gt;= 0)</description>
			<test>PageHasTypeInteger != true || PageIntegerValue &gt;= 0</test>
			<error>
				<message>Entry Page with type Integer in Reference does not satisfy possible value predicate: fn:Eval(@Page &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ARelatedFilesArray">
			<id specification="PDF_1_4" clause="RelatedFilesArray" testNumber="3"/>
			<description>RelatedFilesArray shall contain 2 * n elements</description>
			<test>size % 2 == 0</test>
			<error>
				<message>RelatedFilesArray contains %1 element(s)</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ARelatedFilesArraySubArray">
			<id specification="PDF_1_4" clause="RelatedFilesArraySubArray" testNumber="2"/>
			<description>RelatedFilesArraySubArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>RelatedFilesArraySubArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ARelatedFilesArraySubArray">
			<id specification="PDF_1_4" clause="RelatedFilesArraySubArray-0" testNumber="8"/>
			<description>Entry 0 in RelatedFilesArraySubArray shall have type String</description>
			<test>size &lt;= 0 || entry0HasTypeString == true</test>
			<error>
				<message>Entry 0 in RelatedFilesArraySubArray has type %1 instead of type String</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ARelatedFilesArraySubArray">
			<id specification="PDF_1_4" clause="RelatedFilesArraySubArray-1" testNumber="8"/>
			<description>Entry 1 in RelatedFilesArraySubArray shall have type Stream</description>
			<test>size &lt;= 1 || entry1HasTypeStream == true</test>
			<error>
				<message>Entry 1 in RelatedFilesArraySubArray has type %1 instead of type Stream</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ARelatedFilesArraySubArray">
			<id specification="PDF_1_4" clause="RelatedFilesArraySubArray-1-Stream" testNumber="10"/>
			<description>Entry 1 with type Stream in RelatedFilesArraySubArray shall be indirect</description>
			<test>entry1HasTypeStream != true || isentry1Indirect == true</test>
			<error>
				<message>Entry 1 with type Stream in RelatedFilesArraySubArray is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource" testNumber="1"/>
			<description>Resource shall not contain entries except ColorSpace, Encoding, ExtGState, Font, Pattern, ProcSet, Properties, Shading, XObject</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'ExtGState' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'Pattern' &amp;&amp; elem != 'ProcSet' &amp;&amp; elem != 'Properties' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'XObject' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Resource contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'Encoding' &amp;&amp; elem != 'ExtGState' &amp;&amp; elem != 'Font' &amp;&amp; elem != 'Pattern' &amp;&amp; elem != 'ProcSet' &amp;&amp; elem != 'Properties' &amp;&amp; elem != 'Shading' &amp;&amp; elem != 'XObject' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in Resource shall have type Dictionary</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeDictionary == true</test>
			<error>
				<message>Entry ColorSpace in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Encoding" testNumber="8"/>
			<description>Entry Encoding in Resource shall have type Dictionary</description>
			<test>containsEncoding == false || EncodingHasTypeDictionary == true</test>
			<error>
				<message>Entry Encoding in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>EncodingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Encoding" testNumber="5"/>
			<description>Entry Encoding in Resource is deprecated since PDF 1.2</description>
			<test>containsEncoding == false</test>
			<error>
				<message>Entry Encoding in Resource is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-ExtGState" testNumber="8"/>
			<description>Entry ExtGState in Resource shall have type Dictionary</description>
			<test>containsExtGState == false || ExtGStateHasTypeDictionary == true</test>
			<error>
				<message>Entry ExtGState in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ExtGStateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Font" testNumber="8"/>
			<description>Entry Font in Resource shall have type Dictionary</description>
			<test>containsFont == false || FontHasTypeDictionary == true</test>
			<error>
				<message>Entry Font in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FontType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Pattern" testNumber="8"/>
			<description>Entry Pattern in Resource shall have type Dictionary</description>
			<test>containsPattern == false || PatternHasTypeDictionary == true</test>
			<error>
				<message>Entry Pattern in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PatternType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-ProcSet" testNumber="8"/>
			<description>Entry ProcSet in Resource shall have type Array</description>
			<test>containsProcSet == false || ProcSetHasTypeArray == true</test>
			<error>
				<message>Entry ProcSet in Resource has type %1 instead of type Array</message>
				<arguments>
					<argument>ProcSetType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Properties" testNumber="8"/>
			<description>Entry Properties in Resource shall have type Dictionary</description>
			<test>containsProperties == false || entryPropertiesHasTypeDictionary == true</test>
			<error>
				<message>Entry Properties in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>entryPropertiesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-Shading" testNumber="8"/>
			<description>Entry Shading in Resource shall have type Dictionary</description>
			<test>containsShading == false || ShadingHasTypeDictionary == true</test>
			<error>
				<message>Entry Shading in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ShadingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AResource">
			<id specification="PDF_1_4" clause="Resource-XObject" testNumber="8"/>
			<description>Entry XObject in Resource shall have type Dictionary</description>
			<test>containsXObject == false || XObjectHasTypeDictionary == true</test>
			<error>
				<message>Entry XObject in Resource has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>XObjectType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ARoleMapEntry">
			<id specification="PDF_1_4" clause="RoleMapEntry" testNumber="8"/>
			<description>Entry in RoleMap shall have type Name</description>
			<test>HasTypeName == true</test>
			<error>
				<message>Entry %keyName% in RoleMap has type %1 instead of type Name</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation" testNumber="1"/>
			<description>Separation shall not contain entries except ColorSpace, DeviceColorant, Pages</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'DeviceColorant' &amp;&amp; elem != 'Pages' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Separation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ColorSpace' &amp;&amp; elem != 'DeviceColorant' &amp;&amp; elem != 'Pages' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in Separation shall be one of objects SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in Separation is not one of objects SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in Separation shall have type Array</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true</test>
			<error>
				<message>Entry ColorSpace in Separation has type %1 instead of type Array</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-DeviceColorant" testNumber="8"/>
			<description>Entry DeviceColorant in Separation shall have one of types: Name, String</description>
			<test>containsDeviceColorant == false || DeviceColorantHasTypeName == true || DeviceColorantHasTypeString == true</test>
			<error>
				<message>Entry DeviceColorant in Separation has type %1 instead of one of types: Name, String</message>
				<arguments>
					<argument>DeviceColorantType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-DeviceColorant" testNumber="7"/>
			<description>Entry DeviceColorant in Separation is required</description>
			<test>containsDeviceColorant == true</test>
			<error>
				<message>Entry DeviceColorant in Separation is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-Pages" testNumber="8"/>
			<description>Entry Pages in Separation shall have type Array</description>
			<test>containsPages == false || PagesHasTypeArray == true</test>
			<error>
				<message>Entry Pages in Separation has type %1 instead of type Array</message>
				<arguments>
					<argument>PagesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparation">
			<id specification="PDF_1_4" clause="Separation-Pages" testNumber="7"/>
			<description>Entry Pages in Separation is required</description>
			<test>containsPages == true</test>
			<error>
				<message>Entry Pages in Separation is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace" testNumber="2"/>
			<description>SeparationColorSpace shall contain exactly 4 elements</description>
			<test>size == 4</test>
			<error>
				<message>SeparationColorSpace contains %1 element(s) instead of 4</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-0" testNumber="8"/>
			<description>Entry 0 in SeparationColorSpace shall have type Name</description>
			<test>size &lt;= 0 || entry0HasTypeName == true</test>
			<error>
				<message>Entry 0 in SeparationColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-0-Name" testNumber="6"/>
			<description>Entry 0 with type Name in SeparationColorSpace shall have value Separation</description>
			<test>entry0HasTypeName != true || entry0NameValue == "Separation"</test>
			<error>
				<message>Entry 0 with type Name in SeparationColorSpace has incorrect value %1 instead of Separation</message>
				<arguments>
					<argument>entry0NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-1" testNumber="8"/>
			<description>Entry 1 in SeparationColorSpace shall have type Name</description>
			<test>size &lt;= 1 || entry1HasTypeName == true</test>
			<error>
				<message>Entry 1 in SeparationColorSpace has type %1 instead of type Name</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-2-Array" testNumber="17"/>
			<description>Entry 2 with type Array in SeparationColorSpace shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace</description>
			<test>entry2HasTypeArray != true || entry2_size == 1</test>
			<error>
				<message>Entry 2 with type Array in SeparationColorSpace is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-2" testNumber="8"/>
			<description>Entry 2 in SeparationColorSpace shall have one of types: Array, Name</description>
			<test>size &lt;= 2 || entry2HasTypeArray == true || entry2HasTypeName == true</test>
			<error>
				<message>Entry 2 in SeparationColorSpace has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-2-Name" testNumber="6"/>
			<description>Entry 2 with type Name in SeparationColorSpace shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>entry2HasTypeName != true || entry2NameValue == "DeviceCMYK" || entry2NameValue == "DeviceRGB" || entry2NameValue == "DeviceGray"</test>
			<error>
				<message>Entry 2 with type Name in SeparationColorSpace has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>entry2NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-3-Dictionary" testNumber="17"/>
			<description>Entry 3 with type Dictionary in SeparationColorSpace shall be one of objects FunctionType2, FunctionType3</description>
			<test>entry3HasTypeDictionary != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Dictionary in SeparationColorSpace is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-3-Stream" testNumber="17"/>
			<description>Entry 3 with type Stream in SeparationColorSpace shall be one of objects FunctionType0, FunctionType4</description>
			<test>entry3HasTypeStream != true || entry3_size == 1</test>
			<error>
				<message>Entry 3 with type Stream in SeparationColorSpace is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-3" testNumber="8"/>
			<description>Entry 3 in SeparationColorSpace shall have one of types: Dictionary, Stream</description>
			<test>size &lt;= 3 || entry3HasTypeDictionary == true || entry3HasTypeStream == true</test>
			<error>
				<message>Entry 3 in SeparationColorSpace has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>entry3Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASeparationColorSpace">
			<id specification="PDF_1_4" clause="SeparationColorSpace-3-Stream" testNumber="10"/>
			<description>Entry 3 with type Stream in SeparationColorSpace shall be indirect</description>
			<test>entry3HasTypeStream != true || isentry3Indirect == true</test>
			<error>
				<message>Entry 3 with type Stream in SeparationColorSpace is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingMapEntry">
			<id specification="PDF_1_4" clause="ShadingMapEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in ShadingMap shall be one of objects ShadingType1, ShadingType2, ShadingType3</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in ShadingMap is not one of objects ShadingType1, ShadingType2, ShadingType3</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingMapEntry">
			<id specification="PDF_1_4" clause="ShadingMapEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in ShadingMap shall be one of objects ShadingType4, ShadingType5, ShadingType6, ShadingType7</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in ShadingMap is not one of objects ShadingType4, ShadingType5, ShadingType6, ShadingType7</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingMapEntry">
			<id specification="PDF_1_4" clause="ShadingMapEntry" testNumber="8"/>
			<description>Entry in ShadingMap shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in ShadingMap has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingMapEntry">
			<id specification="PDF_1_4" clause="ShadingMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in ShadingMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in ShadingMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1" testNumber="1"/>
			<description>ShadingType1 shall not contain entries except AntiAlias, BBox, Background, ColorSpace, Domain, Function, Matrix, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType1 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType1 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType1 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Background" testNumber="8"/>
			<description>Entry Background in ShadingType1 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType1 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType1 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType1 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType1 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType1 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType1 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Domain" testNumber="8"/>
			<description>Entry Domain in ShadingType1 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in ShadingType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType1 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType1 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType1 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType1 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Function" testNumber="8"/>
			<description>Entry Function in ShadingType1 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType1 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Function" testNumber="7"/>
			<description>Entry Function in ShadingType1 is required</description>
			<test>containsFunction == true</test>
			<error>
				<message>Entry Function in ShadingType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType1 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-Matrix" testNumber="8"/>
			<description>Entry Matrix in ShadingType1 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in ShadingType1 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType1 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType1 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType1">
			<id specification="PDF_1_4" clause="ShadingType1-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType1 shall have value 1</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 1</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2" testNumber="1"/>
			<description>ShadingType2 shall not contain entries except AntiAlias, BBox, Background, ColorSpace, Coords, Domain, Extend, Function, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Coords' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Extend' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType2 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Coords' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Extend' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType2 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType2 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType2 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType2 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Background" testNumber="8"/>
			<description>Entry Background in ShadingType2 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType2 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType2 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType2 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType2 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType2 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType2 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType2 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Coords" testNumber="8"/>
			<description>Entry Coords in ShadingType2 shall have type Array</description>
			<test>containsCoords == false || CoordsHasTypeArray == true</test>
			<error>
				<message>Entry Coords in ShadingType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>CoordsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Coords" testNumber="7"/>
			<description>Entry Coords in ShadingType2 is required</description>
			<test>containsCoords == true</test>
			<error>
				<message>Entry Coords in ShadingType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Domain" testNumber="8"/>
			<description>Entry Domain in ShadingType2 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in ShadingType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Extend" testNumber="8"/>
			<description>Entry Extend in ShadingType2 shall have type Array</description>
			<test>containsExtend == false || ExtendHasTypeArray == true</test>
			<error>
				<message>Entry Extend in ShadingType2 has type %1 instead of type Array</message>
				<arguments>
					<argument>ExtendType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType2 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType2 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType2 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType2 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Function" testNumber="8"/>
			<description>Entry Function in ShadingType2 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType2 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Function" testNumber="7"/>
			<description>Entry Function in ShadingType2 is required</description>
			<test>containsFunction == true</test>
			<error>
				<message>Entry Function in ShadingType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType2 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType2 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType2 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType2 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType2 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType2 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType2">
			<id specification="PDF_1_4" clause="ShadingType2-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType2 shall have value 2</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 2</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType2 has incorrect value %1 instead of 2</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3" testNumber="1"/>
			<description>ShadingType3 shall not contain entries except AntiAlias, BBox, Background, ColorSpace, Coords, Domain, Extend, Function, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Coords' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Extend' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType3 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'Coords' &amp;&amp; elem != 'Domain' &amp;&amp; elem != 'Extend' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType3 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType3 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType3 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType3 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Background" testNumber="8"/>
			<description>Entry Background in ShadingType3 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType3 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType3 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType3 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType3 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType3 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType3 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType3 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Coords" testNumber="8"/>
			<description>Entry Coords in ShadingType3 shall have type Array</description>
			<test>containsCoords == false || CoordsHasTypeArray == true</test>
			<error>
				<message>Entry Coords in ShadingType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>CoordsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Coords" testNumber="7"/>
			<description>Entry Coords in ShadingType3 is required</description>
			<test>containsCoords == true</test>
			<error>
				<message>Entry Coords in ShadingType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Domain" testNumber="8"/>
			<description>Entry Domain in ShadingType3 shall have type Array</description>
			<test>containsDomain == false || DomainHasTypeArray == true</test>
			<error>
				<message>Entry Domain in ShadingType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>DomainType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Extend" testNumber="8"/>
			<description>Entry Extend in ShadingType3 shall have type Array</description>
			<test>containsExtend == false || ExtendHasTypeArray == true</test>
			<error>
				<message>Entry Extend in ShadingType3 has type %1 instead of type Array</message>
				<arguments>
					<argument>ExtendType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType3 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType3 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType3 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType3 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Function" testNumber="8"/>
			<description>Entry Function in ShadingType3 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType3 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Function" testNumber="7"/>
			<description>Entry Function in ShadingType3 is required</description>
			<test>containsFunction == true</test>
			<error>
				<message>Entry Function in ShadingType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType3 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType3 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType3 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType3 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType3 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType3 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType3">
			<id specification="PDF_1_4" clause="ShadingType3-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType3 shall have value 3</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 3</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType3 has incorrect value %1 instead of 3</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4" testNumber="1"/>
			<description>ShadingType4 shall not contain entries except AntiAlias, BBox, Background, BitsPerComponent, BitsPerCoordinate, BitsPerFlag, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Function, Length, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType4 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4" testNumber="22"/>
			<description>ShadingType4 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ShadingType4 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType4 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType4 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType4 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType4 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Background" testNumber="8"/>
			<description>Entry Background in ShadingType4 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType4 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in ShadingType4 shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in ShadingType4 is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in ShadingType4 shall have one of values: 1, 12, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 12 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in ShadingType4 has incorrect value %1 instead of 1, 12, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerCoordinate" testNumber="8"/>
			<description>Entry BitsPerCoordinate in ShadingType4 shall have type Integer</description>
			<test>containsBitsPerCoordinate == false || BitsPerCoordinateHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerCoordinateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerCoordinate" testNumber="7"/>
			<description>Entry BitsPerCoordinate in ShadingType4 is required</description>
			<test>containsBitsPerCoordinate == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerCoordinate-Integer" testNumber="6"/>
			<description>Entry BitsPerCoordinate with type Integer in ShadingType4 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerCoordinateHasTypeInteger != true || BitsPerCoordinateIntegerValue == 1 || BitsPerCoordinateIntegerValue == 2 || BitsPerCoordinateIntegerValue == 4 || BitsPerCoordinateIntegerValue == 8 || BitsPerCoordinateIntegerValue == 12 || BitsPerCoordinateIntegerValue == 16 || BitsPerCoordinateIntegerValue == 24 || BitsPerCoordinateIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerCoordinate with type Integer in ShadingType4 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerCoordinateIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerFlag" testNumber="8"/>
			<description>Entry BitsPerFlag in ShadingType4 shall have type Integer</description>
			<test>containsBitsPerFlag == false || BitsPerFlagHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerFlagType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerFlag" testNumber="7"/>
			<description>Entry BitsPerFlag in ShadingType4 is required</description>
			<test>containsBitsPerFlag == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-BitsPerFlag-Integer" testNumber="6"/>
			<description>Entry BitsPerFlag with type Integer in ShadingType4 shall have one of values: 2, 4, 8</description>
			<test>BitsPerFlagHasTypeInteger != true || BitsPerFlagIntegerValue == 2 || BitsPerFlagIntegerValue == 4 || BitsPerFlagIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerFlag with type Integer in ShadingType4 has incorrect value %1 instead of 2, 4, 8</message>
				<arguments>
					<argument>BitsPerFlagIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType4 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType4 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType4 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType4 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType4 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType4 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType4 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Decode" testNumber="8"/>
			<description>Entry Decode in ShadingType4 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in ShadingType4 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ShadingType4 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ShadingType4 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ShadingType4 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ShadingType4 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ShadingType4 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ShadingType4 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-F" testNumber="8"/>
			<description>Entry F in ShadingType4 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ShadingType4 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ShadingType4 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ShadingType4 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ShadingType4 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ShadingType4 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ShadingType4 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ShadingType4 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FFilter" testNumber="8"/>
			<description>Entry FFilter in ShadingType4 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ShadingType4 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ShadingType4 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ShadingType4 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ShadingType4 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ShadingType4 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Filter" testNumber="8"/>
			<description>Entry Filter in ShadingType4 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ShadingType4 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ShadingType4 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ShadingType4 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ShadingType4 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ShadingType4 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType4 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType4 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType4 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType4 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Function" testNumber="8"/>
			<description>Entry Function in ShadingType4 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType4 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType4 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType4 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Length" testNumber="8"/>
			<description>Entry Length in ShadingType4 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ShadingType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-Length" testNumber="7"/>
			<description>Entry Length in ShadingType4 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType4 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType4 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType4 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType4 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType4">
			<id specification="PDF_1_4" clause="ShadingType4-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType4 shall have value 4</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 4</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType4 has incorrect value %1 instead of 4</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5" testNumber="1"/>
			<description>ShadingType5 shall not contain entries except AntiAlias, BBox, Background, BitsPerComponent, BitsPerCoordinate, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Function, Length, ShadingType, VerticesPerRow</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; elem != 'VerticesPerRow' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType5 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; elem != 'VerticesPerRow' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5" testNumber="22"/>
			<description>ShadingType5 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ShadingType5 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType5 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType5 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType5 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType5 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Background" testNumber="8"/>
			<description>Entry Background in ShadingType5 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType5 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in ShadingType5 shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in ShadingType5 is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in ShadingType5 shall have one of values: 1, 12, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 12 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in ShadingType5 has incorrect value %1 instead of 1, 12, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerCoordinate" testNumber="8"/>
			<description>Entry BitsPerCoordinate in ShadingType5 shall have type Integer</description>
			<test>containsBitsPerCoordinate == false || BitsPerCoordinateHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerCoordinateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerCoordinate" testNumber="7"/>
			<description>Entry BitsPerCoordinate in ShadingType5 is required</description>
			<test>containsBitsPerCoordinate == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-BitsPerCoordinate-Integer" testNumber="6"/>
			<description>Entry BitsPerCoordinate with type Integer in ShadingType5 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerCoordinateHasTypeInteger != true || BitsPerCoordinateIntegerValue == 1 || BitsPerCoordinateIntegerValue == 2 || BitsPerCoordinateIntegerValue == 4 || BitsPerCoordinateIntegerValue == 8 || BitsPerCoordinateIntegerValue == 12 || BitsPerCoordinateIntegerValue == 16 || BitsPerCoordinateIntegerValue == 24 || BitsPerCoordinateIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerCoordinate with type Integer in ShadingType5 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerCoordinateIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType5 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType5 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType5 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType5 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType5 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType5 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType5 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Decode" testNumber="8"/>
			<description>Entry Decode in ShadingType5 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in ShadingType5 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ShadingType5 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ShadingType5 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ShadingType5 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ShadingType5 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ShadingType5 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ShadingType5 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-F" testNumber="8"/>
			<description>Entry F in ShadingType5 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ShadingType5 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ShadingType5 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ShadingType5 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ShadingType5 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ShadingType5 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ShadingType5 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ShadingType5 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FFilter" testNumber="8"/>
			<description>Entry FFilter in ShadingType5 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ShadingType5 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ShadingType5 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ShadingType5 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ShadingType5 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ShadingType5 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Filter" testNumber="8"/>
			<description>Entry Filter in ShadingType5 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ShadingType5 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ShadingType5 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ShadingType5 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ShadingType5 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ShadingType5 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType5 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType5 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType5 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType5 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Function" testNumber="8"/>
			<description>Entry Function in ShadingType5 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType5 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType5 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType5 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Length" testNumber="8"/>
			<description>Entry Length in ShadingType5 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ShadingType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-Length" testNumber="7"/>
			<description>Entry Length in ShadingType5 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType5 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType5 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType5 shall have value 5</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 5</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType5 has incorrect value %1 instead of 5</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-VerticesPerRow" testNumber="8"/>
			<description>Entry VerticesPerRow in ShadingType5 shall have type Integer</description>
			<test>containsVerticesPerRow == false || VerticesPerRowHasTypeInteger == true</test>
			<error>
				<message>Entry VerticesPerRow in ShadingType5 has type %1 instead of type Integer</message>
				<arguments>
					<argument>VerticesPerRowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-VerticesPerRow" testNumber="7"/>
			<description>Entry VerticesPerRow in ShadingType5 is required</description>
			<test>containsVerticesPerRow == true</test>
			<error>
				<message>Entry VerticesPerRow in ShadingType5 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType5">
			<id specification="PDF_1_4" clause="ShadingType5-VerticesPerRow-Integer" testNumber="14"/>
			<description>Entry VerticesPerRow with type Integer in ShadingType5 shall satisfy possible value predicate: fn:Eval(@VerticesPerRow &gt;= 2)</description>
			<test>VerticesPerRowHasTypeInteger != true || VerticesPerRowIntegerValue &gt;= 2</test>
			<error>
				<message>Entry VerticesPerRow with type Integer in ShadingType5 does not satisfy possible value predicate: fn:Eval(@VerticesPerRow &gt;= 2)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6" testNumber="1"/>
			<description>ShadingType6 shall not contain entries except AntiAlias, BBox, Background, BitsPerComponent, BitsPerCoordinate, BitsPerFlag, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Function, Length, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType6 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6" testNumber="22"/>
			<description>ShadingType6 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ShadingType6 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType6 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType6 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType6 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType6 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Background" testNumber="8"/>
			<description>Entry Background in ShadingType6 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType6 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in ShadingType6 shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in ShadingType6 is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in ShadingType6 shall have one of values: 1, 12, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 12 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in ShadingType6 has incorrect value %1 instead of 1, 12, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerCoordinate" testNumber="8"/>
			<description>Entry BitsPerCoordinate in ShadingType6 shall have type Integer</description>
			<test>containsBitsPerCoordinate == false || BitsPerCoordinateHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerCoordinateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerCoordinate" testNumber="7"/>
			<description>Entry BitsPerCoordinate in ShadingType6 is required</description>
			<test>containsBitsPerCoordinate == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerCoordinate-Integer" testNumber="6"/>
			<description>Entry BitsPerCoordinate with type Integer in ShadingType6 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerCoordinateHasTypeInteger != true || BitsPerCoordinateIntegerValue == 1 || BitsPerCoordinateIntegerValue == 2 || BitsPerCoordinateIntegerValue == 4 || BitsPerCoordinateIntegerValue == 8 || BitsPerCoordinateIntegerValue == 12 || BitsPerCoordinateIntegerValue == 16 || BitsPerCoordinateIntegerValue == 24 || BitsPerCoordinateIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerCoordinate with type Integer in ShadingType6 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerCoordinateIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerFlag" testNumber="8"/>
			<description>Entry BitsPerFlag in ShadingType6 shall have type Integer</description>
			<test>containsBitsPerFlag == false || BitsPerFlagHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerFlagType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-BitsPerFlag" testNumber="7"/>
			<description>Entry BitsPerFlag in ShadingType6 is required</description>
			<test>containsBitsPerFlag == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType6 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType6 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType6 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType6 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType6 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType6 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType6 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Decode" testNumber="8"/>
			<description>Entry Decode in ShadingType6 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in ShadingType6 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ShadingType6 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ShadingType6 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ShadingType6 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ShadingType6 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ShadingType6 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ShadingType6 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-F" testNumber="8"/>
			<description>Entry F in ShadingType6 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ShadingType6 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ShadingType6 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ShadingType6 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ShadingType6 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ShadingType6 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ShadingType6 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ShadingType6 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FFilter" testNumber="8"/>
			<description>Entry FFilter in ShadingType6 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ShadingType6 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ShadingType6 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ShadingType6 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ShadingType6 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ShadingType6 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Filter" testNumber="8"/>
			<description>Entry Filter in ShadingType6 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ShadingType6 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ShadingType6 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ShadingType6 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ShadingType6 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ShadingType6 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType6 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType6 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType6 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType6 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Function" testNumber="8"/>
			<description>Entry Function in ShadingType6 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType6 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType6 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType6 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Length" testNumber="8"/>
			<description>Entry Length in ShadingType6 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ShadingType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-Length" testNumber="7"/>
			<description>Entry Length in ShadingType6 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType6 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType6 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType6 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType6 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType6">
			<id specification="PDF_1_4" clause="ShadingType6-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType6 shall have value 6</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 6</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType6 has incorrect value %1 instead of 6</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7" testNumber="1"/>
			<description>ShadingType7 shall not contain entries except AntiAlias, BBox, Background, BitsPerComponent, BitsPerCoordinate, BitsPerFlag, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Function, Length, ShadingType</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ShadingType7 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AntiAlias' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Background' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'BitsPerCoordinate' &amp;&amp; elem != 'BitsPerFlag' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Function' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'ShadingType' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7" testNumber="22"/>
			<description>ShadingType7 shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ShadingType7 contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-AntiAlias" testNumber="8"/>
			<description>Entry AntiAlias in ShadingType7 shall have type Boolean</description>
			<test>containsAntiAlias == false || AntiAliasHasTypeBoolean == true</test>
			<error>
				<message>Entry AntiAlias in ShadingType7 has type %1 instead of type Boolean</message>
				<arguments>
					<argument>AntiAliasType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BBox" testNumber="8"/>
			<description>Entry BBox in ShadingType7 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in ShadingType7 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Background" testNumber="8"/>
			<description>Entry Background in ShadingType7 shall have type Array</description>
			<test>containsBackground == false || BackgroundHasTypeArray == true</test>
			<error>
				<message>Entry Background in ShadingType7 has type %1 instead of type Array</message>
				<arguments>
					<argument>BackgroundType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in ShadingType7 shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType7 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in ShadingType7 is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in ShadingType7 shall have one of values: 1, 12, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 12 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in ShadingType7 has incorrect value %1 instead of 1, 12, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerCoordinate" testNumber="8"/>
			<description>Entry BitsPerCoordinate in ShadingType7 shall have type Integer</description>
			<test>containsBitsPerCoordinate == false || BitsPerCoordinateHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType7 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerCoordinateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerCoordinate" testNumber="7"/>
			<description>Entry BitsPerCoordinate in ShadingType7 is required</description>
			<test>containsBitsPerCoordinate == true</test>
			<error>
				<message>Entry BitsPerCoordinate in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerCoordinate-Integer" testNumber="6"/>
			<description>Entry BitsPerCoordinate with type Integer in ShadingType7 shall have one of values: 1, 12, 2, 24, 4, 16, 8, 32</description>
			<test>BitsPerCoordinateHasTypeInteger != true || BitsPerCoordinateIntegerValue == 1 || BitsPerCoordinateIntegerValue == 2 || BitsPerCoordinateIntegerValue == 4 || BitsPerCoordinateIntegerValue == 8 || BitsPerCoordinateIntegerValue == 12 || BitsPerCoordinateIntegerValue == 16 || BitsPerCoordinateIntegerValue == 24 || BitsPerCoordinateIntegerValue == 32</test>
			<error>
				<message>Entry BitsPerCoordinate with type Integer in ShadingType7 has incorrect value %1 instead of 1, 12, 2, 24, 4, 16, 8, 32</message>
				<arguments>
					<argument>BitsPerCoordinateIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerFlag" testNumber="8"/>
			<description>Entry BitsPerFlag in ShadingType7 shall have type Integer</description>
			<test>containsBitsPerFlag == false || BitsPerFlagHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType7 has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerFlagType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-BitsPerFlag" testNumber="7"/>
			<description>Entry BitsPerFlag in ShadingType7 is required</description>
			<test>containsBitsPerFlag == true</test>
			<error>
				<message>Entry BitsPerFlag in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in ShadingType7 shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in ShadingType7 is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in ShadingType7 shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType7 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in ShadingType7 is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in ShadingType7 shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in ShadingType7 has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Decode" testNumber="8"/>
			<description>Entry Decode in ShadingType7 shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in ShadingType7 has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ShadingType7 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ShadingType7 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ShadingType7 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ShadingType7 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ShadingType7 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ShadingType7 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-F" testNumber="8"/>
			<description>Entry F in ShadingType7 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ShadingType7 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ShadingType7 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ShadingType7 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ShadingType7 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ShadingType7 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ShadingType7 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ShadingType7 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FFilter" testNumber="8"/>
			<description>Entry FFilter in ShadingType7 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ShadingType7 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ShadingType7 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ShadingType7 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ShadingType7 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ShadingType7 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Filter" testNumber="8"/>
			<description>Entry Filter in ShadingType7 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ShadingType7 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ShadingType7 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ShadingType7 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ShadingType7 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ShadingType7 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Function-Dictionary" testNumber="17"/>
			<description>Entry Function with type Dictionary in ShadingType7 shall be one of objects FunctionType2, FunctionType3</description>
			<test>FunctionHasTypeDictionary != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Dictionary in ShadingType7 is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Function-Stream" testNumber="17"/>
			<description>Entry Function with type Stream in ShadingType7 shall be one of objects FunctionType0, FunctionType4</description>
			<test>FunctionHasTypeStream != true || Function_size == 1</test>
			<error>
				<message>Entry Function with type Stream in ShadingType7 is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Function" testNumber="8"/>
			<description>Entry Function in ShadingType7 shall have one of types: Array, Dictionary, Stream</description>
			<test>containsFunction == false || FunctionHasTypeArray == true || FunctionHasTypeDictionary == true || FunctionHasTypeStream == true</test>
			<error>
				<message>Entry Function in ShadingType7 has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>FunctionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Function-Stream" testNumber="10"/>
			<description>Entry Function with type Stream in ShadingType7 shall be indirect</description>
			<test>FunctionHasTypeStream != true || isFunctionIndirect == true</test>
			<error>
				<message>Entry Function with type Stream in ShadingType7 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Length" testNumber="8"/>
			<description>Entry Length in ShadingType7 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ShadingType7 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-Length" testNumber="7"/>
			<description>Entry Length in ShadingType7 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ShadingType" testNumber="8"/>
			<description>Entry ShadingType in ShadingType7 shall have type Integer</description>
			<test>containsShadingType == false || ShadingTypeHasTypeInteger == true</test>
			<error>
				<message>Entry ShadingType in ShadingType7 has type %1 instead of type Integer</message>
				<arguments>
					<argument>ShadingTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ShadingType" testNumber="7"/>
			<description>Entry ShadingType in ShadingType7 is required</description>
			<test>containsShadingType == true</test>
			<error>
				<message>Entry ShadingType in ShadingType7 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AShadingType7">
			<id specification="PDF_1_4" clause="ShadingType7-ShadingType-Integer" testNumber="6"/>
			<description>Entry ShadingType with type Integer in ShadingType7 shall have value 7</description>
			<test>ShadingTypeHasTypeInteger != true || ShadingTypeIntegerValue == 7</test>
			<error>
				<message>Entry ShadingType with type Integer in ShadingType7 has incorrect value %1 instead of 7</message>
				<arguments>
					<argument>ShadingTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature" testNumber="1"/>
			<description>Signature shall not contain entries except ADBE_Build, ByteRange, Cert, Changes, ContactInfo, Contents, Filter, Location, M, Name, R, Reason, SubFilter, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'ADBE_Build' &amp;&amp; elem != 'ByteRange' &amp;&amp; elem != 'Cert' &amp;&amp; elem != 'Changes' &amp;&amp; elem != 'ContactInfo' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Location' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Prop_AuthTime' &amp;&amp; elem != 'Prop_AuthType' &amp;&amp; elem != 'Prop_Build' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Reason' &amp;&amp; elem != 'Reference' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Signature contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'ADBE_Build' &amp;&amp; elem != 'ByteRange' &amp;&amp; elem != 'Cert' &amp;&amp; elem != 'Changes' &amp;&amp; elem != 'ContactInfo' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Location' &amp;&amp; elem != 'M' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Prop_AuthTime' &amp;&amp; elem != 'Prop_AuthType' &amp;&amp; elem != 'Prop_Build' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Reason' &amp;&amp; elem != 'Reference' &amp;&amp; elem != 'SubFilter' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature" testNumber="22"/>
			<description>Signature shall not contain entries Prop_AuthTime, Prop_AuthType, Prop_Build, Reference, V in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Prop_AuthTime' || elem == 'Prop_AuthType' || elem == 'Prop_Build' || elem == 'Reference' || elem == 'V').length == 0</test>
			<error>
				<message>Signature contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Prop_AuthTime' || elem == 'Prop_AuthType' || elem == 'Prop_Build' || elem == 'Reference' || elem == 'V').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ADBE_Build" testNumber="8"/>
			<description>Entry ADBE_Build in Signature shall have type String</description>
			<test>containsADBE_Build == false || ADBE_BuildHasTypeString == true</test>
			<error>
				<message>Entry ADBE_Build in Signature has type %1 instead of type String</message>
				<arguments>
					<argument>ADBE_BuildType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ADBE_Build-String" testNumber="16"/>
			<description>If entry ADBE_Build with type String in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ADBE_BuildHasTypeString != true || (isADBE_BuildIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry ADBE_Build with type String in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ByteRange" testNumber="8"/>
			<description>Entry ByteRange in Signature shall have type Array</description>
			<test>containsByteRange == false || ByteRangeHasTypeArray == true</test>
			<error>
				<message>Entry ByteRange in Signature has type %1 instead of type Array</message>
				<arguments>
					<argument>ByteRangeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ByteRange-Array" testNumber="16"/>
			<description>If entry ByteRange with type Array in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ByteRangeHasTypeArray != true || (isByteRangeIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry ByteRange with type Array in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ByteRange-Array" testNumber="9"/>
			<description>Entry ByteRange with type Array in Signature shall satisfy special case: fn:Eval((fn:ArrayLength(ByteRange) mod 2) == 0)</description>
			<test>ByteRangeHasTypeArray != true || ((ByteRangeArraySize % 2) == 0)</test>
			<error>
				<message>Entry ByteRange with type Array in Signature does not satisfy special case: fn:Eval((fn:ArrayLength(ByteRange) mod 2) == 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Cert" testNumber="8"/>
			<description>Entry Cert in Signature shall have one of types: Array, StringByte</description>
			<test>containsCert == false || CertHasTypeArray == true || CertHasTypeStringByte == true</test>
			<error>
				<message>Entry Cert in Signature has type %1 instead of one of types: Array, StringByte</message>
				<arguments>
					<argument>CertType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Cert" testNumber="11"/>
			<description>Entry Cert in Signature is required, when @SubFilter == adbe.x509.rsa_sha1</description>
			<test>containsCert == true || (SubFilterNameValue != "adbe.x509.rsa_sha1")</test>
			<error>
				<message>Entry Cert in Signature is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Cert-Array" testNumber="16"/>
			<description>If entry Cert with type Array in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>CertHasTypeArray != true || (isCertIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Cert with type Array in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Cert-StringByte" testNumber="16"/>
			<description>If entry Cert with type StringByte in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>CertHasTypeStringByte != true || (isCertIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Cert with type StringByte in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Changes" testNumber="8"/>
			<description>Entry Changes in Signature shall have type Array</description>
			<test>containsChanges == false || ChangesHasTypeArray == true</test>
			<error>
				<message>Entry Changes in Signature has type %1 instead of type Array</message>
				<arguments>
					<argument>ChangesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Changes-Array" testNumber="16"/>
			<description>If entry Changes with type Array in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ChangesHasTypeArray != true || (isChangesIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Changes with type Array in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ContactInfo" testNumber="8"/>
			<description>Entry ContactInfo in Signature shall have type StringText</description>
			<test>containsContactInfo == false || ContactInfoHasTypeStringText == true</test>
			<error>
				<message>Entry ContactInfo in Signature has type %1 instead of type StringText</message>
				<arguments>
					<argument>ContactInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-ContactInfo-StringText" testNumber="16"/>
			<description>If entry ContactInfo with type StringText in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ContactInfoHasTypeStringText != true || (isContactInfoIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry ContactInfo with type StringText in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Contents" testNumber="8"/>
			<description>Entry Contents in Signature shall have type StringByte</description>
			<test>containsContents == false || ContentsHasTypeStringByte == true</test>
			<error>
				<message>Entry Contents in Signature has type %1 instead of type StringByte</message>
				<arguments>
					<argument>ContentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Contents" testNumber="7"/>
			<description>Entry Contents in Signature is required</description>
			<test>containsContents == true</test>
			<error>
				<message>Entry Contents in Signature is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Contents-StringByte" testNumber="16"/>
			<description>If entry Contents with type StringByte in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ContentsHasTypeStringByte != true || (isContentsIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Contents with type StringByte in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Contents-StringByte" testNumber="9"/>
			<description>Entry Contents with type StringByte in Signature shall satisfy special case: fn:Eval((fn:IsPresent(ByteRange) &amp;&amp; fn:IsHexString()) &amp;&amp; fn:AlwaysUnencrypted())</description>
			<test>ContentsHasTypeStringByte != true || ((containsByteRange == true) &amp;&amp; isContentsHexString == true)</test>
			<error>
				<message>Entry Contents with type StringByte in Signature does not satisfy special case: fn:Eval((fn:IsPresent(ByteRange) &amp;&amp; fn:IsHexString()) &amp;&amp; fn:AlwaysUnencrypted())</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Filter" testNumber="8"/>
			<description>Entry Filter in Signature shall have type Name</description>
			<test>containsFilter == false || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in Signature has type %1 instead of type Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Filter" testNumber="7"/>
			<description>Entry Filter in Signature is required</description>
			<test>containsFilter == true</test>
			<error>
				<message>Entry Filter in Signature is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Filter-Name" testNumber="16"/>
			<description>If entry Filter with type Name in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>FilterHasTypeName != true || (isFilterIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Filter with type Name in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Location" testNumber="8"/>
			<description>Entry Location in Signature shall have type StringText</description>
			<test>containsLocation == false || LocationHasTypeStringText == true</test>
			<error>
				<message>Entry Location in Signature has type %1 instead of type StringText</message>
				<arguments>
					<argument>LocationType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Location-StringText" testNumber="16"/>
			<description>If entry Location with type StringText in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>LocationHasTypeStringText != true || (isLocationIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Location with type StringText in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-M" testNumber="8"/>
			<description>Entry M in Signature shall have type Date</description>
			<test>containsM == false || MHasTypeDate == true</test>
			<error>
				<message>Entry M in Signature has type %1 instead of type Date</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-M-Date" testNumber="16"/>
			<description>If entry M with type Date in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>MHasTypeDate != true || (isMIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry M with type Date in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Name" testNumber="8"/>
			<description>Entry Name in Signature shall have type StringText</description>
			<test>containsName == false || NameHasTypeStringText == true</test>
			<error>
				<message>Entry Name in Signature has type %1 instead of type StringText</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Name-StringText" testNumber="16"/>
			<description>If entry Name with type StringText in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>NameHasTypeStringText != true || (isNameIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Name with type StringText in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-R" testNumber="8"/>
			<description>Entry R in Signature shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in Signature has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-R-Integer" testNumber="16"/>
			<description>If entry R with type Integer in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>RHasTypeInteger != true || (isRIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry R with type Integer in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Reason" testNumber="8"/>
			<description>Entry Reason in Signature shall have type StringText</description>
			<test>containsReason == false || ReasonHasTypeStringText == true</test>
			<error>
				<message>Entry Reason in Signature has type %1 instead of type StringText</message>
				<arguments>
					<argument>ReasonType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Reason-StringText" testNumber="16"/>
			<description>If entry Reason with type StringText in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>ReasonHasTypeStringText != true || (isReasonIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Reason with type StringText in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-SubFilter" testNumber="8"/>
			<description>Entry SubFilter in Signature shall have type Name</description>
			<test>containsSubFilter == false || SubFilterHasTypeName == true</test>
			<error>
				<message>Entry SubFilter in Signature has type %1 instead of type Name</message>
				<arguments>
					<argument>SubFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-SubFilter-Name" testNumber="16"/>
			<description>If entry SubFilter with type Name in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>SubFilterHasTypeName != true || (isSubFilterIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry SubFilter with type Name in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-SubFilter-Name-ETSI.CAdES.detached" testNumber="27"/>
			<description>Entry SubFilter with type Name in Signature should not have value ETSI.CAdES.detached, if extension ETSI_PAdES does not chosen</description>
			<test>(hasExtensionETSI_PAdES == true) || SubFilterNameValue != "ETSI.CAdES.detached"</test>
			<error>
				<message>Entry SubFilter with type Name in Signature has value ETSI.CAdES.detached</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-SubFilter-Name" testNumber="6"/>
			<description>Entry SubFilter with type Name in Signature shall have one of values: adbe.pkcs7.detached, adbe.x509.rsa_sha1, adbe.pkcs7.sha1, ETSI.CAdES.detached</description>
			<test>SubFilterHasTypeName != true || SubFilterNameValue == "adbe.pkcs7.detached" || SubFilterNameValue == "adbe.pkcs7.sha1" || SubFilterNameValue == "adbe.x509.rsa_sha1" || SubFilterNameValue == "ETSI.CAdES.detached"</test>
			<error>
				<message>Entry SubFilter with type Name in Signature has incorrect value %1 instead of adbe.pkcs7.detached, adbe.x509.rsa_sha1, adbe.pkcs7.sha1, ETSI.CAdES.detached</message>
				<arguments>
					<argument>SubFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Type" testNumber="8"/>
			<description>Entry Type in Signature shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Signature has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Type-Name" testNumber="16"/>
			<description>If entry Type with type Name in Signature satisfies condition fn:IsPresent(ByteRange), it shall be direct</description>
			<test>TypeHasTypeName != true || (isTypeIndirect == false || (containsByteRange != true))</test>
			<error>
				<message>Entry Type with type Name in Signature is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASignature">
			<id specification="PDF_1_4" clause="Signature-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Signature shall have value Sig</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Sig"</test>
			<error>
				<message>Entry Type with type Name in Signature has incorrect value %1 instead of Sig</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow" testNumber="1"/>
			<description>SlideShow shall not contain entries except Resources, StartResource, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Resources' &amp;&amp; elem != 'StartResource' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SlideShow contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Resources' &amp;&amp; elem != 'StartResource' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Resources" testNumber="8"/>
			<description>Entry Resources in SlideShow shall have type NameTree</description>
			<test>containsResources == false || ResourcesHasTypeNameTree == true</test>
			<error>
				<message>Entry Resources in SlideShow has type %1 instead of type NameTree</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Resources" testNumber="7"/>
			<description>Entry Resources in SlideShow is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in SlideShow is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-ResourcesTreeNode" testNumber="8"/>
			<description>Entry ResourcesTreeNode in SlideShow shall have type NameTree</description>
			<test>containsResourcesTreeNode == false || ResourcesTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry ResourcesTreeNode in SlideShow has type %1 instead of type NameTree</message>
				<arguments>
					<argument>ResourcesTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-ResourcesTreeNode" testNumber="7"/>
			<description>Entry ResourcesTreeNode in SlideShow is required</description>
			<test>containsResourcesTreeNode == true</test>
			<error>
				<message>Entry ResourcesTreeNode in SlideShow is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-StartResource" testNumber="8"/>
			<description>Entry StartResource in SlideShow shall have type StringByte</description>
			<test>containsStartResource == false || StartResourceHasTypeStringByte == true</test>
			<error>
				<message>Entry StartResource in SlideShow has type %1 instead of type StringByte</message>
				<arguments>
					<argument>StartResourceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-StartResource" testNumber="7"/>
			<description>Entry StartResource in SlideShow is required</description>
			<test>containsStartResource == true</test>
			<error>
				<message>Entry StartResource in SlideShow is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-StartResource-StringByte" testNumber="9"/>
			<description>Entry StartResource with type StringByte in SlideShow shall satisfy special case: fn:IsNameTreeIndex(Resources, @StartResource)</description>
			<test>StartResourceHasTypeStringByte != true || (StartResourceIsNameTreeResourcesIndex == true)</test>
			<error>
				<message>Entry StartResource with type StringByte in SlideShow does not satisfy special case: fn:IsNameTreeIndex(Resources, @StartResource)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Subtype" testNumber="8"/>
			<description>Entry Subtype in SlideShow shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in SlideShow has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Subtype" testNumber="7"/>
			<description>Entry Subtype in SlideShow is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in SlideShow is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in SlideShow shall have value Embedded</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Embedded"</test>
			<error>
				<message>Entry Subtype with type Name in SlideShow has incorrect value %1 instead of Embedded</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Type" testNumber="8"/>
			<description>Entry Type in SlideShow shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in SlideShow has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Type" testNumber="7"/>
			<description>Entry Type in SlideShow is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in SlideShow is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShow">
			<id specification="PDF_1_4" clause="SlideShow-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in SlideShow shall have value SlideShow</description>
			<test>TypeHasTypeName != true || TypeNameValue == "SlideShow"</test>
			<error>
				<message>Entry Type with type Name in SlideShow has incorrect value %1 instead of SlideShow</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShowNameTreeResourcesEntry">
			<id specification="PDF_1_4" clause="SlideShowNameTreeResourcesEntry" testNumber="8"/>
			<description>Entry in SlideShowNameTreeResources shall have one of types: Dictionary, Stream</description>
			<test>HasTypeDictionary == true || HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in SlideShowNameTreeResources has type %1 instead of one of types: Dictionary, Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASlideShowNameTreeResourcesEntry">
			<id specification="PDF_1_4" clause="SlideShowNameTreeResourcesEntry" testNumber="8"/>
			<description>Entry in SlideShowNameTreeResources shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in SlideShowNameTreeResources has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha" testNumber="1"/>
			<description>SoftMaskAlpha shall not contain entries except BC, G, S, TR, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'G' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SoftMaskAlpha contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'G' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-BC" testNumber="8"/>
			<description>Entry BC in SoftMaskAlpha shall have type Array</description>
			<test>containsBC == false || BCHasTypeArray == true</test>
			<error>
				<message>Entry BC in SoftMaskAlpha has type %1 instead of type Array</message>
				<arguments>
					<argument>BCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-G" testNumber="8"/>
			<description>Entry G in SoftMaskAlpha shall have type Stream</description>
			<test>containsG == false || GHasTypeStream == true</test>
			<error>
				<message>Entry G in SoftMaskAlpha has type %1 instead of type Stream</message>
				<arguments>
					<argument>GType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-G" testNumber="7"/>
			<description>Entry G in SoftMaskAlpha is required</description>
			<test>containsG == true</test>
			<error>
				<message>Entry G in SoftMaskAlpha is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-G-Stream" testNumber="10"/>
			<description>Entry G with type Stream in SoftMaskAlpha shall be indirect</description>
			<test>GHasTypeStream != true || isGIndirect == true</test>
			<error>
				<message>Entry G with type Stream in SoftMaskAlpha is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-S" testNumber="8"/>
			<description>Entry S in SoftMaskAlpha shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in SoftMaskAlpha has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-S" testNumber="7"/>
			<description>Entry S in SoftMaskAlpha is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in SoftMaskAlpha is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-S-Name" testNumber="6"/>
			<description>Entry S with type Name in SoftMaskAlpha shall have value Alpha</description>
			<test>SHasTypeName != true || SNameValue == "Alpha"</test>
			<error>
				<message>Entry S with type Name in SoftMaskAlpha has incorrect value %1 instead of Alpha</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-TR-Dictionary" testNumber="17"/>
			<description>Entry TR with type Dictionary in SoftMaskAlpha shall be one of objects FunctionType2, FunctionType3</description>
			<test>TRHasTypeDictionary != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Dictionary in SoftMaskAlpha is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-TR-Stream" testNumber="17"/>
			<description>Entry TR with type Stream in SoftMaskAlpha shall be one of objects FunctionType0, FunctionType4</description>
			<test>TRHasTypeStream != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Stream in SoftMaskAlpha is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-TR" testNumber="8"/>
			<description>Entry TR in SoftMaskAlpha shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTR == false || TRHasTypeDictionary == true || TRHasTypeName == true || TRHasTypeStream == true</test>
			<error>
				<message>Entry TR in SoftMaskAlpha has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-TR-Name" testNumber="6"/>
			<description>Entry TR with type Name in SoftMaskAlpha shall have value Identity</description>
			<test>TRHasTypeName != true || TRNameValue == "Identity"</test>
			<error>
				<message>Entry TR with type Name in SoftMaskAlpha has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TRNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-TR-Stream" testNumber="10"/>
			<description>Entry TR with type Stream in SoftMaskAlpha shall be indirect</description>
			<test>TRHasTypeStream != true || isTRIndirect == true</test>
			<error>
				<message>Entry TR with type Stream in SoftMaskAlpha is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-Type" testNumber="8"/>
			<description>Entry Type in SoftMaskAlpha shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in SoftMaskAlpha has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskAlpha">
			<id specification="PDF_1_4" clause="SoftMaskAlpha-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in SoftMaskAlpha shall have value Mask</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Mask"</test>
			<error>
				<message>Entry Type with type Name in SoftMaskAlpha has incorrect value %1 instead of Mask</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity" testNumber="1"/>
			<description>SoftMaskLuminosity shall not contain entries except BC, G, S, TR, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'G' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SoftMaskLuminosity contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BC' &amp;&amp; elem != 'G' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TR' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-BC" testNumber="8"/>
			<description>Entry BC in SoftMaskLuminosity shall have type Array</description>
			<test>containsBC == false || BCHasTypeArray == true</test>
			<error>
				<message>Entry BC in SoftMaskLuminosity has type %1 instead of type Array</message>
				<arguments>
					<argument>BCType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-G" testNumber="8"/>
			<description>Entry G in SoftMaskLuminosity shall have type Stream</description>
			<test>containsG == false || GHasTypeStream == true</test>
			<error>
				<message>Entry G in SoftMaskLuminosity has type %1 instead of type Stream</message>
				<arguments>
					<argument>GType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-G" testNumber="7"/>
			<description>Entry G in SoftMaskLuminosity is required</description>
			<test>containsG == true</test>
			<error>
				<message>Entry G in SoftMaskLuminosity is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-G-Stream" testNumber="10"/>
			<description>Entry G with type Stream in SoftMaskLuminosity shall be indirect</description>
			<test>GHasTypeStream != true || isGIndirect == true</test>
			<error>
				<message>Entry G with type Stream in SoftMaskLuminosity is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-G-Stream" testNumber="9"/>
			<description>Entry G with type Stream in SoftMaskLuminosity shall satisfy special case: fn:Eval((G::Group::@S == Transparency) &amp;&amp; fn:IsPresent(G::Group::CS))</description>
			<test>GHasTypeStream != true || ((GGroupSNameValue == "Transparency") &amp;&amp; (containsGGroupCS == true))</test>
			<error>
				<message>Entry G with type Stream in SoftMaskLuminosity does not satisfy special case: fn:Eval((G::Group::@S == Transparency) &amp;&amp; fn:IsPresent(G::Group::CS))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-S" testNumber="8"/>
			<description>Entry S in SoftMaskLuminosity shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in SoftMaskLuminosity has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-S" testNumber="7"/>
			<description>Entry S in SoftMaskLuminosity is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in SoftMaskLuminosity is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-S-Name" testNumber="6"/>
			<description>Entry S with type Name in SoftMaskLuminosity shall have value Luminosity</description>
			<test>SHasTypeName != true || SNameValue == "Luminosity"</test>
			<error>
				<message>Entry S with type Name in SoftMaskLuminosity has incorrect value %1 instead of Luminosity</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-TR-Dictionary" testNumber="17"/>
			<description>Entry TR with type Dictionary in SoftMaskLuminosity shall be one of objects FunctionType2, FunctionType3</description>
			<test>TRHasTypeDictionary != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Dictionary in SoftMaskLuminosity is not one of objects FunctionType2, FunctionType3</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-TR-Stream" testNumber="17"/>
			<description>Entry TR with type Stream in SoftMaskLuminosity shall be one of objects FunctionType0, FunctionType4</description>
			<test>TRHasTypeStream != true || TR_size == 1</test>
			<error>
				<message>Entry TR with type Stream in SoftMaskLuminosity is not one of objects FunctionType0, FunctionType4</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-TR" testNumber="8"/>
			<description>Entry TR in SoftMaskLuminosity shall have one of types: Dictionary, Name, Stream</description>
			<test>containsTR == false || TRHasTypeDictionary == true || TRHasTypeName == true || TRHasTypeStream == true</test>
			<error>
				<message>Entry TR in SoftMaskLuminosity has type %1 instead of one of types: Dictionary, Name, Stream</message>
				<arguments>
					<argument>TRType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-TR-Name" testNumber="6"/>
			<description>Entry TR with type Name in SoftMaskLuminosity shall have value Identity</description>
			<test>TRHasTypeName != true || TRNameValue == "Identity"</test>
			<error>
				<message>Entry TR with type Name in SoftMaskLuminosity has incorrect value %1 instead of Identity</message>
				<arguments>
					<argument>TRNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-TR-Stream" testNumber="10"/>
			<description>Entry TR with type Stream in SoftMaskLuminosity shall be indirect</description>
			<test>TRHasTypeStream != true || isTRIndirect == true</test>
			<error>
				<message>Entry TR with type Stream in SoftMaskLuminosity is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-Type" testNumber="8"/>
			<description>Entry Type in SoftMaskLuminosity shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in SoftMaskLuminosity has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoftMaskLuminosity">
			<id specification="PDF_1_4" clause="SoftMaskLuminosity-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in SoftMaskLuminosity shall have value Mask</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Mask"</test>
			<error>
				<message>Entry Type with type Name in SoftMaskLuminosity has incorrect value %1 instead of Mask</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject" testNumber="1"/>
			<description>SoundObject shall not contain entries except B, C, CO, CP, DecodeParms, E, F, FDecodeParms, FFilter, Filter, Length, R, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SoundObject contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'C' &amp;&amp; elem != 'CO' &amp;&amp; elem != 'CP' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'E' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject" testNumber="22"/>
			<description>SoundObject shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>SoundObject contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-B" testNumber="8"/>
			<description>Entry B in SoundObject shall have type Integer</description>
			<test>containsB == false || BHasTypeInteger == true</test>
			<error>
				<message>Entry B in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>BType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-B-Integer" testNumber="14"/>
			<description>Entry B with type Integer in SoundObject shall satisfy possible value predicate: fn:Eval(@B &gt; 0)</description>
			<test>BHasTypeInteger != true || BIntegerValue &gt; 0</test>
			<error>
				<message>Entry B with type Integer in SoundObject does not satisfy possible value predicate: fn:Eval(@B &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-C" testNumber="8"/>
			<description>Entry C in SoundObject shall have type Integer</description>
			<test>containsC == false || CHasTypeInteger == true</test>
			<error>
				<message>Entry C in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-C-Integer" testNumber="14"/>
			<description>Entry C with type Integer in SoundObject shall satisfy possible value predicate: fn:Eval(@C &gt; 0)</description>
			<test>CHasTypeInteger != true || CIntegerValue &gt; 0</test>
			<error>
				<message>Entry C with type Integer in SoundObject does not satisfy possible value predicate: fn:Eval(@C &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-CO" testNumber="8"/>
			<description>Entry CO in SoundObject shall have type Name</description>
			<test>containsCO == false || COHasTypeName == true</test>
			<error>
				<message>Entry CO in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>COType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-CP" testNumber="8"/>
			<description>Entry CP in SoundObject shall have one of types: Array, Dictionary, Stream</description>
			<test>containsCP == false || CPHasTypeArray == true || CPHasTypeDictionary == true || CPHasTypeStream == true</test>
			<error>
				<message>Entry CP in SoundObject has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>CPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-CP-Stream" testNumber="10"/>
			<description>Entry CP with type Stream in SoundObject shall be indirect</description>
			<test>CPHasTypeStream != true || isCPIndirect == true</test>
			<error>
				<message>Entry CP with type Stream in SoundObject is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in SoundObject shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in SoundObject is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in SoundObject shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in SoundObject has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-E" testNumber="8"/>
			<description>Entry E in SoundObject shall have type Name</description>
			<test>containsE == false || EHasTypeName == true</test>
			<error>
				<message>Entry E in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-E-Name" testNumber="6"/>
			<description>Entry E with type Name in SoundObject shall have one of values: Signed, Raw, muLaw, ALaw</description>
			<test>EHasTypeName != true || ENameValue == "Raw" || ENameValue == "Signed" || ENameValue == "muLaw" || ENameValue == "ALaw"</test>
			<error>
				<message>Entry E with type Name in SoundObject has incorrect value %1 instead of Signed, Raw, muLaw, ALaw</message>
				<arguments>
					<argument>ENameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-F" testNumber="8"/>
			<description>Entry F in SoundObject shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in SoundObject has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in SoundObject shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in SoundObject is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in SoundObject shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in SoundObject has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FFilter" testNumber="8"/>
			<description>Entry FFilter in SoundObject shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in SoundObject has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in SoundObject shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in SoundObject has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Filter" testNumber="8"/>
			<description>Entry Filter in SoundObject shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in SoundObject has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in SoundObject shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in SoundObject does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in SoundObject shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in SoundObject has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Length" testNumber="8"/>
			<description>Entry Length in SoundObject shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in SoundObject has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Length" testNumber="7"/>
			<description>Entry Length in SoundObject is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in SoundObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-R" testNumber="8"/>
			<description>Entry R in SoundObject shall have type Number</description>
			<test>containsR == false || RHasTypeNumber == true</test>
			<error>
				<message>Entry R in SoundObject has type %1 instead of type Number</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-R" testNumber="7"/>
			<description>Entry R in SoundObject is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in SoundObject is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-R-Number" testNumber="14"/>
			<description>Entry R with type Number in SoundObject shall satisfy possible value predicate: fn:Eval(@R &gt; 0)</description>
			<test>RHasTypeNumber != true || RNumberValue &gt; 0</test>
			<error>
				<message>Entry R with type Number in SoundObject does not satisfy possible value predicate: fn:Eval(@R &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Type" testNumber="8"/>
			<description>Entry Type in SoundObject shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in SoundObject has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASoundObject">
			<id specification="PDF_1_4" clause="SoundObject-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in SoundObject shall have value Sound</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Sound"</test>
			<error>
				<message>Entry Type with type Name in SoundObject has incorrect value %1 instead of Sound</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation" testNumber="1"/>
			<description>SourceInformation shall not contain entries except AU, C, E, S, TS</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TS' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>SourceInformation contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AU' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'S' &amp;&amp; elem != 'TS' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-AU" testNumber="8"/>
			<description>Entry AU in SourceInformation shall have one of types: Dictionary, StringAscii</description>
			<test>containsAU == false || AUHasTypeDictionary == true || AUHasTypeStringAscii == true</test>
			<error>
				<message>Entry AU in SourceInformation has type %1 instead of one of types: Dictionary, StringAscii</message>
				<arguments>
					<argument>AUType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-AU" testNumber="7"/>
			<description>Entry AU in SourceInformation is required</description>
			<test>containsAU == true</test>
			<error>
				<message>Entry AU in SourceInformation is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-C" testNumber="8"/>
			<description>Entry C in SourceInformation shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in SourceInformation has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-C-Dictionary" testNumber="10"/>
			<description>Entry C with type Dictionary in SourceInformation shall be indirect</description>
			<test>CHasTypeDictionary != true || isCIndirect == true</test>
			<error>
				<message>Entry C with type Dictionary in SourceInformation is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-C-Dictionary" testNumber="9"/>
			<description>Entry C with type Dictionary in SourceInformation shall satisfy special case: fn:Eval(parent::@S == SPS)</description>
			<test>CHasTypeDictionary != true || (parentSNameValue == "SPS")</test>
			<error>
				<message>Entry C with type Dictionary in SourceInformation does not satisfy special case: fn:Eval(parent::@S == SPS)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-E" testNumber="8"/>
			<description>Entry E in SourceInformation shall have type Date</description>
			<test>containsE == false || EHasTypeDate == true</test>
			<error>
				<message>Entry E in SourceInformation has type %1 instead of type Date</message>
				<arguments>
					<argument>EType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-S" testNumber="8"/>
			<description>Entry S in SourceInformation shall have type Integer</description>
			<test>containsS == false || SHasTypeInteger == true</test>
			<error>
				<message>Entry S in SourceInformation has type %1 instead of type Integer</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-S-Integer" testNumber="6"/>
			<description>Entry S with type Integer in SourceInformation shall have one of values: 0, 1, 2</description>
			<test>SHasTypeInteger != true || SIntegerValue == 0 || SIntegerValue == 1 || SIntegerValue == 2</test>
			<error>
				<message>Entry S with type Integer in SourceInformation has incorrect value %1 instead of 0, 1, 2</message>
				<arguments>
					<argument>SIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-S-Integer" testNumber="9"/>
			<description>Entry S with type Integer in SourceInformation shall satisfy special case: fn:Eval(parent::@S == SPS)</description>
			<test>SHasTypeInteger != true || (parentSNameValue == "SPS")</test>
			<error>
				<message>Entry S with type Integer in SourceInformation does not satisfy special case: fn:Eval(parent::@S == SPS)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ASourceInformation">
			<id specification="PDF_1_4" clause="SourceInformation-TS" testNumber="8"/>
			<description>Entry TS in SourceInformation shall have type Date</description>
			<test>containsTS == false || TSHasTypeDate == true</test>
			<error>
				<message>Entry TS in SourceInformation has type %1 instead of type Date</message>
				<arguments>
					<argument>TSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in Stream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in Stream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in Stream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in Stream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-F" testNumber="8"/>
			<description>Entry F in Stream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Stream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in Stream shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in Stream is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in Stream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in Stream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FFilter" testNumber="8"/>
			<description>Entry FFilter in Stream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in Stream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in Stream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in Stream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-Filter" testNumber="8"/>
			<description>Entry Filter in Stream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in Stream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in Stream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in Stream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in Stream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in Stream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-Length" testNumber="8"/>
			<description>Entry Length in Stream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in Stream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStream">
			<id specification="PDF_1_4" clause="Stream-Length" testNumber="7"/>
			<description>Entry Length in Stream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in Stream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem" testNumber="1"/>
			<description>StructElem shall not contain entries except A, ActualText, Alt, C, ID, K, Lang, P, Pg, R, S, T, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'ActualText' &amp;&amp; elem != 'Alt' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'NS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Phoneme' &amp;&amp; elem != 'PhoneticAlphabet' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>StructElem contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'A' &amp;&amp; elem != 'AF' &amp;&amp; elem != 'ActualText' &amp;&amp; elem != 'Alt' &amp;&amp; elem != 'C' &amp;&amp; elem != 'E' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Lang' &amp;&amp; elem != 'NS' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Pg' &amp;&amp; elem != 'Phoneme' &amp;&amp; elem != 'PhoneticAlphabet' &amp;&amp; elem != 'R' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'S' &amp;&amp; elem != 'T' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem" testNumber="22"/>
			<description>StructElem shall not contain entries AF, E, NS, Phoneme, PhoneticAlphabet, Ref in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'E' || elem == 'NS' || elem == 'Phoneme' || elem == 'PhoneticAlphabet' || elem == 'Ref').length == 0</test>
			<error>
				<message>StructElem contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'E' || elem == 'NS' || elem == 'Phoneme' || elem == 'PhoneticAlphabet' || elem == 'Ref').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-A" testNumber="8"/>
			<description>Entry A in StructElem shall have one of types: Array, Dictionary, Stream</description>
			<test>containsA == false || AHasTypeArray == true || AHasTypeDictionary == true || AHasTypeStream == true</test>
			<error>
				<message>Entry A in StructElem has type %1 instead of one of types: Array, Dictionary, Stream</message>
				<arguments>
					<argument>AType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-A-Array" testNumber="14"/>
			<description>Entry A with type Array in StructElem shall satisfy possible value predicate: fn:Eval(fn:ArrayLength(A) &gt;= 1)</description>
			<test>AHasTypeArray != true || AArraySize &gt;= 1</test>
			<error>
				<message>Entry A with type Array in StructElem does not satisfy possible value predicate: fn:Eval(fn:ArrayLength(A) &gt;= 1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-A-Stream" testNumber="10"/>
			<description>Entry A with type Stream in StructElem shall be indirect</description>
			<test>AHasTypeStream != true || isAIndirect == true</test>
			<error>
				<message>Entry A with type Stream in StructElem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-ActualText" testNumber="8"/>
			<description>Entry ActualText in StructElem shall have type StringText</description>
			<test>containsActualText == false || ActualTextHasTypeStringText == true</test>
			<error>
				<message>Entry ActualText in StructElem has type %1 instead of type StringText</message>
				<arguments>
					<argument>ActualTextType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Alt" testNumber="8"/>
			<description>Entry Alt in StructElem shall have type StringText</description>
			<test>containsAlt == false || AltHasTypeStringText == true</test>
			<error>
				<message>Entry Alt in StructElem has type %1 instead of type StringText</message>
				<arguments>
					<argument>AltType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-C" testNumber="8"/>
			<description>Entry C in StructElem shall have one of types: Array, Name</description>
			<test>containsC == false || CHasTypeArray == true || CHasTypeName == true</test>
			<error>
				<message>Entry C in StructElem has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-ID" testNumber="8"/>
			<description>Entry ID in StructElem shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in StructElem has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-K-Dictionary" testNumber="17"/>
			<description>Entry K with type Dictionary in StructElem shall be one of objects StructElem, MarkedContentReference, ObjectReference</description>
			<test>KHasTypeDictionary != true || K_size == 1</test>
			<error>
				<message>Entry K with type Dictionary in StructElem is not one of objects StructElem, MarkedContentReference, ObjectReference</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-K" testNumber="8"/>
			<description>Entry K in StructElem shall have one of types: Array, Dictionary, Integer</description>
			<test>containsK == false || KHasTypeArray == true || KHasTypeDictionary == true || KHasTypeInteger == true</test>
			<error>
				<message>Entry K in StructElem has type %1 instead of one of types: Array, Dictionary, Integer</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Lang" testNumber="8"/>
			<description>Entry Lang in StructElem shall have type StringText</description>
			<test>containsLang == false || LangHasTypeStringText == true</test>
			<error>
				<message>Entry Lang in StructElem has type %1 instead of type StringText</message>
				<arguments>
					<argument>LangType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-P-Dictionary" testNumber="17"/>
			<description>Entry P with type Dictionary in StructElem shall be one of objects StructElem, StructTreeRoot</description>
			<test>PHasTypeDictionary != true || P_size == 1</test>
			<error>
				<message>Entry P with type Dictionary in StructElem is not one of objects StructElem, StructTreeRoot</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-P" testNumber="8"/>
			<description>Entry P in StructElem shall have type Dictionary</description>
			<test>containsP == false || PHasTypeDictionary == true</test>
			<error>
				<message>Entry P in StructElem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-P" testNumber="7"/>
			<description>Entry P in StructElem is required</description>
			<test>containsP == true</test>
			<error>
				<message>Entry P in StructElem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-P-Dictionary" testNumber="10"/>
			<description>Entry P with type Dictionary in StructElem shall be indirect</description>
			<test>PHasTypeDictionary != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Dictionary in StructElem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Pg" testNumber="8"/>
			<description>Entry Pg in StructElem shall have type Dictionary</description>
			<test>containsPg == false || PgHasTypeDictionary == true</test>
			<error>
				<message>Entry Pg in StructElem has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PgType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Pg-Dictionary" testNumber="10"/>
			<description>Entry Pg with type Dictionary in StructElem shall be indirect</description>
			<test>PgHasTypeDictionary != true || isPgIndirect == true</test>
			<error>
				<message>Entry Pg with type Dictionary in StructElem is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-R" testNumber="8"/>
			<description>Entry R in StructElem shall have type Integer</description>
			<test>containsR == false || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in StructElem has type %1 instead of type Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-R-Integer" testNumber="14"/>
			<description>Entry R with type Integer in StructElem shall satisfy possible value predicate: fn:Eval(@R &gt;= 0)</description>
			<test>RHasTypeInteger != true || RIntegerValue &gt;= 0</test>
			<error>
				<message>Entry R with type Integer in StructElem does not satisfy possible value predicate: fn:Eval(@R &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-S" testNumber="8"/>
			<description>Entry S in StructElem shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in StructElem has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-S" testNumber="7"/>
			<description>Entry S in StructElem is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in StructElem is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-T" testNumber="8"/>
			<description>Entry T in StructElem shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in StructElem has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Type" testNumber="8"/>
			<description>Entry Type in StructElem shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in StructElem has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructElem">
			<id specification="PDF_1_4" clause="StructElem-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in StructElem shall have value StructElem</description>
			<test>TypeHasTypeName != true || TypeNameValue == "StructElem"</test>
			<error>
				<message>Entry Type with type Name in StructElem has incorrect value %1 instead of StructElem</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot" testNumber="1"/>
			<description>StructTreeRoot shall not contain entries except ClassMap, IDTree, K, ParentTree, ParentTreeNextKey, RoleMap, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'ClassMap' &amp;&amp; elem != 'IDTree' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Namespaces' &amp;&amp; elem != 'ParentTree' &amp;&amp; elem != 'ParentTreeNextKey' &amp;&amp; elem != 'PronunciationLexicon' &amp;&amp; elem != 'RoleMap' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>StructTreeRoot contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'ClassMap' &amp;&amp; elem != 'IDTree' &amp;&amp; elem != 'K' &amp;&amp; elem != 'Namespaces' &amp;&amp; elem != 'ParentTree' &amp;&amp; elem != 'ParentTreeNextKey' &amp;&amp; elem != 'PronunciationLexicon' &amp;&amp; elem != 'RoleMap' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot" testNumber="22"/>
			<description>StructTreeRoot shall not contain entries AF, Namespaces, PronunciationLexicon in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Namespaces' || elem == 'PronunciationLexicon').length == 0</test>
			<error>
				<message>StructTreeRoot contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'Namespaces' || elem == 'PronunciationLexicon').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-ClassMap" testNumber="8"/>
			<description>Entry ClassMap in StructTreeRoot shall have type Dictionary</description>
			<test>containsClassMap == false || ClassMapHasTypeDictionary == true</test>
			<error>
				<message>Entry ClassMap in StructTreeRoot has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ClassMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-IDTree" testNumber="8"/>
			<description>Entry IDTree in StructTreeRoot shall have type NameTree</description>
			<test>containsIDTree == false || IDTreeHasTypeNameTree == true</test>
			<error>
				<message>Entry IDTree in StructTreeRoot has type %1 instead of type NameTree</message>
				<arguments>
					<argument>IDTreeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-IDTreeTreeNode" testNumber="8"/>
			<description>Entry IDTreeTreeNode in StructTreeRoot shall have type NameTree</description>
			<test>containsIDTreeTreeNode == false || IDTreeTreeNodeHasTypeNameTree == true</test>
			<error>
				<message>Entry IDTreeTreeNode in StructTreeRoot has type %1 instead of type NameTree</message>
				<arguments>
					<argument>IDTreeTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-K" testNumber="8"/>
			<description>Entry K in StructTreeRoot shall have one of types: Array, Dictionary</description>
			<test>containsK == false || KHasTypeArray == true || KHasTypeDictionary == true</test>
			<error>
				<message>Entry K in StructTreeRoot has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>KType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-ParentTree" testNumber="8"/>
			<description>Entry ParentTree in StructTreeRoot shall have type NumberTree</description>
			<test>containsParentTree == false || ParentTreeHasTypeNumberTree == true</test>
			<error>
				<message>Entry ParentTree in StructTreeRoot has type %1 instead of type NumberTree</message>
				<arguments>
					<argument>ParentTreeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-ParentTreeNextKey" testNumber="8"/>
			<description>Entry ParentTreeNextKey in StructTreeRoot shall have type Integer</description>
			<test>containsParentTreeNextKey == false || ParentTreeNextKeyHasTypeInteger == true</test>
			<error>
				<message>Entry ParentTreeNextKey in StructTreeRoot has type %1 instead of type Integer</message>
				<arguments>
					<argument>ParentTreeNextKeyType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-ParentTreeTreeNode" testNumber="8"/>
			<description>Entry ParentTreeTreeNode in StructTreeRoot shall have type NumberTree</description>
			<test>containsParentTreeTreeNode == false || ParentTreeTreeNodeHasTypeNumberTree == true</test>
			<error>
				<message>Entry ParentTreeTreeNode in StructTreeRoot has type %1 instead of type NumberTree</message>
				<arguments>
					<argument>ParentTreeTreeNodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-RoleMap" testNumber="8"/>
			<description>Entry RoleMap in StructTreeRoot shall have type Dictionary</description>
			<test>containsRoleMap == false || RoleMapHasTypeDictionary == true</test>
			<error>
				<message>Entry RoleMap in StructTreeRoot has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RoleMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-Type" testNumber="8"/>
			<description>Entry Type in StructTreeRoot shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in StructTreeRoot has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-Type" testNumber="7"/>
			<description>Entry Type in StructTreeRoot is required</description>
			<test>containsType == true</test>
			<error>
				<message>Entry Type in StructTreeRoot is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRoot">
			<id specification="PDF_1_4" clause="StructTreeRoot-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in StructTreeRoot shall have value StructTreeRoot</description>
			<test>TypeHasTypeName != true || TypeNameValue == "StructTreeRoot"</test>
			<error>
				<message>Entry Type with type Name in StructTreeRoot has incorrect value %1 instead of StructTreeRoot</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRootNameTreeIDTreeEntry">
			<id specification="PDF_1_4" clause="StructTreeRootNameTreeIDTreeEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in StructTreeRootNameTreeIDTree shall be one of objects StructElem, MarkedContentReference, ObjectReference</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in StructTreeRootNameTreeIDTree is not one of objects StructElem, MarkedContentReference, ObjectReference</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRootNameTreeIDTreeEntry">
			<id specification="PDF_1_4" clause="StructTreeRootNameTreeIDTreeEntry" testNumber="8"/>
			<description>Entry in StructTreeRootNameTreeIDTree shall have type Dictionary</description>
			<test>HasTypeDictionary == true</test>
			<error>
				<message>Entry %keyName% in StructTreeRootNameTreeIDTree has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRootNumberTreeParentTreeEntry">
			<id specification="PDF_1_4" clause="StructTreeRootNumberTreeParentTreeEntry-Dictionary" testNumber="17"/>
			<description>Entry with type Dictionary in StructTreeRootNumberTreeParentTree shall be one of objects StructElem, MarkedContentReference, ObjectReference</description>
			<test>HasTypeDictionary != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Dictionary in StructTreeRootNumberTreeParentTree is not one of objects StructElem, MarkedContentReference, ObjectReference</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructTreeRootNumberTreeParentTreeEntry">
			<id specification="PDF_1_4" clause="StructTreeRootNumberTreeParentTreeEntry" testNumber="8"/>
			<description>Entry in StructTreeRootNumberTreeParentTree shall have one of types: Array, Dictionary, Null</description>
			<test>HasTypeArray == true || HasTypeDictionary == true || HasTypeNull == true</test>
			<error>
				<message>Entry %keyName% in StructTreeRootNumberTreeParentTree has type %1 instead of one of types: Array, Dictionary, Null</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict" testNumber="1"/>
			<description>StructureAttributesDict shall not contain entries except BBox, BaselineShift, BlockAlign, ColSpan, EndIndent, Headers, Height, InlineAlign, LineHeight, ListNumbering, O, Placement, RowSpan, SpaceAfter, SpaceBefore, StartIndent, TextAlign, TextDecorationType, TextIndent, Width, WritingMode</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'BackgroundColor' &amp;&amp; elem != 'BaselineShift' &amp;&amp; elem != 'BlockAlign' &amp;&amp; elem != 'BorderColor' &amp;&amp; elem != 'BorderStyle' &amp;&amp; elem != 'BorderThickness' &amp;&amp; elem != 'Checked' &amp;&amp; elem != 'ColSpan' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'ColumnCount' &amp;&amp; elem != 'ColumnGap' &amp;&amp; elem != 'ColumnWidths' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'ContinuedForm' &amp;&amp; elem != 'ContinuedList' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'EndIndent' &amp;&amp; elem != 'GlyphOrientationVertical' &amp;&amp; elem != 'Headers' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'InlineAlign' &amp;&amp; elem != 'LineHeight' &amp;&amp; elem != 'ListNumbering' &amp;&amp; elem != 'NS' &amp;&amp; elem != 'NoteType' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Padding' &amp;&amp; elem != 'Placement' &amp;&amp; elem != 'Role' &amp;&amp; elem != 'RowSpan' &amp;&amp; elem != 'RubyAlign' &amp;&amp; elem != 'RubyPosition' &amp;&amp; elem != 'Scope' &amp;&amp; elem != 'Short' &amp;&amp; elem != 'SpaceAfter' &amp;&amp; elem != 'SpaceBefore' &amp;&amp; elem != 'StartIndent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Summary' &amp;&amp; elem != 'TBorderStyle' &amp;&amp; elem != 'TPadding' &amp;&amp; elem != 'TextAlign' &amp;&amp; elem != 'TextDecorationColor' &amp;&amp; elem != 'TextDecorationThickness' &amp;&amp; elem != 'TextDecorationType' &amp;&amp; elem != 'TextIndent' &amp;&amp; elem != 'TextPosition' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'WritingMode' &amp;&amp; elem != 'checked' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>StructureAttributesDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'BackgroundColor' &amp;&amp; elem != 'BaselineShift' &amp;&amp; elem != 'BlockAlign' &amp;&amp; elem != 'BorderColor' &amp;&amp; elem != 'BorderStyle' &amp;&amp; elem != 'BorderThickness' &amp;&amp; elem != 'Checked' &amp;&amp; elem != 'ColSpan' &amp;&amp; elem != 'Color' &amp;&amp; elem != 'ColumnCount' &amp;&amp; elem != 'ColumnGap' &amp;&amp; elem != 'ColumnWidths' &amp;&amp; elem != 'Contents' &amp;&amp; elem != 'ContinuedForm' &amp;&amp; elem != 'ContinuedList' &amp;&amp; elem != 'Desc' &amp;&amp; elem != 'EndIndent' &amp;&amp; elem != 'GlyphOrientationVertical' &amp;&amp; elem != 'Headers' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'InlineAlign' &amp;&amp; elem != 'LineHeight' &amp;&amp; elem != 'ListNumbering' &amp;&amp; elem != 'NS' &amp;&amp; elem != 'NoteType' &amp;&amp; elem != 'O' &amp;&amp; elem != 'P' &amp;&amp; elem != 'Padding' &amp;&amp; elem != 'Placement' &amp;&amp; elem != 'Role' &amp;&amp; elem != 'RowSpan' &amp;&amp; elem != 'RubyAlign' &amp;&amp; elem != 'RubyPosition' &amp;&amp; elem != 'Scope' &amp;&amp; elem != 'Short' &amp;&amp; elem != 'SpaceAfter' &amp;&amp; elem != 'SpaceBefore' &amp;&amp; elem != 'StartIndent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Summary' &amp;&amp; elem != 'TBorderStyle' &amp;&amp; elem != 'TPadding' &amp;&amp; elem != 'TextAlign' &amp;&amp; elem != 'TextDecorationColor' &amp;&amp; elem != 'TextDecorationThickness' &amp;&amp; elem != 'TextDecorationType' &amp;&amp; elem != 'TextIndent' &amp;&amp; elem != 'TextPosition' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; elem != 'WritingMode' &amp;&amp; elem != 'checked' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict" testNumber="22"/>
			<description>StructureAttributesDict shall not contain entries BackgroundColor, BorderColor, BorderStyle, BorderThickness, Checked, Color, ColumnCount, ColumnGap, ColumnWidths, Contents, ContinuedForm, ContinuedList, Desc, GlyphOrientationVertical, NS, NoteType, P, Padding, Role, RubyAlign, RubyPosition, Scope, Short, Subtype, Summary, TBorderStyle, TPadding, TextDecorationColor, TextDecorationThickness, TextPosition, Type, checked in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'BackgroundColor' || elem == 'BorderColor' || elem == 'BorderStyle' || elem == 'BorderThickness' || elem == 'Checked' || elem == 'Color' || elem == 'ColumnCount' || elem == 'ColumnGap' || elem == 'ColumnWidths' || elem == 'Contents' || elem == 'ContinuedForm' || elem == 'ContinuedList' || elem == 'Desc' || elem == 'GlyphOrientationVertical' || elem == 'NS' || elem == 'NoteType' || elem == 'P' || elem == 'Padding' || elem == 'Role' || elem == 'RubyAlign' || elem == 'RubyPosition' || elem == 'Scope' || elem == 'Short' || elem == 'Subtype' || elem == 'Summary' || elem == 'TBorderStyle' || elem == 'TPadding' || elem == 'TextDecorationColor' || elem == 'TextDecorationThickness' || elem == 'TextPosition' || elem == 'Type' || elem == 'checked').length == 0</test>
			<error>
				<message>StructureAttributesDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'BackgroundColor' || elem == 'BorderColor' || elem == 'BorderStyle' || elem == 'BorderThickness' || elem == 'Checked' || elem == 'Color' || elem == 'ColumnCount' || elem == 'ColumnGap' || elem == 'ColumnWidths' || elem == 'Contents' || elem == 'ContinuedForm' || elem == 'ContinuedList' || elem == 'Desc' || elem == 'GlyphOrientationVertical' || elem == 'NS' || elem == 'NoteType' || elem == 'P' || elem == 'Padding' || elem == 'Role' || elem == 'RubyAlign' || elem == 'RubyPosition' || elem == 'Scope' || elem == 'Short' || elem == 'Subtype' || elem == 'Summary' || elem == 'TBorderStyle' || elem == 'TPadding' || elem == 'TextDecorationColor' || elem == 'TextDecorationThickness' || elem == 'TextPosition' || elem == 'Type' || elem == 'checked').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BBox" testNumber="8"/>
			<description>Entry BBox in StructureAttributesDict shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in StructureAttributesDict has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BBox-Rectangle" testNumber="9"/>
			<description>Entry BBox with type Rectangle in StructureAttributesDict shall satisfy special case: fn:Eval(((@O == Layout) || (@O == Artifact)) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsBBox != true || BBoxHasTypeRectangle != true || (((ONameValue == "Layout") || (ONameValue == "Artifact")) || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry BBox with type Rectangle in StructureAttributesDict does not satisfy special case: fn:Eval(((@O == Layout) || (@O == Artifact)) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BaselineShift" testNumber="8"/>
			<description>Entry BaselineShift in StructureAttributesDict shall have type Number</description>
			<test>containsBaselineShift == false || BaselineShiftHasTypeNumber == true</test>
			<error>
				<message>Entry BaselineShift in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>BaselineShiftType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BaselineShift-Number" testNumber="9"/>
			<description>Entry BaselineShift with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsBaselineShift != true || BaselineShiftHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry BaselineShift with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BlockAlign" testNumber="8"/>
			<description>Entry BlockAlign in StructureAttributesDict shall have type Name</description>
			<test>containsBlockAlign == false || BlockAlignHasTypeName == true</test>
			<error>
				<message>Entry BlockAlign in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>BlockAlignType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BlockAlign-Name" testNumber="6"/>
			<description>Entry BlockAlign with type Name in StructureAttributesDict shall have one of values: Before, After, Middle, Justify</description>
			<test>BlockAlignHasTypeName != true || BlockAlignNameValue == "Before" || BlockAlignNameValue == "Middle" || BlockAlignNameValue == "After" || BlockAlignNameValue == "Justify"</test>
			<error>
				<message>Entry BlockAlign with type Name in StructureAttributesDict has incorrect value %1 instead of Before, After, Middle, Justify</message>
				<arguments>
					<argument>BlockAlignNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-BlockAlign-Name" testNumber="9"/>
			<description>Entry BlockAlign with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsBlockAlign != true || BlockAlignHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry BlockAlign with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-ColSpan" testNumber="8"/>
			<description>Entry ColSpan in StructureAttributesDict shall have type Integer</description>
			<test>containsColSpan == false || ColSpanHasTypeInteger == true</test>
			<error>
				<message>Entry ColSpan in StructureAttributesDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>ColSpanType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-ColSpan-Integer" testNumber="9"/>
			<description>Entry ColSpan with type Integer in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</description>
			<test>containsColSpan != true || ColSpanHasTypeInteger != true || ((ONameValue == "Table") || ((ONameValue != "Layout") &amp;&amp; (ONameValue != "List") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Artifact")))</test>
			<error>
				<message>Entry ColSpan with type Integer in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-EndIndent" testNumber="8"/>
			<description>Entry EndIndent in StructureAttributesDict shall have type Number</description>
			<test>containsEndIndent == false || EndIndentHasTypeNumber == true</test>
			<error>
				<message>Entry EndIndent in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>EndIndentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-EndIndent-Number" testNumber="9"/>
			<description>Entry EndIndent with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsEndIndent != true || EndIndentHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry EndIndent with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Headers" testNumber="8"/>
			<description>Entry Headers in StructureAttributesDict shall have type Array</description>
			<test>containsHeaders == false || HeadersHasTypeArray == true</test>
			<error>
				<message>Entry Headers in StructureAttributesDict has type %1 instead of type Array</message>
				<arguments>
					<argument>HeadersType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Headers-Array" testNumber="9"/>
			<description>Entry Headers with type Array in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</description>
			<test>containsHeaders != true || HeadersHasTypeArray != true || ((ONameValue == "Table") || ((ONameValue != "Layout") &amp;&amp; (ONameValue != "List") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Artifact")))</test>
			<error>
				<message>Entry Headers with type Array in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Height" testNumber="8"/>
			<description>Entry Height in StructureAttributesDict shall have one of types: Name, Number</description>
			<test>containsHeight == false || HeightHasTypeName == true || HeightHasTypeNumber == true</test>
			<error>
				<message>Entry Height in StructureAttributesDict has type %1 instead of one of types: Name, Number</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Height-Name" testNumber="9"/>
			<description>Entry Height with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsHeight != true || HeightHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry Height with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Height-Number" testNumber="9"/>
			<description>Entry Height with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsHeight != true || HeightHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry Height with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-InlineAlign" testNumber="8"/>
			<description>Entry InlineAlign in StructureAttributesDict shall have type Name</description>
			<test>containsInlineAlign == false || InlineAlignHasTypeName == true</test>
			<error>
				<message>Entry InlineAlign in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>InlineAlignType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-InlineAlign-Name" testNumber="6"/>
			<description>Entry InlineAlign with type Name in StructureAttributesDict shall have one of values: Center, Start, End</description>
			<test>InlineAlignHasTypeName != true || InlineAlignNameValue == "Start" || InlineAlignNameValue == "Center" || InlineAlignNameValue == "End"</test>
			<error>
				<message>Entry InlineAlign with type Name in StructureAttributesDict has incorrect value %1 instead of Center, Start, End</message>
				<arguments>
					<argument>InlineAlignNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-InlineAlign-Name" testNumber="9"/>
			<description>Entry InlineAlign with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsInlineAlign != true || InlineAlignHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry InlineAlign with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-LineHeight" testNumber="8"/>
			<description>Entry LineHeight in StructureAttributesDict shall have one of types: Name, Number</description>
			<test>containsLineHeight == false || LineHeightHasTypeName == true || LineHeightHasTypeNumber == true</test>
			<error>
				<message>Entry LineHeight in StructureAttributesDict has type %1 instead of one of types: Name, Number</message>
				<arguments>
					<argument>LineHeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-LineHeight-Name" testNumber="6"/>
			<description>Entry LineHeight with type Name in StructureAttributesDict shall have one of values: Auto, Normal</description>
			<test>LineHeightHasTypeName != true || LineHeightNameValue == "Normal" || LineHeightNameValue == "Auto"</test>
			<error>
				<message>Entry LineHeight with type Name in StructureAttributesDict has incorrect value %1 instead of Auto, Normal</message>
				<arguments>
					<argument>LineHeightNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-LineHeight-Name" testNumber="9"/>
			<description>Entry LineHeight with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsLineHeight != true || LineHeightHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry LineHeight with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-LineHeight-Number" testNumber="9"/>
			<description>Entry LineHeight with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsLineHeight != true || LineHeightHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry LineHeight with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-ListNumbering" testNumber="8"/>
			<description>Entry ListNumbering in StructureAttributesDict shall have type Name</description>
			<test>containsListNumbering == false || ListNumberingHasTypeName == true</test>
			<error>
				<message>Entry ListNumbering in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>ListNumberingType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-ListNumbering-Name" testNumber="6"/>
			<description>Entry ListNumbering with type Name in StructureAttributesDict shall have one of values: Circle, Decimal, Disc, UpperRoman, LowerRoman, UpperAlpha, LowerAlpha, Ordered, Square, None</description>
			<test>ListNumberingHasTypeName != true || ListNumberingNameValue == "None" || ListNumberingNameValue == "Disc" || ListNumberingNameValue == "Circle" || ListNumberingNameValue == "Square" || ListNumberingNameValue == "Ordered" || ListNumberingNameValue == "Decimal" || ListNumberingNameValue == "UpperRoman" || ListNumberingNameValue == "LowerRoman" || ListNumberingNameValue == "UpperAlpha" || ListNumberingNameValue == "LowerAlpha"</test>
			<error>
				<message>Entry ListNumbering with type Name in StructureAttributesDict has incorrect value %1 instead of Circle, Decimal, Disc, UpperRoman, LowerRoman, UpperAlpha, LowerAlpha, Ordered, Square, None</message>
				<arguments>
					<argument>ListNumberingNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-ListNumbering-Name" testNumber="9"/>
			<description>Entry ListNumbering with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == List) || ((@O != Layout) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsListNumbering != true || ListNumberingHasTypeName != true || ((ONameValue == "List") || ((ONameValue != "Layout") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry ListNumbering with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == List) || ((@O != Layout) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-O" testNumber="8"/>
			<description>Entry O in StructureAttributesDict shall have type Name</description>
			<test>containsO == false || OHasTypeName == true</test>
			<error>
				<message>Entry O in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-O" testNumber="7"/>
			<description>Entry O in StructureAttributesDict is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in StructureAttributesDict is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-O-Name-FENote" testNumber="27"/>
			<description>Entry O with type Name in StructureAttributesDict should not have value FENote, if extension WTPDF does not chosen</description>
			<test>(hasExtensionWTPDF == true) || ONameValue != "FENote"</test>
			<error>
				<message>Entry O with type Name in StructureAttributesDict has value FENote</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Placement" testNumber="8"/>
			<description>Entry Placement in StructureAttributesDict shall have type Name</description>
			<test>containsPlacement == false || PlacementHasTypeName == true</test>
			<error>
				<message>Entry Placement in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>PlacementType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Placement-Name" testNumber="6"/>
			<description>Entry Placement with type Name in StructureAttributesDict shall have one of values: Before, Start, Block, End, Inline</description>
			<test>PlacementHasTypeName != true || PlacementNameValue == "Block" || PlacementNameValue == "Before" || PlacementNameValue == "Start" || PlacementNameValue == "End" || PlacementNameValue == "Inline"</test>
			<error>
				<message>Entry Placement with type Name in StructureAttributesDict has incorrect value %1 instead of Before, Start, Block, End, Inline</message>
				<arguments>
					<argument>PlacementNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Placement-Name" testNumber="9"/>
			<description>Entry Placement with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsPlacement != true || PlacementHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry Placement with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-RowSpan" testNumber="8"/>
			<description>Entry RowSpan in StructureAttributesDict shall have type Integer</description>
			<test>containsRowSpan == false || RowSpanHasTypeInteger == true</test>
			<error>
				<message>Entry RowSpan in StructureAttributesDict has type %1 instead of type Integer</message>
				<arguments>
					<argument>RowSpanType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-RowSpan-Integer" testNumber="9"/>
			<description>Entry RowSpan with type Integer in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</description>
			<test>containsRowSpan != true || RowSpanHasTypeInteger != true || ((ONameValue == "Table") || ((ONameValue != "Layout") &amp;&amp; (ONameValue != "List") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Artifact")))</test>
			<error>
				<message>Entry RowSpan with type Integer in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Table) || ((@O != Layout) &amp;&amp; (@O != List) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Artifact)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-SpaceAfter" testNumber="8"/>
			<description>Entry SpaceAfter in StructureAttributesDict shall have type Number</description>
			<test>containsSpaceAfter == false || SpaceAfterHasTypeNumber == true</test>
			<error>
				<message>Entry SpaceAfter in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>SpaceAfterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-SpaceAfter-Number" testNumber="9"/>
			<description>Entry SpaceAfter with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsSpaceAfter != true || SpaceAfterHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry SpaceAfter with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-SpaceBefore" testNumber="8"/>
			<description>Entry SpaceBefore in StructureAttributesDict shall have type Number</description>
			<test>containsSpaceBefore == false || SpaceBeforeHasTypeNumber == true</test>
			<error>
				<message>Entry SpaceBefore in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>SpaceBeforeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-SpaceBefore-Number" testNumber="9"/>
			<description>Entry SpaceBefore with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsSpaceBefore != true || SpaceBeforeHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry SpaceBefore with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-StartIndent" testNumber="8"/>
			<description>Entry StartIndent in StructureAttributesDict shall have type Number</description>
			<test>containsStartIndent == false || StartIndentHasTypeNumber == true</test>
			<error>
				<message>Entry StartIndent in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>StartIndentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-StartIndent-Number" testNumber="9"/>
			<description>Entry StartIndent with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsStartIndent != true || StartIndentHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry StartIndent with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextAlign" testNumber="8"/>
			<description>Entry TextAlign in StructureAttributesDict shall have type Name</description>
			<test>containsTextAlign == false || TextAlignHasTypeName == true</test>
			<error>
				<message>Entry TextAlign in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>TextAlignType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextAlign-Name" testNumber="6"/>
			<description>Entry TextAlign with type Name in StructureAttributesDict shall have one of values: Center, Start, End, Justify</description>
			<test>TextAlignHasTypeName != true || TextAlignNameValue == "Start" || TextAlignNameValue == "Center" || TextAlignNameValue == "End" || TextAlignNameValue == "Justify"</test>
			<error>
				<message>Entry TextAlign with type Name in StructureAttributesDict has incorrect value %1 instead of Center, Start, End, Justify</message>
				<arguments>
					<argument>TextAlignNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextAlign-Name" testNumber="9"/>
			<description>Entry TextAlign with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsTextAlign != true || TextAlignHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry TextAlign with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextDecorationType" testNumber="8"/>
			<description>Entry TextDecorationType in StructureAttributesDict shall have type Name</description>
			<test>containsTextDecorationType == false || TextDecorationTypeHasTypeName == true</test>
			<error>
				<message>Entry TextDecorationType in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>TextDecorationTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextDecorationType-Name" testNumber="6"/>
			<description>Entry TextDecorationType with type Name in StructureAttributesDict shall have one of values: LineThrough, Overline, Underline, None</description>
			<test>TextDecorationTypeHasTypeName != true || TextDecorationTypeNameValue == "None" || TextDecorationTypeNameValue == "Underline" || TextDecorationTypeNameValue == "Overline" || TextDecorationTypeNameValue == "LineThrough"</test>
			<error>
				<message>Entry TextDecorationType with type Name in StructureAttributesDict has incorrect value %1 instead of LineThrough, Overline, Underline, None</message>
				<arguments>
					<argument>TextDecorationTypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextDecorationType-Name" testNumber="9"/>
			<description>Entry TextDecorationType with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsTextDecorationType != true || TextDecorationTypeHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry TextDecorationType with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextIndent" testNumber="8"/>
			<description>Entry TextIndent in StructureAttributesDict shall have type Number</description>
			<test>containsTextIndent == false || TextIndentHasTypeNumber == true</test>
			<error>
				<message>Entry TextIndent in StructureAttributesDict has type %1 instead of type Number</message>
				<arguments>
					<argument>TextIndentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-TextIndent-Number" testNumber="9"/>
			<description>Entry TextIndent with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsTextIndent != true || TextIndentHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry TextIndent with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Width" testNumber="8"/>
			<description>Entry Width in StructureAttributesDict shall have one of types: Name, Number</description>
			<test>containsWidth == false || WidthHasTypeName == true || WidthHasTypeNumber == true</test>
			<error>
				<message>Entry Width in StructureAttributesDict has type %1 instead of one of types: Name, Number</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Width-Name" testNumber="9"/>
			<description>Entry Width with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsWidth != true || WidthHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry Width with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-Width-Number" testNumber="9"/>
			<description>Entry Width with type Number in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsWidth != true || WidthHasTypeNumber != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry Width with type Number in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-WritingMode" testNumber="8"/>
			<description>Entry WritingMode in StructureAttributesDict shall have type Name</description>
			<test>containsWritingMode == false || WritingModeHasTypeName == true</test>
			<error>
				<message>Entry WritingMode in StructureAttributesDict has type %1 instead of type Name</message>
				<arguments>
					<argument>WritingModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-WritingMode-Name" testNumber="6"/>
			<description>Entry WritingMode with type Name in StructureAttributesDict shall have one of values: LrTb, RlTb, TbRl</description>
			<test>WritingModeHasTypeName != true || WritingModeNameValue == "LrTb" || WritingModeNameValue == "RlTb" || WritingModeNameValue == "TbRl"</test>
			<error>
				<message>Entry WritingMode with type Name in StructureAttributesDict has incorrect value %1 instead of LrTb, RlTb, TbRl</message>
				<arguments>
					<argument>WritingModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStructureAttributesDict">
			<id specification="PDF_1_4" clause="StructureAttributesDict-WritingMode-Name" testNumber="9"/>
			<description>Entry WritingMode with type Name in StructureAttributesDict shall satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</description>
			<test>containsWritingMode != true || WritingModeHasTypeName != true || ((ONameValue == "Layout") || ((ONameValue != "List") &amp;&amp; (ONameValue != "Table") &amp;&amp; (ONameValue != "PrintField") &amp;&amp; (ONameValue != "Table")))</test>
			<error>
				<message>Entry WritingMode with type Name in StructureAttributesDict does not satisfy special case: fn:Eval((@O == Layout) || ((@O != List) &amp;&amp; (@O != Table) &amp;&amp; (@O != PrintField) &amp;&amp; (@O != Table)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_4" clause="StyleDict" testNumber="1"/>
			<description>StyleDict shall not contain entries except Panose</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Panose' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>StyleDict contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Panose' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_4" clause="StyleDict-Panose" testNumber="8"/>
			<description>Entry Panose in StyleDict shall have type StringByte</description>
			<test>containsPanose == false || PanoseHasTypeStringByte == true</test>
			<error>
				<message>Entry Panose in StyleDict has type %1 instead of type StringByte</message>
				<arguments>
					<argument>PanoseType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AStyleDict">
			<id specification="PDF_1_4" clause="StyleDict-Panose-StringByte" testNumber="9"/>
			<description>Entry Panose with type StringByte in StyleDict shall satisfy special case: fn:Eval(fn:StringLength(Panose) == 12)</description>
			<test>PanoseHasTypeStringByte != true || (PanoseStringSize == 12)</test>
			<error>
				<message>Entry Panose with type StringByte in StyleDict does not satisfy special case: fn:Eval(fn:StringLength(Panose) == 12)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread" testNumber="1"/>
			<description>Thread shall not contain entries except F, I, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Thread contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'F' &amp;&amp; elem != 'I' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread" testNumber="22"/>
			<description>Thread shall not contain entry Metadata in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsMetadata == false</test>
			<error>
				<message>Thread contains entry Metadata</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-F" testNumber="8"/>
			<description>Entry F in Thread shall have type Dictionary</description>
			<test>containsF == false || FHasTypeDictionary == true</test>
			<error>
				<message>Entry F in Thread has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-F" testNumber="7"/>
			<description>Entry F in Thread is required</description>
			<test>containsF == true</test>
			<error>
				<message>Entry F in Thread is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-F-Dictionary" testNumber="10"/>
			<description>Entry F with type Dictionary in Thread shall be indirect</description>
			<test>FHasTypeDictionary != true || isFIndirect == true</test>
			<error>
				<message>Entry F with type Dictionary in Thread is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-I" testNumber="8"/>
			<description>Entry I in Thread shall have type Dictionary</description>
			<test>containsI == false || IHasTypeDictionary == true</test>
			<error>
				<message>Entry I in Thread has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>IType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-Type" testNumber="8"/>
			<description>Entry Type in Thread shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Thread has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThread">
			<id specification="PDF_1_4" clause="Thread-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Thread shall have value Thread</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Thread"</test>
			<error>
				<message>Entry Type with type Name in Thread has incorrect value %1 instead of Thread</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail" testNumber="1"/>
			<description>Thumbnail shall not contain entries except BitsPerComponent, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Height, Length, Subtype, Type, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Thumbnail contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail" testNumber="22"/>
			<description>Thumbnail shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>Thumbnail contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in Thumbnail shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-BitsPerComponent" testNumber="7"/>
			<description>Entry BitsPerComponent in Thumbnail is required</description>
			<test>containsBitsPerComponent == true</test>
			<error>
				<message>Entry BitsPerComponent in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in Thumbnail shall have one of values: 1, 2, 4, 16, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8 || BitsPerComponentIntegerValue == 16</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in Thumbnail has incorrect value %1 instead of 1, 2, 4, 16, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in Thumbnail shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in Thumbnail has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in Thumbnail is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in Thumbnail shall have one of values: DeviceGray, DeviceRGB</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in Thumbnail has incorrect value %1 instead of DeviceGray, DeviceRGB</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Decode" testNumber="8"/>
			<description>Entry Decode in Thumbnail shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in Thumbnail has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in Thumbnail shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in Thumbnail is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in Thumbnail shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in Thumbnail has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in Thumbnail shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in Thumbnail does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-F" testNumber="8"/>
			<description>Entry F in Thumbnail shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in Thumbnail has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in Thumbnail shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in Thumbnail is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in Thumbnail shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in Thumbnail has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in Thumbnail shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in Thumbnail does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FFilter" testNumber="8"/>
			<description>Entry FFilter in Thumbnail shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in Thumbnail has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in Thumbnail shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in Thumbnail does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in Thumbnail shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in Thumbnail has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Filter" testNumber="8"/>
			<description>Entry Filter in Thumbnail shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in Thumbnail has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in Thumbnail shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in Thumbnail does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in Thumbnail shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in Thumbnail has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Height" testNumber="8"/>
			<description>Entry Height in Thumbnail shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Height" testNumber="7"/>
			<description>Entry Height in Thumbnail is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Length" testNumber="8"/>
			<description>Entry Length in Thumbnail shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Length" testNumber="7"/>
			<description>Entry Length in Thumbnail is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Subtype" testNumber="8"/>
			<description>Entry Subtype in Thumbnail shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in Thumbnail has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in Thumbnail shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in Thumbnail has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Type" testNumber="8"/>
			<description>Entry Type in Thumbnail shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Thumbnail has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Thumbnail shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in Thumbnail has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Width" testNumber="8"/>
			<description>Entry Width in Thumbnail shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in Thumbnail has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AThumbnail">
			<id specification="PDF_1_4" clause="Thumbnail-Width" testNumber="7"/>
			<description>Entry Width in Thumbnail is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in Thumbnail is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream" testNumber="1"/>
			<description>ToUnicodeCMapStream shall not contain entries except CIDSystemInfo, CMapName, DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Type, UseCMap, WMode</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'WMode' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ToUnicodeCMapStream contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CIDSystemInfo' &amp;&amp; elem != 'CMapName' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'UseCMap' &amp;&amp; elem != 'WMode' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream" testNumber="22"/>
			<description>ToUnicodeCMapStream shall not contain entry DL in PDF 1.4. This entry appears in later pdf versions</description>
			<test>containsDL == false</test>
			<error>
				<message>ToUnicodeCMapStream contains entry DL</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-CIDSystemInfo" testNumber="8"/>
			<description>Entry CIDSystemInfo in ToUnicodeCMapStream shall have type Dictionary</description>
			<test>containsCIDSystemInfo == false || CIDSystemInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry CIDSystemInfo in ToUnicodeCMapStream has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CIDSystemInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-CMapName" testNumber="8"/>
			<description>Entry CMapName in ToUnicodeCMapStream shall have type Name</description>
			<test>containsCMapName == false || CMapNameHasTypeName == true</test>
			<error>
				<message>Entry CMapName in ToUnicodeCMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>CMapNameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in ToUnicodeCMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in ToUnicodeCMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in ToUnicodeCMapStream shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in ToUnicodeCMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in ToUnicodeCMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in ToUnicodeCMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-F" testNumber="8"/>
			<description>Entry F in ToUnicodeCMapStream shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in ToUnicodeCMapStream has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in ToUnicodeCMapStream shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in ToUnicodeCMapStream is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in ToUnicodeCMapStream shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in ToUnicodeCMapStream has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in ToUnicodeCMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in ToUnicodeCMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FFilter" testNumber="8"/>
			<description>Entry FFilter in ToUnicodeCMapStream shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in ToUnicodeCMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in ToUnicodeCMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in ToUnicodeCMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in ToUnicodeCMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in ToUnicodeCMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Filter" testNumber="8"/>
			<description>Entry Filter in ToUnicodeCMapStream shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in ToUnicodeCMapStream has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in ToUnicodeCMapStream shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in ToUnicodeCMapStream does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in ToUnicodeCMapStream shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in ToUnicodeCMapStream has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Length" testNumber="8"/>
			<description>Entry Length in ToUnicodeCMapStream shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in ToUnicodeCMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Length" testNumber="7"/>
			<description>Entry Length in ToUnicodeCMapStream is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in ToUnicodeCMapStream is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Type" testNumber="8"/>
			<description>Entry Type in ToUnicodeCMapStream shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in ToUnicodeCMapStream has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in ToUnicodeCMapStream shall have value CMap</description>
			<test>TypeHasTypeName != true || TypeNameValue == "CMap"</test>
			<error>
				<message>Entry Type with type Name in ToUnicodeCMapStream has incorrect value %1 instead of CMap</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-UseCMap" testNumber="8"/>
			<description>Entry UseCMap in ToUnicodeCMapStream shall have one of types: Name, Stream</description>
			<test>containsUseCMap == false || UseCMapHasTypeName == true || UseCMapHasTypeStream == true</test>
			<error>
				<message>Entry UseCMap in ToUnicodeCMapStream has type %1 instead of one of types: Name, Stream</message>
				<arguments>
					<argument>UseCMapType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-UseCMap-Name" testNumber="6"/>
			<description>Entry UseCMap with type Name in ToUnicodeCMapStream shall have one of values: GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</description>
			<test>UseCMapHasTypeName != true || UseCMapNameValue == "GB-EUC-H" || UseCMapNameValue == "GB-EUC-V" || UseCMapNameValue == "GBpc-EUC-H" || UseCMapNameValue == "GBpc-EUC-V" || UseCMapNameValue == "GBK-EUC-H" || UseCMapNameValue == "GBK-EUC-V" || UseCMapNameValue == "GBKp-EUC-H" || UseCMapNameValue == "GBKp-EUC-V" || UseCMapNameValue == "GBK2K-H" || UseCMapNameValue == "GBK2K-V" || UseCMapNameValue == "UniGB-UCS2-H" || UseCMapNameValue == "UniGB-UCS2-V" || UseCMapNameValue == "UniGB-UTF16-H" || UseCMapNameValue == "UniGB-UTF16-V" || UseCMapNameValue == "B5pc-H" || UseCMapNameValue == "B5pc-V" || UseCMapNameValue == "HKscs-B5-H" || UseCMapNameValue == "HKscs-B5-V" || UseCMapNameValue == "ETen-B5-H" || UseCMapNameValue == "ETen-B5-V" || UseCMapNameValue == "ETenms-B5-H" || UseCMapNameValue == "ETenms-B5-V" || UseCMapNameValue == "CNS-EUC-H" || UseCMapNameValue == "CNS-EUC-V" || UseCMapNameValue == "UniCNS-UCS2-H" || UseCMapNameValue == "UniCNS-UCS2-V" || UseCMapNameValue == "UniCNS-UTF16-H" || UseCMapNameValue == "UniCNS-UTF16-V" || UseCMapNameValue == "83pv-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-H" || UseCMapNameValue == "90ms-RKSJ-V" || UseCMapNameValue == "90msp-RKSJ-H" || UseCMapNameValue == "90msp-RKSJ-V" || UseCMapNameValue == "90pv-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-H" || UseCMapNameValue == "Add-RKSJ-V" || UseCMapNameValue == "EUC-H" || UseCMapNameValue == "EUC-V" || UseCMapNameValue == "Ext-RKSJ-H" || UseCMapNameValue == "Ext-RKSJ-V" || UseCMapNameValue == "H" || UseCMapNameValue == "V" || UseCMapNameValue == "UniJIS-UCS2-H" || UseCMapNameValue == "UniJIS-UCS2-V" || UseCMapNameValue == "UniJIS-UCS2-HW-H" || UseCMapNameValue == "UniJIS-UCS2-HW-V" || UseCMapNameValue == "UniJIS-UTF16-H" || UseCMapNameValue == "UniJIS-UTF16-V" || UseCMapNameValue == "KSC-EUC-H" || UseCMapNameValue == "KSC-EUC-V" || UseCMapNameValue == "KSCms-UHC-H" || UseCMapNameValue == "KSCms-UHC-V" || UseCMapNameValue == "KSCms-UHC-HW-H" || UseCMapNameValue == "KSCms-UHC-HW-V" || UseCMapNameValue == "KSCpc-EUC-H" || UseCMapNameValue == "UniKS-UCS2-H" || UseCMapNameValue == "UniKS-UCS2-V" || UseCMapNameValue == "UniKS-UTF16-H" || UseCMapNameValue == "UniKS-UTF16-V" || UseCMapNameValue == "Identity-H" || UseCMapNameValue == "Identity-V"</test>
			<error>
				<message>Entry UseCMap with type Name in ToUnicodeCMapStream has incorrect value %1 instead of GBK2K-V, ETenms-B5-H, 83pv-RKSJ-H, UniKS-UTF16-V, KSCpc-EUC-H, KSCms-UHC-HW-V, GB-EUC-H, B5pc-V, KSC-EUC-H, HKscs-B5-V, GBK2K-H, B5pc-H, KSCms-UHC-H, HKscs-B5-H, UniJIS-UCS2-V, UniJIS-UCS2-HW-H, GB-EUC-V, 90msp-RKSJ-H, UniJIS-UTF16-H, KSC-EUC-V, ETen-B5-V, CNS-EUC-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniJIS-UCS2-HW-V, ETenms-B5-V, CNS-EUC-V, 90msp-RKSJ-V, UniKS-UCS2-H, UniKS-UTF16-H, ETen-B5-H, 90ms-RKSJ-V, GBpc-EUC-H, Ext-RKSJ-H, UniKS-UCS2-V, Identity-V, H, GBpc-EUC-V, GBKp-EUC-H, KSCms-UHC-V, Add-RKSJ-H, UniCNS-UTF16-H, UniJIS-UTF16-V, V, UniCNS-UCS2-V, GBKp-EUC-V, Add-RKSJ-V, 90pv-RKSJ-H, GBK-EUC-V, UniGB-UTF16-V, UniCNS-UTF16-V, GBK-EUC-H, UniGB-UCS2-H, EUC-V, UniGB-UTF16-H, Ext-RKSJ-V, 90ms-RKSJ-H, Identity-H, UniGB-UCS2-V, EUC-H, KSCms-UHC-HW-H</message>
				<arguments>
					<argument>UseCMapNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-UseCMap-Stream" testNumber="10"/>
			<description>Entry UseCMap with type Stream in ToUnicodeCMapStream shall be indirect</description>
			<test>UseCMapHasTypeStream != true || isUseCMapIndirect == true</test>
			<error>
				<message>Entry UseCMap with type Stream in ToUnicodeCMapStream is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-WMode" testNumber="8"/>
			<description>Entry WMode in ToUnicodeCMapStream shall have type Integer</description>
			<test>containsWMode == false || WModeHasTypeInteger == true</test>
			<error>
				<message>Entry WMode in ToUnicodeCMapStream has type %1 instead of type Integer</message>
				<arguments>
					<argument>WModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AToUnicodeCMapStream">
			<id specification="PDF_1_4" clause="ToUnicodeCMapStream-WMode-Integer" testNumber="6"/>
			<description>Entry WMode with type Integer in ToUnicodeCMapStream shall have one of values: 0, 1</description>
			<test>WModeHasTypeInteger != true || WModeIntegerValue == 1 || WModeIntegerValue == 0</test>
			<error>
				<message>Entry WMode with type Integer in ToUnicodeCMapStream has incorrect value %1 instead of 0, 1</message>
				<arguments>
					<argument>WModeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray" testNumber="2"/>
			<description>TrailerIDArray shall contain exactly 2 elements</description>
			<test>size == 2</test>
			<error>
				<message>TrailerIDArray contains %1 element(s) instead of 2</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-0" testNumber="8"/>
			<description>Entry 0 in TrailerIDArray shall have type StringByte</description>
			<test>size &lt;= 0 || entry0HasTypeStringByte == true</test>
			<error>
				<message>Entry 0 in TrailerIDArray has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-0-StringByte" testNumber="16"/>
			<description>If entry 0 with type StringByte in TrailerIDArray satisfies condition fn:IsPresent(trailer::Encrypt), it shall be direct</description>
			<test>entry0HasTypeStringByte != true || (isentry0Indirect == false || (containstrailerEncrypt != true))</test>
			<error>
				<message>Entry 0 with type StringByte in TrailerIDArray is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-0-StringByte" testNumber="9"/>
			<description>Entry 0 with type StringByte in TrailerIDArray shall satisfy special case: fn:Eval((fn:StringLength(0) &gt;= 16) &amp;&amp; fn:AlwaysUnencrypted())</description>
			<test>entry0HasTypeStringByte != true || (entry0StringSize &gt;= 16)</test>
			<error>
				<message>Entry 0 with type StringByte in TrailerIDArray does not satisfy special case: fn:Eval((fn:StringLength(0) &gt;= 16) &amp;&amp; fn:AlwaysUnencrypted())</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-1" testNumber="8"/>
			<description>Entry 1 in TrailerIDArray shall have type StringByte</description>
			<test>size &lt;= 1 || entry1HasTypeStringByte == true</test>
			<error>
				<message>Entry 1 in TrailerIDArray has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-1-StringByte" testNumber="16"/>
			<description>If entry 1 with type StringByte in TrailerIDArray satisfies condition fn:IsPresent(trailer::Encrypt), it shall be direct</description>
			<test>entry1HasTypeStringByte != true || (isentry1Indirect == false || (containstrailerEncrypt != true))</test>
			<error>
				<message>Entry 1 with type StringByte in TrailerIDArray is indirect</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrailerIDArray">
			<id specification="PDF_1_4" clause="TrailerIDArray-1-StringByte" testNumber="9"/>
			<description>Entry 1 with type StringByte in TrailerIDArray shall satisfy special case: fn:Eval((fn:StringLength(1) &gt;= 16) &amp;&amp; fn:AlwaysUnencrypted())</description>
			<test>entry1HasTypeStringByte != true || (entry1StringSize &gt;= 16)</test>
			<error>
				<message>Entry 1 with type StringByte in TrailerIDArray does not satisfy special case: fn:Eval((fn:StringLength(1) &gt;= 16) &amp;&amp; fn:AlwaysUnencrypted())</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition" testNumber="1"/>
			<description>Transition shall not contain entries except D, Di, Dm, M, S, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Di' &amp;&amp; elem != 'Dm' &amp;&amp; elem != 'M' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>Transition contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'B' &amp;&amp; elem != 'D' &amp;&amp; elem != 'Di' &amp;&amp; elem != 'Dm' &amp;&amp; elem != 'M' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition" testNumber="22"/>
			<description>Transition shall not contain entries B, SS in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'B' || elem == 'SS').length == 0</test>
			<error>
				<message>Transition contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'B' || elem == 'SS').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-D" testNumber="8"/>
			<description>Entry D in Transition shall have type Number</description>
			<test>containsD == false || DHasTypeNumber == true</test>
			<error>
				<message>Entry D in Transition has type %1 instead of type Number</message>
				<arguments>
					<argument>DType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-D-Number" testNumber="14"/>
			<description>Entry D with type Number in Transition shall satisfy possible value predicate: fn:Eval(@D &gt;= 0)</description>
			<test>DHasTypeNumber != true || DNumberValue &gt;= 0</test>
			<error>
				<message>Entry D with type Number in Transition does not satisfy possible value predicate: fn:Eval(@D &gt;= 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di" testNumber="8"/>
			<description>Entry Di in Transition shall have one of types: Integer, Name</description>
			<test>containsDi == false || DiHasTypeInteger == true || DiHasTypeName == true</test>
			<error>
				<message>Entry Di in Transition has type %1 instead of one of types: Integer, Name</message>
				<arguments>
					<argument>DiType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Integer-90" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 90, only if this object satisfies condition (@S == Wipe)</description>
			<test>(SNameValue == "Wipe") || DiIntegerValue != 90</test>
			<error>
				<message>Entry Di in Transition has value 90, but not satisfy condition (@S == Wipe)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Integer-180" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 180, only if this object satisfies condition (@S == Wipe)</description>
			<test>(SNameValue == "Wipe") || DiIntegerValue != 180</test>
			<error>
				<message>Entry Di in Transition has value 180, but not satisfy condition (@S == Wipe)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Integer-315" testNumber="13"/>
			<description>Entry Di in Transition may have Integer value 315, only if this object satisfies condition (@S == Glitter)</description>
			<test>(SNameValue == "Glitter") || DiIntegerValue != 315</test>
			<error>
				<message>Entry Di in Transition has value 315, but not satisfy condition (@S == Glitter)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Integer" testNumber="6"/>
			<description>Entry Di with type Integer in Transition shall have one of values: 0, 90, 315, 180, 270</description>
			<test>DiHasTypeInteger != true || DiIntegerValue == 0 || DiIntegerValue == 90 || DiIntegerValue == 180 || DiIntegerValue == 270 || DiIntegerValue == 315</test>
			<error>
				<message>Entry Di with type Integer in Transition has incorrect value %1 instead of 0, 90, 315, 180, 270</message>
				<arguments>
					<argument>DiIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Name" testNumber="6"/>
			<description>Entry Di with type Name in Transition shall have value None</description>
			<test>DiHasTypeName != true || DiNameValue == "None"</test>
			<error>
				<message>Entry Di with type Name in Transition has incorrect value %1 instead of None</message>
				<arguments>
					<argument>DiNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Di-Name" testNumber="9"/>
			<description>Entry Di with type Name in Transition shall satisfy special case: fn:Eval(((@Di == None) &amp;&amp; (@S == Fly)))</description>
			<test>DiHasTypeName != true || ((DiNameValue == "None") &amp;&amp; (SNameValue == "Fly"))</test>
			<error>
				<message>Entry Di with type Name in Transition does not satisfy special case: fn:Eval(((@Di == None) &amp;&amp; (@S == Fly)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Dm" testNumber="8"/>
			<description>Entry Dm in Transition shall have type Name</description>
			<test>containsDm == false || DmHasTypeName == true</test>
			<error>
				<message>Entry Dm in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>DmType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Dm-Name" testNumber="6"/>
			<description>Entry Dm with type Name in Transition shall have one of values: V, H</description>
			<test>DmHasTypeName != true || DmNameValue == "H" || DmNameValue == "V"</test>
			<error>
				<message>Entry Dm with type Name in Transition has incorrect value %1 instead of V, H</message>
				<arguments>
					<argument>DmNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-M" testNumber="8"/>
			<description>Entry M in Transition shall have type Name</description>
			<test>containsM == false || MHasTypeName == true</test>
			<error>
				<message>Entry M in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>MType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-M-Name" testNumber="6"/>
			<description>Entry M with type Name in Transition shall have one of values: I, O</description>
			<test>MHasTypeName != true || MNameValue == "I" || MNameValue == "O"</test>
			<error>
				<message>Entry M with type Name in Transition has incorrect value %1 instead of I, O</message>
				<arguments>
					<argument>MNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-S" testNumber="8"/>
			<description>Entry S in Transition shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-S-Name" testNumber="6"/>
			<description>Entry S with type Name in Transition shall have one of values: Uncover, Glitter, R, Fly, Cover, Dissolve, Box, Split, Push, Blinds, Fade, Wipe</description>
			<test>SHasTypeName != true || SNameValue == "Split" || SNameValue == "Blinds" || SNameValue == "Box" || SNameValue == "Wipe" || SNameValue == "Dissolve" || SNameValue == "Glitter" || SNameValue == "R" || SNameValue == "Fly" || SNameValue == "Push" || SNameValue == "Cover" || SNameValue == "Uncover" || SNameValue == "Fade"</test>
			<error>
				<message>Entry S with type Name in Transition has incorrect value %1 instead of Uncover, Glitter, R, Fly, Cover, Dissolve, Box, Split, Push, Blinds, Fade, Wipe</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Type" testNumber="8"/>
			<description>Entry Type in Transition shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in Transition has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATransition">
			<id specification="PDF_1_4" clause="Transition-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in Transition shall have value Trans</description>
			<test>TypeHasTypeName != true || TypeNameValue == "Trans"</test>
			<error>
				<message>Entry Type with type Name in Transition has incorrect value %1 instead of Trans</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrapRegion">
			<id specification="PDF_1_4" clause="TrapRegion" testNumber="1"/>
			<description>TrapRegion shall not contain entries except TP, TZ</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'TP' &amp;&amp; elem != 'TZ' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>TrapRegion contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'TP' &amp;&amp; elem != 'TZ' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrapRegion">
			<id specification="PDF_1_4" clause="TrapRegion-TP" testNumber="8"/>
			<description>Entry TP in TrapRegion shall have type Name</description>
			<test>containsTP == false || TPHasTypeName == true</test>
			<error>
				<message>Entry TP in TrapRegion has type %1 instead of type Name</message>
				<arguments>
					<argument>TPType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="ATrapRegion">
			<id specification="PDF_1_4" clause="TrapRegion-TP" testNumber="7"/>
			<description>Entry TP in TrapRegion is required</description>
			<test>containsTP == true</test>
			<error>
				<message>Entry TP in TrapRegion is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="ATrapRegion">
			<id specification="PDF_1_4" clause="TrapRegion-TZ" testNumber="8"/>
			<description>Entry TZ in TrapRegion shall have type Array</description>
			<test>containsTZ == false || TZHasTypeArray == true</test>
			<error>
				<message>Entry TZ in TrapRegion has type %1 instead of type Array</message>
				<arguments>
					<argument>TZType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURI">
			<id specification="PDF_1_4" clause="URI" testNumber="1"/>
			<description>URI shall not contain entries except Base</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'Base' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>URI contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'Base' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURI">
			<id specification="PDF_1_4" clause="URI-Base" testNumber="8"/>
			<description>Entry Base in URI shall have type StringAscii</description>
			<test>containsBase == false || BaseHasTypeStringAscii == true</test>
			<error>
				<message>Entry Base in URI has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>BaseType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURLAlias">
			<id specification="PDF_1_4" clause="URLAlias" testNumber="1"/>
			<description>URLAlias shall not contain entries except C, U</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'U' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>URLAlias contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'U' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURLAlias">
			<id specification="PDF_1_4" clause="URLAlias-C" testNumber="8"/>
			<description>Entry C in URLAlias shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in URLAlias has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURLAlias">
			<id specification="PDF_1_4" clause="URLAlias-C-Array" testNumber="9"/>
			<description>Entry C with type Array in URLAlias shall satisfy special case: fn:Eval(fn:ArrayLength(C) &gt;= 1)</description>
			<test>CHasTypeArray != true || (CArraySize &gt;= 1)</test>
			<error>
				<message>Entry C with type Array in URLAlias does not satisfy special case: fn:Eval(fn:ArrayLength(C) &gt;= 1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AURLAlias">
			<id specification="PDF_1_4" clause="URLAlias-U" testNumber="8"/>
			<description>Entry U in URLAlias shall have type StringAscii</description>
			<test>containsU == false || UHasTypeStringAscii == true</test>
			<error>
				<message>Entry U in URLAlias has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>UType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AURLAlias">
			<id specification="PDF_1_4" clause="URLAlias-U" testNumber="7"/>
			<description>Entry U in URLAlias is required</description>
			<test>containsU == true</test>
			<error>
				<message>Entry U in URLAlias is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences" testNumber="1"/>
			<description>ViewerPreferences shall not contain entries except CenterWindow, Direction, DisplayDocTitle, FitWindow, HideMenubar, HideToolbar, HideWindowUI, NonFullScreenPageMode, PrintArea, PrintClip, ViewArea, ViewClip</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CenterWindow' &amp;&amp; elem != 'Direction' &amp;&amp; elem != 'DisplayDocTitle' &amp;&amp; elem != 'Duplex' &amp;&amp; elem != 'Enforce' &amp;&amp; elem != 'FitWindow' &amp;&amp; elem != 'HideMenubar' &amp;&amp; elem != 'HideToolbar' &amp;&amp; elem != 'HideWindowUI' &amp;&amp; elem != 'NonFullScreenPageMode' &amp;&amp; elem != 'NumCopies' &amp;&amp; elem != 'PickTrayByPDFSize' &amp;&amp; elem != 'PrintArea' &amp;&amp; elem != 'PrintClip' &amp;&amp; elem != 'PrintPageRange' &amp;&amp; elem != 'PrintScaling' &amp;&amp; elem != 'ViewArea' &amp;&amp; elem != 'ViewClip' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>ViewerPreferences contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CenterWindow' &amp;&amp; elem != 'Direction' &amp;&amp; elem != 'DisplayDocTitle' &amp;&amp; elem != 'Duplex' &amp;&amp; elem != 'Enforce' &amp;&amp; elem != 'FitWindow' &amp;&amp; elem != 'HideMenubar' &amp;&amp; elem != 'HideToolbar' &amp;&amp; elem != 'HideWindowUI' &amp;&amp; elem != 'NonFullScreenPageMode' &amp;&amp; elem != 'NumCopies' &amp;&amp; elem != 'PickTrayByPDFSize' &amp;&amp; elem != 'PrintArea' &amp;&amp; elem != 'PrintClip' &amp;&amp; elem != 'PrintPageRange' &amp;&amp; elem != 'PrintScaling' &amp;&amp; elem != 'ViewArea' &amp;&amp; elem != 'ViewClip' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences" testNumber="22"/>
			<description>ViewerPreferences shall not contain entries Duplex, Enforce, NumCopies, PickTrayByPDFSize, PrintPageRange, PrintScaling in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'Duplex' || elem == 'Enforce' || elem == 'NumCopies' || elem == 'PickTrayByPDFSize' || elem == 'PrintPageRange' || elem == 'PrintScaling').length == 0</test>
			<error>
				<message>ViewerPreferences contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'Duplex' || elem == 'Enforce' || elem == 'NumCopies' || elem == 'PickTrayByPDFSize' || elem == 'PrintPageRange' || elem == 'PrintScaling').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-CenterWindow" testNumber="8"/>
			<description>Entry CenterWindow in ViewerPreferences shall have type Boolean</description>
			<test>containsCenterWindow == false || CenterWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry CenterWindow in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>CenterWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-Direction" testNumber="8"/>
			<description>Entry Direction in ViewerPreferences shall have type Name</description>
			<test>containsDirection == false || DirectionHasTypeName == true</test>
			<error>
				<message>Entry Direction in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>DirectionType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-Direction-Name" testNumber="6"/>
			<description>Entry Direction with type Name in ViewerPreferences shall have one of values: L2R, R2L</description>
			<test>DirectionHasTypeName != true || DirectionNameValue == "L2R" || DirectionNameValue == "R2L"</test>
			<error>
				<message>Entry Direction with type Name in ViewerPreferences has incorrect value %1 instead of L2R, R2L</message>
				<arguments>
					<argument>DirectionNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-DisplayDocTitle" testNumber="8"/>
			<description>Entry DisplayDocTitle in ViewerPreferences shall have type Boolean</description>
			<test>containsDisplayDocTitle == false || DisplayDocTitleHasTypeBoolean == true</test>
			<error>
				<message>Entry DisplayDocTitle in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>DisplayDocTitleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-FitWindow" testNumber="8"/>
			<description>Entry FitWindow in ViewerPreferences shall have type Boolean</description>
			<test>containsFitWindow == false || FitWindowHasTypeBoolean == true</test>
			<error>
				<message>Entry FitWindow in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>FitWindowType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-HideMenubar" testNumber="8"/>
			<description>Entry HideMenubar in ViewerPreferences shall have type Boolean</description>
			<test>containsHideMenubar == false || HideMenubarHasTypeBoolean == true</test>
			<error>
				<message>Entry HideMenubar in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideMenubarType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-HideToolbar" testNumber="8"/>
			<description>Entry HideToolbar in ViewerPreferences shall have type Boolean</description>
			<test>containsHideToolbar == false || HideToolbarHasTypeBoolean == true</test>
			<error>
				<message>Entry HideToolbar in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideToolbarType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-HideWindowUI" testNumber="8"/>
			<description>Entry HideWindowUI in ViewerPreferences shall have type Boolean</description>
			<test>containsHideWindowUI == false || HideWindowUIHasTypeBoolean == true</test>
			<error>
				<message>Entry HideWindowUI in ViewerPreferences has type %1 instead of type Boolean</message>
				<arguments>
					<argument>HideWindowUIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-NonFullScreenPageMode" testNumber="8"/>
			<description>Entry NonFullScreenPageMode in ViewerPreferences shall have type Name</description>
			<test>containsNonFullScreenPageMode == false || NonFullScreenPageModeHasTypeName == true</test>
			<error>
				<message>Entry NonFullScreenPageMode in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>NonFullScreenPageModeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-NonFullScreenPageMode-Name" testNumber="6"/>
			<description>Entry NonFullScreenPageMode with type Name in ViewerPreferences shall have one of values: UseOutlines, UseThumbs, UseOC, UseNone</description>
			<test>NonFullScreenPageModeHasTypeName != true || NonFullScreenPageModeNameValue == "UseNone" || NonFullScreenPageModeNameValue == "UseOutlines" || NonFullScreenPageModeNameValue == "UseThumbs" || NonFullScreenPageModeNameValue == "UseOC"</test>
			<error>
				<message>Entry NonFullScreenPageMode with type Name in ViewerPreferences has incorrect value %1 instead of UseOutlines, UseThumbs, UseOC, UseNone</message>
				<arguments>
					<argument>NonFullScreenPageModeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-PrintArea" testNumber="8"/>
			<description>Entry PrintArea in ViewerPreferences shall have type Name</description>
			<test>containsPrintArea == false || PrintAreaHasTypeName == true</test>
			<error>
				<message>Entry PrintArea in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>PrintAreaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-PrintArea-Name" testNumber="6"/>
			<description>Entry PrintArea with type Name in ViewerPreferences shall have one of values: CropBox, BleedBox, TrimBox, MediaBox, ArtBox</description>
			<test>PrintAreaHasTypeName != true || PrintAreaNameValue == "MediaBox" || PrintAreaNameValue == "CropBox" || PrintAreaNameValue == "BleedBox" || PrintAreaNameValue == "TrimBox" || PrintAreaNameValue == "ArtBox"</test>
			<error>
				<message>Entry PrintArea with type Name in ViewerPreferences has incorrect value %1 instead of CropBox, BleedBox, TrimBox, MediaBox, ArtBox</message>
				<arguments>
					<argument>PrintAreaNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-PrintClip" testNumber="8"/>
			<description>Entry PrintClip in ViewerPreferences shall have type Name</description>
			<test>containsPrintClip == false || PrintClipHasTypeName == true</test>
			<error>
				<message>Entry PrintClip in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>PrintClipType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-PrintClip-Name" testNumber="6"/>
			<description>Entry PrintClip with type Name in ViewerPreferences shall have one of values: CropBox, BleedBox, TrimBox, MediaBox, ArtBox</description>
			<test>PrintClipHasTypeName != true || PrintClipNameValue == "MediaBox" || PrintClipNameValue == "CropBox" || PrintClipNameValue == "BleedBox" || PrintClipNameValue == "TrimBox" || PrintClipNameValue == "ArtBox"</test>
			<error>
				<message>Entry PrintClip with type Name in ViewerPreferences has incorrect value %1 instead of CropBox, BleedBox, TrimBox, MediaBox, ArtBox</message>
				<arguments>
					<argument>PrintClipNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-ViewArea" testNumber="8"/>
			<description>Entry ViewArea in ViewerPreferences shall have type Name</description>
			<test>containsViewArea == false || ViewAreaHasTypeName == true</test>
			<error>
				<message>Entry ViewArea in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>ViewAreaType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-ViewArea-Name" testNumber="6"/>
			<description>Entry ViewArea with type Name in ViewerPreferences shall have one of values: CropBox, BleedBox, TrimBox, MediaBox, ArtBox</description>
			<test>ViewAreaHasTypeName != true || ViewAreaNameValue == "MediaBox" || ViewAreaNameValue == "CropBox" || ViewAreaNameValue == "BleedBox" || ViewAreaNameValue == "TrimBox" || ViewAreaNameValue == "ArtBox"</test>
			<error>
				<message>Entry ViewArea with type Name in ViewerPreferences has incorrect value %1 instead of CropBox, BleedBox, TrimBox, MediaBox, ArtBox</message>
				<arguments>
					<argument>ViewAreaNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-ViewClip" testNumber="8"/>
			<description>Entry ViewClip in ViewerPreferences shall have type Name</description>
			<test>containsViewClip == false || ViewClipHasTypeName == true</test>
			<error>
				<message>Entry ViewClip in ViewerPreferences has type %1 instead of type Name</message>
				<arguments>
					<argument>ViewClipType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AViewerPreferences">
			<id specification="PDF_1_4" clause="ViewerPreferences-ViewClip-Name" testNumber="6"/>
			<description>Entry ViewClip with type Name in ViewerPreferences shall have one of values: CropBox, BleedBox, TrimBox, MediaBox, ArtBox</description>
			<test>ViewClipHasTypeName != true || ViewClipNameValue == "MediaBox" || ViewClipNameValue == "CropBox" || ViewClipNameValue == "BleedBox" || ViewClipNameValue == "TrimBox" || ViewClipNameValue == "ArtBox"</test>
			<error>
				<message>Entry ViewClip with type Name in ViewerPreferences has incorrect value %1 instead of CropBox, BleedBox, TrimBox, MediaBox, ArtBox</message>
				<arguments>
					<argument>ViewClipNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand" testNumber="1"/>
			<description>WebCaptureCommand shall not contain entries except CT, F, H, L, P, S, URL</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'P' &amp;&amp; elem != 'S' &amp;&amp; elem != 'URL' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>WebCaptureCommand contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'F' &amp;&amp; elem != 'H' &amp;&amp; elem != 'L' &amp;&amp; elem != 'P' &amp;&amp; elem != 'S' &amp;&amp; elem != 'URL' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-CT" testNumber="8"/>
			<description>Entry CT in WebCaptureCommand shall have type StringAscii</description>
			<test>containsCT == false || CTHasTypeStringAscii == true</test>
			<error>
				<message>Entry CT in WebCaptureCommand has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>CTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-F" testNumber="8"/>
			<description>Entry F in WebCaptureCommand shall have type Bitmask</description>
			<test>containsF == false || FHasTypeBitmask == true</test>
			<error>
				<message>Entry F in WebCaptureCommand has type %1 instead of type Bitmask</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-F-Bitmask" testNumber="9"/>
			<description>Entry F with type Bitmask in WebCaptureCommand shall satisfy special case: fn:Eval(fn:BitsClear(4, 32))</description>
			<test>FHasTypeBitmask != true || ((FBitmaskValue &gt;&gt; 3 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 4 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 5 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 6 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 7 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 8 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 9 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 10 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 11 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 12 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 13 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 14 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 15 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 16 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 17 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 18 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 19 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 20 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 21 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 22 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 23 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 24 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 25 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 26 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 27 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 28 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 29 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 30 &amp; 1) == 0 &amp;&amp; (FBitmaskValue &gt;&gt; 31 &amp; 1) == 0)</test>
			<error>
				<message>Entry F with type Bitmask in WebCaptureCommand does not satisfy special case: fn:Eval(fn:BitsClear(4, 32))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-H" testNumber="8"/>
			<description>Entry H in WebCaptureCommand shall have type String</description>
			<test>containsH == false || HHasTypeString == true</test>
			<error>
				<message>Entry H in WebCaptureCommand has type %1 instead of type String</message>
				<arguments>
					<argument>HType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-L" testNumber="8"/>
			<description>Entry L in WebCaptureCommand shall have type Integer</description>
			<test>containsL == false || LHasTypeInteger == true</test>
			<error>
				<message>Entry L in WebCaptureCommand has type %1 instead of type Integer</message>
				<arguments>
					<argument>LType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-L-Integer" testNumber="9"/>
			<description>Entry L with type Integer in WebCaptureCommand shall satisfy special case: fn:Eval(@L &gt;= 1)</description>
			<test>LHasTypeInteger != true || (LIntegerValue &gt;= 1)</test>
			<error>
				<message>Entry L with type Integer in WebCaptureCommand does not satisfy special case: fn:Eval(@L &gt;= 1)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-P" testNumber="8"/>
			<description>Entry P in WebCaptureCommand shall have one of types: Stream, String</description>
			<test>containsP == false || PHasTypeStream == true || PHasTypeString == true</test>
			<error>
				<message>Entry P in WebCaptureCommand has type %1 instead of one of types: Stream, String</message>
				<arguments>
					<argument>PType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-P-Stream" testNumber="10"/>
			<description>Entry P with type Stream in WebCaptureCommand shall be indirect</description>
			<test>PHasTypeStream != true || isPIndirect == true</test>
			<error>
				<message>Entry P with type Stream in WebCaptureCommand is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-S" testNumber="8"/>
			<description>Entry S in WebCaptureCommand shall have type Dictionary</description>
			<test>containsS == false || SHasTypeDictionary == true</test>
			<error>
				<message>Entry S in WebCaptureCommand has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-URL" testNumber="8"/>
			<description>Entry URL in WebCaptureCommand shall have type StringAscii</description>
			<test>containsURL == false || URLHasTypeStringAscii == true</test>
			<error>
				<message>Entry URL in WebCaptureCommand has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>URLType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommand">
			<id specification="PDF_1_4" clause="WebCaptureCommand-URL" testNumber="7"/>
			<description>Entry URL in WebCaptureCommand is required</description>
			<test>containsURL == true</test>
			<error>
				<message>Entry URL in WebCaptureCommand is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommandSettings">
			<id specification="PDF_1_4" clause="WebCaptureCommandSettings" testNumber="1"/>
			<description>WebCaptureCommandSettings shall not contain entries except C, G</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'G' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>WebCaptureCommandSettings contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'G' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommandSettings">
			<id specification="PDF_1_4" clause="WebCaptureCommandSettings-C" testNumber="8"/>
			<description>Entry C in WebCaptureCommandSettings shall have type Dictionary</description>
			<test>containsC == false || CHasTypeDictionary == true</test>
			<error>
				<message>Entry C in WebCaptureCommandSettings has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureCommandSettings">
			<id specification="PDF_1_4" clause="WebCaptureCommandSettings-G" testNumber="8"/>
			<description>Entry G in WebCaptureCommandSettings shall have type Dictionary</description>
			<test>containsG == false || GHasTypeDictionary == true</test>
			<error>
				<message>Entry G in WebCaptureCommandSettings has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>GType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet" testNumber="1"/>
			<description>WebCaptureImageSet shall not contain entries except CT, ID, O, R, S, SI, TS, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'O' &amp;&amp; elem != 'R' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SI' &amp;&amp; elem != 'TS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>WebCaptureImageSet contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'O' &amp;&amp; elem != 'R' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SI' &amp;&amp; elem != 'TS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-CT" testNumber="8"/>
			<description>Entry CT in WebCaptureImageSet shall have type String</description>
			<test>containsCT == false || CTHasTypeString == true</test>
			<error>
				<message>Entry CT in WebCaptureImageSet has type %1 instead of type String</message>
				<arguments>
					<argument>CTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-ID" testNumber="8"/>
			<description>Entry ID in WebCaptureImageSet shall have type String</description>
			<test>containsID == false || entryIDHasTypeString == true</test>
			<error>
				<message>Entry ID in WebCaptureImageSet has type %1 instead of type String</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-ID" testNumber="7"/>
			<description>Entry ID in WebCaptureImageSet is required</description>
			<test>containsID == true</test>
			<error>
				<message>Entry ID in WebCaptureImageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-O" testNumber="8"/>
			<description>Entry O in WebCaptureImageSet shall have type Array</description>
			<test>containsO == false || OHasTypeArray == true</test>
			<error>
				<message>Entry O in WebCaptureImageSet has type %1 instead of type Array</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-O" testNumber="7"/>
			<description>Entry O in WebCaptureImageSet is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in WebCaptureImageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-R" testNumber="8"/>
			<description>Entry R in WebCaptureImageSet shall have one of types: Array, Integer</description>
			<test>containsR == false || RHasTypeArray == true || RHasTypeInteger == true</test>
			<error>
				<message>Entry R in WebCaptureImageSet has type %1 instead of one of types: Array, Integer</message>
				<arguments>
					<argument>RType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-R" testNumber="7"/>
			<description>Entry R in WebCaptureImageSet is required</description>
			<test>containsR == true</test>
			<error>
				<message>Entry R in WebCaptureImageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-R-Array" testNumber="9"/>
			<description>Entry R with type Array in WebCaptureImageSet shall satisfy special case: fn:Eval(fn:ArrayLength(O) == fn:ArrayLength(R))</description>
			<test>RHasTypeArray != true || (OHasTypeArray == false || OArraySize == RArraySize)</test>
			<error>
				<message>Entry R with type Array in WebCaptureImageSet does not satisfy special case: fn:Eval(fn:ArrayLength(O) == fn:ArrayLength(R))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-R-Integer" testNumber="9"/>
			<description>Entry R with type Integer in WebCaptureImageSet shall satisfy special case: fn:Eval(@R &gt; 0)</description>
			<test>RHasTypeInteger != true || (RIntegerValue &gt; 0)</test>
			<error>
				<message>Entry R with type Integer in WebCaptureImageSet does not satisfy special case: fn:Eval(@R &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-S" testNumber="8"/>
			<description>Entry S in WebCaptureImageSet shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in WebCaptureImageSet has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-S" testNumber="7"/>
			<description>Entry S in WebCaptureImageSet is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in WebCaptureImageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-S-Name" testNumber="6"/>
			<description>Entry S with type Name in WebCaptureImageSet shall have value SIS</description>
			<test>SHasTypeName != true || SNameValue == "SIS"</test>
			<error>
				<message>Entry S with type Name in WebCaptureImageSet has incorrect value %1 instead of SIS</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-SI" testNumber="8"/>
			<description>Entry SI in WebCaptureImageSet shall have one of types: Array, Dictionary</description>
			<test>containsSI == false || SIHasTypeArray == true || SIHasTypeDictionary == true</test>
			<error>
				<message>Entry SI in WebCaptureImageSet has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>SIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-SI" testNumber="7"/>
			<description>Entry SI in WebCaptureImageSet is required</description>
			<test>containsSI == true</test>
			<error>
				<message>Entry SI in WebCaptureImageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-TS" testNumber="8"/>
			<description>Entry TS in WebCaptureImageSet shall have type Date</description>
			<test>containsTS == false || TSHasTypeDate == true</test>
			<error>
				<message>Entry TS in WebCaptureImageSet has type %1 instead of type Date</message>
				<arguments>
					<argument>TSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-Type" testNumber="8"/>
			<description>Entry Type in WebCaptureImageSet shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in WebCaptureImageSet has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureImageSet">
			<id specification="PDF_1_4" clause="WebCaptureImageSet-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in WebCaptureImageSet shall have value SpiderContentSet</description>
			<test>TypeHasTypeName != true || TypeNameValue == "SpiderContentSet"</test>
			<error>
				<message>Entry Type with type Name in WebCaptureImageSet has incorrect value %1 instead of SpiderContentSet</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureInfo">
			<id specification="PDF_1_4" clause="WebCaptureInfo" testNumber="1"/>
			<description>WebCaptureInfo shall not contain entries except C, V</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>WebCaptureInfo contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'C' &amp;&amp; elem != 'V' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureInfo">
			<id specification="PDF_1_4" clause="WebCaptureInfo-C" testNumber="8"/>
			<description>Entry C in WebCaptureInfo shall have type Array</description>
			<test>containsC == false || CHasTypeArray == true</test>
			<error>
				<message>Entry C in WebCaptureInfo has type %1 instead of type Array</message>
				<arguments>
					<argument>CType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureInfo">
			<id specification="PDF_1_4" clause="WebCaptureInfo-V" testNumber="8"/>
			<description>Entry V in WebCaptureInfo shall have type Number</description>
			<test>containsV == false || VHasTypeNumber == true</test>
			<error>
				<message>Entry V in WebCaptureInfo has type %1 instead of type Number</message>
				<arguments>
					<argument>VType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureInfo">
			<id specification="PDF_1_4" clause="WebCaptureInfo-V" testNumber="7"/>
			<description>Entry V in WebCaptureInfo is required</description>
			<test>containsV == true</test>
			<error>
				<message>Entry V in WebCaptureInfo is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCaptureInfo">
			<id specification="PDF_1_4" clause="WebCaptureInfo-V-Number" testNumber="6"/>
			<description>Entry V with type Number in WebCaptureInfo shall have value 1</description>
			<test>VHasTypeNumber != true || VNumberValue == 1</test>
			<error>
				<message>Entry V with type Number in WebCaptureInfo has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>VNumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet" testNumber="1"/>
			<description>WebCapturePageSet shall not contain entries except CT, ID, O, S, SI, T, TID, TS, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'O' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SI' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TID' &amp;&amp; elem != 'TS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>WebCapturePageSet contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'CT' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'O' &amp;&amp; elem != 'S' &amp;&amp; elem != 'SI' &amp;&amp; elem != 'T' &amp;&amp; elem != 'TID' &amp;&amp; elem != 'TS' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-CT" testNumber="8"/>
			<description>Entry CT in WebCapturePageSet shall have type StringAscii</description>
			<test>containsCT == false || CTHasTypeStringAscii == true</test>
			<error>
				<message>Entry CT in WebCapturePageSet has type %1 instead of type StringAscii</message>
				<arguments>
					<argument>CTType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-ID" testNumber="8"/>
			<description>Entry ID in WebCapturePageSet shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in WebCapturePageSet has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-ID" testNumber="7"/>
			<description>Entry ID in WebCapturePageSet is required</description>
			<test>containsID == true</test>
			<error>
				<message>Entry ID in WebCapturePageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-O" testNumber="8"/>
			<description>Entry O in WebCapturePageSet shall have type Array</description>
			<test>containsO == false || OHasTypeArray == true</test>
			<error>
				<message>Entry O in WebCapturePageSet has type %1 instead of type Array</message>
				<arguments>
					<argument>OType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-O" testNumber="7"/>
			<description>Entry O in WebCapturePageSet is required</description>
			<test>containsO == true</test>
			<error>
				<message>Entry O in WebCapturePageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-S" testNumber="8"/>
			<description>Entry S in WebCapturePageSet shall have type Name</description>
			<test>containsS == false || SHasTypeName == true</test>
			<error>
				<message>Entry S in WebCapturePageSet has type %1 instead of type Name</message>
				<arguments>
					<argument>SType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-S" testNumber="7"/>
			<description>Entry S in WebCapturePageSet is required</description>
			<test>containsS == true</test>
			<error>
				<message>Entry S in WebCapturePageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-S-Name" testNumber="6"/>
			<description>Entry S with type Name in WebCapturePageSet shall have value SPS</description>
			<test>SHasTypeName != true || SNameValue == "SPS"</test>
			<error>
				<message>Entry S with type Name in WebCapturePageSet has incorrect value %1 instead of SPS</message>
				<arguments>
					<argument>SNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-SI" testNumber="8"/>
			<description>Entry SI in WebCapturePageSet shall have one of types: Array, Dictionary</description>
			<test>containsSI == false || SIHasTypeArray == true || SIHasTypeDictionary == true</test>
			<error>
				<message>Entry SI in WebCapturePageSet has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>SIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-SI" testNumber="7"/>
			<description>Entry SI in WebCapturePageSet is required</description>
			<test>containsSI == true</test>
			<error>
				<message>Entry SI in WebCapturePageSet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-T" testNumber="8"/>
			<description>Entry T in WebCapturePageSet shall have type StringText</description>
			<test>containsT == false || THasTypeStringText == true</test>
			<error>
				<message>Entry T in WebCapturePageSet has type %1 instead of type StringText</message>
				<arguments>
					<argument>TType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-TID" testNumber="8"/>
			<description>Entry TID in WebCapturePageSet shall have type StringByte</description>
			<test>containsTID == false || TIDHasTypeStringByte == true</test>
			<error>
				<message>Entry TID in WebCapturePageSet has type %1 instead of type StringByte</message>
				<arguments>
					<argument>TIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-TS" testNumber="8"/>
			<description>Entry TS in WebCapturePageSet shall have type Date</description>
			<test>containsTS == false || TSHasTypeDate == true</test>
			<error>
				<message>Entry TS in WebCapturePageSet has type %1 instead of type Date</message>
				<arguments>
					<argument>TSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-Type" testNumber="8"/>
			<description>Entry Type in WebCapturePageSet shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in WebCapturePageSet has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWebCapturePageSet">
			<id specification="PDF_1_4" clause="WebCapturePageSet-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in WebCapturePageSet shall have value SpiderContentSet</description>
			<test>TypeHasTypeName != true || TypeNameValue == "SpiderContentSet"</test>
			<error>
				<message>Entry Type with type Name in WebCapturePageSet has incorrect value %1 instead of SpiderContentSet</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray" testNumber="2"/>
			<description>WhitepointArray shall contain exactly 3 elements</description>
			<test>size == 3</test>
			<error>
				<message>WhitepointArray contains %1 element(s) instead of 3</message>
				<arguments>
					<argument>size</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-0" testNumber="8"/>
			<description>Entry 0 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 0 || entry0HasTypeNumber == true</test>
			<error>
				<message>Entry 0 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry0Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-0-Number" testNumber="14"/>
			<description>Entry 0 with type Number in WhitepointArray shall satisfy possible value predicate: fn:Eval(@0 &gt; 0)</description>
			<test>entry0HasTypeNumber != true || entry0NumberValue &gt; 0</test>
			<error>
				<message>Entry 0 with type Number in WhitepointArray does not satisfy possible value predicate: fn:Eval(@0 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-1" testNumber="8"/>
			<description>Entry 1 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 1 || entry1HasTypeNumber == true</test>
			<error>
				<message>Entry 1 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-1-Number" testNumber="6"/>
			<description>Entry 1 with type Number in WhitepointArray shall have value 1</description>
			<test>entry1HasTypeNumber != true || entry1NumberValue == 1</test>
			<error>
				<message>Entry 1 with type Number in WhitepointArray has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>entry1NumberValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-2" testNumber="8"/>
			<description>Entry 2 in WhitepointArray shall have type Number</description>
			<test>size &lt;= 2 || entry2HasTypeNumber == true</test>
			<error>
				<message>Entry 2 in WhitepointArray has type %1 instead of type Number</message>
				<arguments>
					<argument>entry2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AWhitepointArray">
			<id specification="PDF_1_4" clause="WhitepointArray-2-Number" testNumber="14"/>
			<description>Entry 2 with type Number in WhitepointArray shall satisfy possible value predicate: fn:Eval(@2 &gt; 0)</description>
			<test>entry2HasTypeNumber != true || entry2NumberValue &gt; 0</test>
			<error>
				<message>Entry 2 with type Number in WhitepointArray does not satisfy possible value predicate: fn:Eval(@2 &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS" testNumber="1"/>
			<description>XObjectFormPS shall not contain entries except DecodeParms, F, FDecodeParms, FFilter, Filter, Length, Level1, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormPS contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormPS shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormPS is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormPS shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPS has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-DecodeParms" testNumber="5"/>
			<description>Entry DecodeParms in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsDecodeParms == false</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-F" testNumber="8"/>
			<description>Entry F in XObjectFormPS shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormPS has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-F" testNumber="5"/>
			<description>Entry F in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsF == false</test>
			<error>
				<message>Entry F in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormPS shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormPS is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormPS shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPS has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FDecodeParms" testNumber="5"/>
			<description>Entry FDecodeParms in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsFDecodeParms == false</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormPS shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormPS has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FFilter" testNumber="5"/>
			<description>Entry FFilter in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsFFilter == false</test>
			<error>
				<message>Entry FFilter in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormPS shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormPS has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormPS shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormPS has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Filter" testNumber="5"/>
			<description>Entry Filter in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsFilter == false</test>
			<error>
				<message>Entry Filter in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormPS shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormPS does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormPS shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormPS has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormPS shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormPS has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormPS is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormPS is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Length" testNumber="5"/>
			<description>Entry Length in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsLength == false</test>
			<error>
				<message>Entry Length in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Level1" testNumber="8"/>
			<description>Entry Level1 in XObjectFormPS shall have type Stream</description>
			<test>containsLevel1 == false || Level1HasTypeStream == true</test>
			<error>
				<message>Entry Level1 in XObjectFormPS has type %1 instead of type Stream</message>
				<arguments>
					<argument>Level1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Level1" testNumber="5"/>
			<description>Entry Level1 in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsLevel1 == false</test>
			<error>
				<message>Entry Level1 in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Level1-Stream" testNumber="10"/>
			<description>Entry Level1 with type Stream in XObjectFormPS shall be indirect</description>
			<test>Level1HasTypeStream != true || isLevel1Indirect == true</test>
			<error>
				<message>Entry Level1 with type Stream in XObjectFormPS is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormPS shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPS has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormPS is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPS is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Subtype" testNumber="5"/>
			<description>Entry Subtype in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsSubtype == false</test>
			<error>
				<message>Entry Subtype in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormPS shall have value PS</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "PS"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormPS has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormPS shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormPS has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Type" testNumber="5"/>
			<description>Entry Type in XObjectFormPS is deprecated since PDF 1.3</description>
			<test>containsType == false</test>
			<error>
				<message>Entry Type in XObjectFormPS is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPS">
			<id specification="PDF_1_4" clause="XObjectFormPS-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormPS shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormPS has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough" testNumber="1"/>
			<description>XObjectFormPSpassthrough shall not contain entries except BBox, DecodeParms, F, FDecodeParms, FFilter, Filter, FormType, Length, Level1, Matrix, PS, Subtype, Subtype2, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PS' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Subtype2' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormPSpassthrough contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'BBox' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Level1' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'PS' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Subtype2' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormPSpassthrough shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormPSpassthrough has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormPSpassthrough is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-BBox" testNumber="5"/>
			<description>Entry BBox in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsBBox == false</test>
			<error>
				<message>Entry BBox in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormPSpassthrough shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormPSpassthrough is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormPSpassthrough shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-DecodeParms" testNumber="5"/>
			<description>Entry DecodeParms in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsDecodeParms == false</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-F" testNumber="8"/>
			<description>Entry F in XObjectFormPSpassthrough shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormPSpassthrough has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-F" testNumber="5"/>
			<description>Entry F in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsF == false</test>
			<error>
				<message>Entry F in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormPSpassthrough shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormPSpassthrough is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormPSpassthrough shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FDecodeParms" testNumber="5"/>
			<description>Entry FDecodeParms in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsFDecodeParms == false</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormPSpassthrough shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FFilter" testNumber="5"/>
			<description>Entry FFilter in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsFFilter == false</test>
			<error>
				<message>Entry FFilter in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormPSpassthrough shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormPSpassthrough shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormPSpassthrough has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Filter" testNumber="5"/>
			<description>Entry Filter in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsFilter == false</test>
			<error>
				<message>Entry Filter in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormPSpassthrough shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormPSpassthrough does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormPSpassthrough shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormPSpassthrough shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormPSpassthrough has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FormType" testNumber="5"/>
			<description>Entry FormType in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsFormType == false</test>
			<error>
				<message>Entry FormType in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormPSpassthrough shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormPSpassthrough has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormPSpassthrough shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormPSpassthrough has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormPSpassthrough is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Length" testNumber="5"/>
			<description>Entry Length in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsLength == false</test>
			<error>
				<message>Entry Length in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Level1" testNumber="8"/>
			<description>Entry Level1 in XObjectFormPSpassthrough shall have type Stream</description>
			<test>containsLevel1 == false || Level1HasTypeStream == true</test>
			<error>
				<message>Entry Level1 in XObjectFormPSpassthrough has type %1 instead of type Stream</message>
				<arguments>
					<argument>Level1Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Level1" testNumber="5"/>
			<description>Entry Level1 in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsLevel1 == false</test>
			<error>
				<message>Entry Level1 in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Level1-Stream" testNumber="10"/>
			<description>Entry Level1 with type Stream in XObjectFormPSpassthrough shall be indirect</description>
			<test>Level1HasTypeStream != true || isLevel1Indirect == true</test>
			<error>
				<message>Entry Level1 with type Stream in XObjectFormPSpassthrough is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormPSpassthrough shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormPSpassthrough has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Matrix" testNumber="5"/>
			<description>Entry Matrix in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsMatrix == false</test>
			<error>
				<message>Entry Matrix in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-PS" testNumber="8"/>
			<description>Entry PS in XObjectFormPSpassthrough shall have type Stream</description>
			<test>containsPS == false || PSHasTypeStream == true</test>
			<error>
				<message>Entry PS in XObjectFormPSpassthrough has type %1 instead of type Stream</message>
				<arguments>
					<argument>PSType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-PS" testNumber="7"/>
			<description>Entry PS in XObjectFormPSpassthrough is required</description>
			<test>containsPS == true</test>
			<error>
				<message>Entry PS in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-PS" testNumber="5"/>
			<description>Entry PS in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsPS == false</test>
			<error>
				<message>Entry PS in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-PS-Stream" testNumber="10"/>
			<description>Entry PS with type Stream in XObjectFormPSpassthrough shall be indirect</description>
			<test>PSHasTypeStream != true || isPSIndirect == true</test>
			<error>
				<message>Entry PS with type Stream in XObjectFormPSpassthrough is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormPSpassthrough is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype" testNumber="5"/>
			<description>Entry Subtype in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsSubtype == false</test>
			<error>
				<message>Entry Subtype in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormPSpassthrough shall have value PS</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "PS"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype2" testNumber="8"/>
			<description>Entry Subtype2 in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsSubtype2 == false || Subtype2HasTypeName == true</test>
			<error>
				<message>Entry Subtype2 in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>Subtype2Type</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype2" testNumber="7"/>
			<description>Entry Subtype2 in XObjectFormPSpassthrough is required</description>
			<test>containsSubtype2 == true</test>
			<error>
				<message>Entry Subtype2 in XObjectFormPSpassthrough is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype2" testNumber="5"/>
			<description>Entry Subtype2 in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsSubtype2 == false</test>
			<error>
				<message>Entry Subtype2 in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Subtype2-Name" testNumber="6"/>
			<description>Entry Subtype2 with type Name in XObjectFormPSpassthrough shall have value PS</description>
			<test>Subtype2HasTypeName != true || Subtype2NameValue == "PS"</test>
			<error>
				<message>Entry Subtype2 with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of PS</message>
				<arguments>
					<argument>Subtype2NameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormPSpassthrough shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormPSpassthrough has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Type" testNumber="5"/>
			<description>Entry Type in XObjectFormPSpassthrough is deprecated since PDF 1.3</description>
			<test>containsType == false</test>
			<error>
				<message>Entry Type in XObjectFormPSpassthrough is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPSpassthrough">
			<id specification="PDF_1_4" clause="XObjectFormPSpassthrough-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormPSpassthrough shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormPSpassthrough has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark" testNumber="1"/>
			<description>XObjectFormPrinterMark shall not contain entries except BBox, Colorants, DecodeParms, F, FDecodeParms, FFilter, Filter, FormType, Group, LastModified, Length, MarkStyle, Matrix, Metadata, Name, OPI, PieceInfo, Ref, Resources, StructParent, StructParents, Subtype, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Colorants' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'MarkStyle' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormPrinterMark contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'Colorants' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'MarkStyle' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark" testNumber="22"/>
			<description>XObjectFormPrinterMark shall not contain entries AF, DL, Measure, OC, PtData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').length == 0</test>
			<error>
				<message>XObjectFormPrinterMark contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormPrinterMark shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormPrinterMark has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormPrinterMark is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Colorants" testNumber="8"/>
			<description>Entry Colorants in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsColorants == false || ColorantsHasTypeDictionary == true</test>
			<error>
				<message>Entry Colorants in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ColorantsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormPrinterMark shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormPrinterMark is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormPrinterMark shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormPrinterMark has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormPrinterMark shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormPrinterMark does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-F" testNumber="8"/>
			<description>Entry F in XObjectFormPrinterMark shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormPrinterMark has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormPrinterMark shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormPrinterMark is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormPrinterMark shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormPrinterMark has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormPrinterMark shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormPrinterMark does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormPrinterMark shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormPrinterMark has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormPrinterMark shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormPrinterMark does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormPrinterMark shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormPrinterMark has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormPrinterMark shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormPrinterMark has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormPrinterMark shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormPrinterMark does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormPrinterMark shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormPrinterMark has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormPrinterMark shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormPrinterMark has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormPrinterMark shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormPrinterMark has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Group" testNumber="8"/>
			<description>Entry Group in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsGroup == false || GroupHasTypeDictionary == true</test>
			<error>
				<message>Entry Group in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>GroupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-LastModified" testNumber="8"/>
			<description>Entry LastModified in XObjectFormPrinterMark shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in XObjectFormPrinterMark has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-LastModified" testNumber="11"/>
			<description>Entry LastModified in XObjectFormPrinterMark is required, when fn:IsPresent(PieceInfo)</description>
			<test>containsLastModified == true || (containsPieceInfo != true)</test>
			<error>
				<message>Entry LastModified in XObjectFormPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormPrinterMark shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormPrinterMark has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormPrinterMark is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-MarkStyle" testNumber="8"/>
			<description>Entry MarkStyle in XObjectFormPrinterMark shall have type StringText</description>
			<test>containsMarkStyle == false || MarkStyleHasTypeStringText == true</test>
			<error>
				<message>Entry MarkStyle in XObjectFormPrinterMark has type %1 instead of type StringText</message>
				<arguments>
					<argument>MarkStyleType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormPrinterMark shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormPrinterMark has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectFormPrinterMark shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectFormPrinterMark has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectFormPrinterMark shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectFormPrinterMark is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Name" testNumber="8"/>
			<description>Entry Name in XObjectFormPrinterMark shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectFormPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectFormPrinterMark shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectFormPrinterMark is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-PieceInfo" testNumber="8"/>
			<description>Entry PieceInfo in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsPieceInfo == false || PieceInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry PieceInfo in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PieceInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-PieceInfo-Dictionary" testNumber="9"/>
			<description>Entry PieceInfo with type Dictionary in XObjectFormPrinterMark shall satisfy special case: fn:Eval(fn:IsPresent(LastModified))</description>
			<test>PieceInfoHasTypeDictionary != true || (containsLastModified == true)</test>
			<error>
				<message>Entry PieceInfo with type Dictionary in XObjectFormPrinterMark does not satisfy special case: fn:Eval(fn:IsPresent(LastModified))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Ref" testNumber="8"/>
			<description>Entry Ref in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsRef == false || RefHasTypeDictionary == true</test>
			<error>
				<message>Entry Ref in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RefType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Resources" testNumber="8"/>
			<description>Entry Resources in XObjectFormPrinterMark shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in XObjectFormPrinterMark has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-StructParent" testNumber="8"/>
			<description>Entry StructParent in XObjectFormPrinterMark shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in XObjectFormPrinterMark has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-StructParents" testNumber="8"/>
			<description>Entry StructParents in XObjectFormPrinterMark shall have type Integer</description>
			<test>containsStructParents == false || StructParentsHasTypeInteger == true</test>
			<error>
				<message>Entry StructParents in XObjectFormPrinterMark has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormPrinterMark shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormPrinterMark is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormPrinterMark is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormPrinterMark shall have value Form</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Form"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormPrinterMark has incorrect value %1 instead of Form</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormPrinterMark shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormPrinterMark has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormPrinterMark">
			<id specification="PDF_1_4" clause="XObjectFormPrinterMark-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormPrinterMark shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormPrinterMark has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet" testNumber="1"/>
			<description>XObjectFormTrapNet shall not contain entries except BBox, DecodeParms, F, FDecodeParms, FFilter, Filter, FormType, Group, LastModified, Length, Matrix, Metadata, Name, OPI, PCM, PieceInfo, Ref, Resources, SeparationColorNames, StructParent, StructParents, Subtype, TrapRegions, TrapStyles, Type</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PCM' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'SeparationColorNames' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'TrapRegions' &amp;&amp; elem != 'TrapStyles' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormTrapNet contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PCM' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'SeparationColorNames' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'TrapRegions' &amp;&amp; elem != 'TrapStyles' &amp;&amp; elem != 'Type' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet" testNumber="22"/>
			<description>XObjectFormTrapNet shall not contain entries AF, DL, Measure, OC, PtData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').length == 0</test>
			<error>
				<message>XObjectFormTrapNet contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormTrapNet shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormTrapNet has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormTrapNet is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormTrapNet shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormTrapNet is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormTrapNet shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormTrapNet has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormTrapNet shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormTrapNet does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-F" testNumber="8"/>
			<description>Entry F in XObjectFormTrapNet shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormTrapNet has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormTrapNet shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormTrapNet is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormTrapNet shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormTrapNet has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormTrapNet shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormTrapNet does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormTrapNet shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormTrapNet has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormTrapNet shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormTrapNet does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormTrapNet shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormTrapNet has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormTrapNet shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormTrapNet has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormTrapNet shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormTrapNet does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormTrapNet shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormTrapNet has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormTrapNet shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormTrapNet has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormTrapNet shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormTrapNet has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Group" testNumber="8"/>
			<description>Entry Group in XObjectFormTrapNet shall have type Dictionary</description>
			<test>containsGroup == false || GroupHasTypeDictionary == true</test>
			<error>
				<message>Entry Group in XObjectFormTrapNet has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>GroupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-LastModified" testNumber="8"/>
			<description>Entry LastModified in XObjectFormTrapNet shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in XObjectFormTrapNet has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-LastModified" testNumber="11"/>
			<description>Entry LastModified in XObjectFormTrapNet is required, when fn:IsPresent(PieceInfo)</description>
			<test>containsLastModified == true || (containsPieceInfo != true)</test>
			<error>
				<message>Entry LastModified in XObjectFormTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormTrapNet shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormTrapNet has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormTrapNet is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormTrapNet shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormTrapNet has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectFormTrapNet shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectFormTrapNet has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectFormTrapNet shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectFormTrapNet is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Name" testNumber="8"/>
			<description>Entry Name in XObjectFormTrapNet shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectFormTrapNet has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectFormTrapNet shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectFormTrapNet is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectFormTrapNet shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectFormTrapNet has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-PCM" testNumber="8"/>
			<description>Entry PCM in XObjectFormTrapNet shall have type Name</description>
			<test>containsPCM == false || PCMHasTypeName == true</test>
			<error>
				<message>Entry PCM in XObjectFormTrapNet has type %1 instead of type Name</message>
				<arguments>
					<argument>PCMType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-PCM" testNumber="7"/>
			<description>Entry PCM in XObjectFormTrapNet is required</description>
			<test>containsPCM == true</test>
			<error>
				<message>Entry PCM in XObjectFormTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-PCM-Name" testNumber="6"/>
			<description>Entry PCM with type Name in XObjectFormTrapNet shall have one of values: DeviceGray, DeviceRGBK, DeviceRGB, DeviceN, DeviceCMYK, DeviceCMY</description>
			<test>PCMHasTypeName != true || PCMNameValue == "DeviceGray" || PCMNameValue == "DeviceRGB" || PCMNameValue == "DeviceCMYK" || PCMNameValue == "DeviceCMY" || PCMNameValue == "DeviceRGBK" || PCMNameValue == "DeviceN"</test>
			<error>
				<message>Entry PCM with type Name in XObjectFormTrapNet has incorrect value %1 instead of DeviceGray, DeviceRGBK, DeviceRGB, DeviceN, DeviceCMYK, DeviceCMY</message>
				<arguments>
					<argument>PCMNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-PieceInfo" testNumber="8"/>
			<description>Entry PieceInfo in XObjectFormTrapNet shall have type Dictionary</description>
			<test>containsPieceInfo == false || PieceInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry PieceInfo in XObjectFormTrapNet has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PieceInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-PieceInfo-Dictionary" testNumber="9"/>
			<description>Entry PieceInfo with type Dictionary in XObjectFormTrapNet shall satisfy special case: fn:Eval(fn:IsPresent(LastModified))</description>
			<test>PieceInfoHasTypeDictionary != true || (containsLastModified == true)</test>
			<error>
				<message>Entry PieceInfo with type Dictionary in XObjectFormTrapNet does not satisfy special case: fn:Eval(fn:IsPresent(LastModified))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Ref" testNumber="8"/>
			<description>Entry Ref in XObjectFormTrapNet shall have type Dictionary</description>
			<test>containsRef == false || RefHasTypeDictionary == true</test>
			<error>
				<message>Entry Ref in XObjectFormTrapNet has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RefType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Resources" testNumber="8"/>
			<description>Entry Resources in XObjectFormTrapNet shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in XObjectFormTrapNet has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-SeparationColorNames" testNumber="8"/>
			<description>Entry SeparationColorNames in XObjectFormTrapNet shall have type Array</description>
			<test>containsSeparationColorNames == false || SeparationColorNamesHasTypeArray == true</test>
			<error>
				<message>Entry SeparationColorNames in XObjectFormTrapNet has type %1 instead of type Array</message>
				<arguments>
					<argument>SeparationColorNamesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-StructParent" testNumber="8"/>
			<description>Entry StructParent in XObjectFormTrapNet shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in XObjectFormTrapNet has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-StructParents" testNumber="8"/>
			<description>Entry StructParents in XObjectFormTrapNet shall have type Integer</description>
			<test>containsStructParents == false || StructParentsHasTypeInteger == true</test>
			<error>
				<message>Entry StructParents in XObjectFormTrapNet has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormTrapNet shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormTrapNet has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormTrapNet is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormTrapNet is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormTrapNet shall have value Form</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Form"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormTrapNet has incorrect value %1 instead of Form</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-TrapRegions" testNumber="8"/>
			<description>Entry TrapRegions in XObjectFormTrapNet shall have type Array</description>
			<test>containsTrapRegions == false || TrapRegionsHasTypeArray == true</test>
			<error>
				<message>Entry TrapRegions in XObjectFormTrapNet has type %1 instead of type Array</message>
				<arguments>
					<argument>TrapRegionsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-TrapStyles" testNumber="8"/>
			<description>Entry TrapStyles in XObjectFormTrapNet shall have type StringText</description>
			<test>containsTrapStyles == false || TrapStylesHasTypeStringText == true</test>
			<error>
				<message>Entry TrapStyles in XObjectFormTrapNet has type %1 instead of type StringText</message>
				<arguments>
					<argument>TrapStylesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormTrapNet shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormTrapNet has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormTrapNet">
			<id specification="PDF_1_4" clause="XObjectFormTrapNet-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormTrapNet shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormTrapNet has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1" testNumber="1"/>
			<description>XObjectFormType1 shall not contain entries except BBox, DecodeParms, F, FDecodeParms, FFilter, Filter, FormType, Group, LastModified, Length, Matrix, Metadata, Name, OPI, PieceInfo, Ref, Resources, StructParent, StructParents, Subtype, Type, XUID</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XUID' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectFormType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BBox' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'FormType' &amp;&amp; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Group' &amp;&amp; elem != 'LastModified' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matrix' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PieceInfo' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'Ref' &amp;&amp; elem != 'Resources' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'StructParents' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'XUID' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1" testNumber="22"/>
			<description>XObjectFormType1 shall not contain entries AF, DL, GTS_Encapsulated, GTS_Env, GTS_Scope, GTS_XID, Measure, OC, PtData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'GTS_Encapsulated' || elem == 'GTS_Env' || elem == 'GTS_Scope' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').length == 0</test>
			<error>
				<message>XObjectFormType1 contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'GTS_Encapsulated' || elem == 'GTS_Env' || elem == 'GTS_Scope' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'OC' || elem == 'PtData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-BBox" testNumber="8"/>
			<description>Entry BBox in XObjectFormType1 shall have type Rectangle</description>
			<test>containsBBox == false || BBoxHasTypeRectangle == true</test>
			<error>
				<message>Entry BBox in XObjectFormType1 has type %1 instead of type Rectangle</message>
				<arguments>
					<argument>BBoxType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-BBox" testNumber="7"/>
			<description>Entry BBox in XObjectFormType1 is required</description>
			<test>containsBBox == true</test>
			<error>
				<message>Entry BBox in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectFormType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectFormType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectFormType1 shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectFormType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-F" testNumber="8"/>
			<description>Entry F in XObjectFormType1 shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectFormType1 has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectFormType1 shall be one of objects FilterLZWDecode, FilterFlateDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectFormType1 is not one of objects FilterLZWDecode, FilterFlateDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectFormType1 shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectFormType1 has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectFormType1 shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectFormType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectFormType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectFormType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectFormType1 shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectFormType1 has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectFormType1 shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectFormType1 does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectFormType1 shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectFormType1 has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, ASCII85Decode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FormType" testNumber="8"/>
			<description>Entry FormType in XObjectFormType1 shall have type Integer</description>
			<test>containsFormType == false || FormTypeHasTypeInteger == true</test>
			<error>
				<message>Entry FormType in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>FormTypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-FormType-Integer" testNumber="6"/>
			<description>Entry FormType with type Integer in XObjectFormType1 shall have value 1</description>
			<test>FormTypeHasTypeInteger != true || FormTypeIntegerValue == 1</test>
			<error>
				<message>Entry FormType with type Integer in XObjectFormType1 has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>FormTypeIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Group" testNumber="8"/>
			<description>Entry Group in XObjectFormType1 shall have type Dictionary</description>
			<test>containsGroup == false || GroupHasTypeDictionary == true</test>
			<error>
				<message>Entry Group in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>GroupType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-LastModified" testNumber="8"/>
			<description>Entry LastModified in XObjectFormType1 shall have type Date</description>
			<test>containsLastModified == false || LastModifiedHasTypeDate == true</test>
			<error>
				<message>Entry LastModified in XObjectFormType1 has type %1 instead of type Date</message>
				<arguments>
					<argument>LastModifiedType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-LastModified" testNumber="11"/>
			<description>Entry LastModified in XObjectFormType1 is required, when fn:IsPresent(PieceInfo)</description>
			<test>containsLastModified == true || (containsPieceInfo != true)</test>
			<error>
				<message>Entry LastModified in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Length" testNumber="8"/>
			<description>Entry Length in XObjectFormType1 shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Length" testNumber="7"/>
			<description>Entry Length in XObjectFormType1 is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Matrix" testNumber="8"/>
			<description>Entry Matrix in XObjectFormType1 shall have type Matrix</description>
			<test>containsMatrix == false || MatrixHasTypeMatrix == true</test>
			<error>
				<message>Entry Matrix in XObjectFormType1 has type %1 instead of type Matrix</message>
				<arguments>
					<argument>MatrixType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectFormType1 shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectFormType1 has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectFormType1 shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectFormType1 is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Name" testNumber="8"/>
			<description>Entry Name in XObjectFormType1 shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectFormType1 shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectFormType1 is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectFormType1 shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-PieceInfo" testNumber="8"/>
			<description>Entry PieceInfo in XObjectFormType1 shall have type Dictionary</description>
			<test>containsPieceInfo == false || PieceInfoHasTypeDictionary == true</test>
			<error>
				<message>Entry PieceInfo in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>PieceInfoType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-PieceInfo-Dictionary" testNumber="9"/>
			<description>Entry PieceInfo with type Dictionary in XObjectFormType1 shall satisfy special case: fn:Eval(fn:IsPresent(LastModified))</description>
			<test>PieceInfoHasTypeDictionary != true || (containsLastModified == true)</test>
			<error>
				<message>Entry PieceInfo with type Dictionary in XObjectFormType1 does not satisfy special case: fn:Eval(fn:IsPresent(LastModified))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Ref" testNumber="8"/>
			<description>Entry Ref in XObjectFormType1 shall have type Dictionary</description>
			<test>containsRef == false || RefHasTypeDictionary == true</test>
			<error>
				<message>Entry Ref in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>RefType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Resources" testNumber="8"/>
			<description>Entry Resources in XObjectFormType1 shall have type Dictionary</description>
			<test>containsResources == false || ResourcesHasTypeDictionary == true</test>
			<error>
				<message>Entry Resources in XObjectFormType1 has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>ResourcesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Resources" testNumber="7"/>
			<description>Entry Resources in XObjectFormType1 is required</description>
			<test>containsResources == true</test>
			<error>
				<message>Entry Resources in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-StructParent" testNumber="8"/>
			<description>Entry StructParent in XObjectFormType1 shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-StructParent-Integer" testNumber="9"/>
			<description>Entry StructParent with type Integer in XObjectFormType1 shall satisfy special case: fn:Not(fn:IsPresent(StructParents))</description>
			<test>StructParentHasTypeInteger != true || (containsStructParents != true)</test>
			<error>
				<message>Entry StructParent with type Integer in XObjectFormType1 does not satisfy special case: fn:Not(fn:IsPresent(StructParents))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-StructParents" testNumber="8"/>
			<description>Entry StructParents in XObjectFormType1 shall have type Integer</description>
			<test>containsStructParents == false || StructParentsHasTypeInteger == true</test>
			<error>
				<message>Entry StructParents in XObjectFormType1 has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-StructParents-Integer" testNumber="9"/>
			<description>Entry StructParents with type Integer in XObjectFormType1 shall satisfy special case: fn:Not(fn:IsPresent(StructParent))</description>
			<test>StructParentsHasTypeInteger != true || (containsStructParent != true)</test>
			<error>
				<message>Entry StructParents with type Integer in XObjectFormType1 does not satisfy special case: fn:Not(fn:IsPresent(StructParent))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectFormType1 shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectFormType1 is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectFormType1 is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectFormType1 shall have value Form</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Form"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectFormType1 has incorrect value %1 instead of Form</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Type" testNumber="8"/>
			<description>Entry Type in XObjectFormType1 shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectFormType1 has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectFormType1 shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectFormType1 has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-XUID" testNumber="8"/>
			<description>Entry XUID in XObjectFormType1 shall have type Array</description>
			<test>containsXUID == false || XUIDHasTypeArray == true</test>
			<error>
				<message>Entry XUID in XObjectFormType1 has type %1 instead of type Array</message>
				<arguments>
					<argument>XUIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectFormType1">
			<id specification="PDF_1_4" clause="XObjectFormType1-XUID" testNumber="5"/>
			<description>Entry XUID in XObjectFormType1 is deprecated since PDF 1.3</description>
			<test>containsXUID == false</test>
			<error>
				<message>Entry XUID in XObjectFormType1 is present</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage" testNumber="1"/>
			<description>XObjectImage shall not contain entries except Alternates, BitsPerComponent, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Height, ID, ImageMask, Intent, Interpolate, Length, Mask, Metadata, Name, OPI, SMask, StructParent, Subtype, Type, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Mask' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectImage contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'GTS_Encapsulated' &amp;&amp; elem != 'GTS_Env' &amp;&amp; elem != 'GTS_Scope' &amp;&amp; elem != 'GTS_XID' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Mask' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage" testNumber="22"/>
			<description>XObjectImage shall not contain entries AF, DL, GTS_Encapsulated, GTS_Env, GTS_Scope, GTS_XID, Measure, OC, PtData, SMaskInData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'GTS_Encapsulated' || elem == 'GTS_Env' || elem == 'GTS_Scope' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'OC' || elem == 'PtData' || elem == 'SMaskInData').length == 0</test>
			<error>
				<message>XObjectImage contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'GTS_Encapsulated' || elem == 'GTS_Env' || elem == 'GTS_Scope' || elem == 'GTS_XID' || elem == 'Measure' || elem == 'OC' || elem == 'PtData' || elem == 'SMaskInData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Alternates" testNumber="8"/>
			<description>Entry Alternates in XObjectImage shall have type Array</description>
			<test>containsAlternates == false || AlternatesHasTypeArray == true</test>
			<error>
				<message>Entry Alternates in XObjectImage has type %1 instead of type Array</message>
				<arguments>
					<argument>AlternatesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in XObjectImage shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-BitsPerComponent" testNumber="11"/>
			<description>Entry BitsPerComponent in XObjectImage is required, when fn:Not(fn:Contains(@Filter, JPXDecode) || (@ImageMask == true))</description>
			<test>containsBitsPerComponent == true || (((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JPXDecode").length &gt; 0) || (ImageMaskBooleanValue == true)) != true) == false</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-BitsPerComponent-Integer-1" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImage shall have Integer value 1, if this object satisfies condition (@Filter == CCITTFaxDecode) || (@Filter == JBIG2Decode) || (@ImageMask == true)</description>
			<test>((FilterNameValue != "CCITTFaxDecode") &amp;&amp; (FilterNameValue != "JBIG2Decode") &amp;&amp; (ImageMaskBooleanValue != true)) || BitsPerComponentIntegerValue == 1</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage does not have value 1</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-BitsPerComponent-Integer-8" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImage shall have Integer value 8, if this object satisfies condition (@Filter == RunLengthDecode) || (@Filter == DCTDecode)</description>
			<test>((FilterNameValue != "RunLengthDecode") &amp;&amp; (FilterNameValue != "DCTDecode")) || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImage does not have value 8</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in XObjectImage shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in XObjectImage has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace-Array" testNumber="17"/>
			<description>Entry ColorSpace with type Array in XObjectImage shall be one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</description>
			<test>ColorSpaceHasTypeArray != true || ColorSpace_size == 1</test>
			<error>
				<message>Entry ColorSpace with type Array in XObjectImage is not one of objects CalGrayColorSpace, CalRGBColorSpace, LabColorSpace, ICCBasedColorSpace, IndexedColorSpace, SeparationColorSpace, DeviceNColorSpace, PatternColorSpace</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in XObjectImage shall have one of types: Array, Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeArray == true || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace" testNumber="11"/>
			<description>Entry ColorSpace in XObjectImage is required, when fn:Not(fn:Contains(@Filter, JPXDecode) || (@ImageMask == true))</description>
			<test>containsColorSpace == true || (((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JPXDecode").length &gt; 0) || (ImageMaskBooleanValue == true)) != true) == false</test>
			<error>
				<message>Entry ColorSpace in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace-Array" testNumber="9"/>
			<description>Entry ColorSpace with type Array in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>ColorSpaceHasTypeArray != true || ((ImageMaskBooleanValue != true) || containsColorSpace != true)</test>
			<error>
				<message>Entry ColorSpace with type Array in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in XObjectImage shall have one of values: DeviceGray, DeviceRGB, DeviceCMYK</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceCMYK" || ColorSpaceNameValue == "DeviceRGB" || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in XObjectImage has incorrect value %1 instead of DeviceGray, DeviceRGB, DeviceCMYK</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ColorSpace-Name" testNumber="9"/>
			<description>Entry ColorSpace with type Name in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>ColorSpaceHasTypeName != true || ((ImageMaskBooleanValue != true) || containsColorSpace != true)</test>
			<error>
				<message>Entry ColorSpace with type Name in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Decode" testNumber="8"/>
			<description>Entry Decode in XObjectImage shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in XObjectImage has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectImage shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectImage is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectImage shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectImage has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-F" testNumber="8"/>
			<description>Entry F in XObjectImage shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectImage has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectImage shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectImage is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectImage shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectImage has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectImage shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectImage shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectImage has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectImage shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectImage has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectImage shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectImage does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectImage shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectImage has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Height" testNumber="8"/>
			<description>Entry Height in XObjectImage shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Height" testNumber="7"/>
			<description>Entry Height in XObjectImage is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ID" testNumber="8"/>
			<description>Entry ID in XObjectImage shall have type StringByte</description>
			<test>containsID == false || entryIDHasTypeStringByte == true</test>
			<error>
				<message>Entry ID in XObjectImage has type %1 instead of type StringByte</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ImageMask" testNumber="8"/>
			<description>Entry ImageMask in XObjectImage shall have type Boolean</description>
			<test>containsImageMask == false || ImageMaskHasTypeBoolean == true</test>
			<error>
				<message>Entry ImageMask in XObjectImage has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ImageMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-ImageMask-Boolean" testNumber="9"/>
			<description>Entry ImageMask with type Boolean in XObjectImage shall satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1) &amp;&amp; fn:Not(fn:IsPresent(ColorSpace)) &amp;&amp; fn:Not(fn:IsPresent(Mask))) || (@ImageMask == false))</description>
			<test>ImageMaskHasTypeBoolean != true || (((ImageMaskBooleanValue == true) &amp;&amp; (BitsPerComponentHasTypeInteger == false || (BitsPerComponentIntegerValue == 1)) &amp;&amp; (containsColorSpace != true) &amp;&amp; (containsMask != true)) || (ImageMaskBooleanValue == false))</test>
			<error>
				<message>Entry ImageMask with type Boolean in XObjectImage does not satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1) &amp;&amp; fn:Not(fn:IsPresent(ColorSpace)) &amp;&amp; fn:Not(fn:IsPresent(Mask))) || (@ImageMask == false))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Intent" testNumber="8"/>
			<description>Entry Intent in XObjectImage shall have type Name</description>
			<test>containsIntent == false || IntentHasTypeName == true</test>
			<error>
				<message>Entry Intent in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>IntentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Interpolate" testNumber="8"/>
			<description>Entry Interpolate in XObjectImage shall have type Boolean</description>
			<test>containsInterpolate == false || InterpolateHasTypeBoolean == true</test>
			<error>
				<message>Entry Interpolate in XObjectImage has type %1 instead of type Boolean</message>
				<arguments>
					<argument>InterpolateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Length" testNumber="8"/>
			<description>Entry Length in XObjectImage shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Length" testNumber="7"/>
			<description>Entry Length in XObjectImage is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Mask" testNumber="8"/>
			<description>Entry Mask in XObjectImage shall have one of types: Array, Stream</description>
			<test>containsMask == false || MaskHasTypeArray == true || MaskHasTypeStream == true</test>
			<error>
				<message>Entry Mask in XObjectImage has type %1 instead of one of types: Array, Stream</message>
				<arguments>
					<argument>MaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Mask-Array" testNumber="9"/>
			<description>Entry Mask with type Array in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>MaskHasTypeArray != true || ((ImageMaskBooleanValue != true) || containsMask != true)</test>
			<error>
				<message>Entry Mask with type Array in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Mask-Stream" testNumber="10"/>
			<description>Entry Mask with type Stream in XObjectImage shall be indirect</description>
			<test>MaskHasTypeStream != true || isMaskIndirect == true</test>
			<error>
				<message>Entry Mask with type Stream in XObjectImage is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Mask-Stream" testNumber="9"/>
			<description>Entry Mask with type Stream in XObjectImage shall satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</description>
			<test>MaskHasTypeStream != true || ((ImageMaskBooleanValue != true) || containsMask != true)</test>
			<error>
				<message>Entry Mask with type Stream in XObjectImage does not satisfy special case: fn:Not(fn:IsPresent(@ImageMask == true))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectImage shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectImage has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectImage shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectImage is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Name" testNumber="8"/>
			<description>Entry Name in XObjectImage shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectImage shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectImage is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectImage shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectImage has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-SMask" testNumber="8"/>
			<description>Entry SMask in XObjectImage shall have type Stream</description>
			<test>containsSMask == false || SMaskHasTypeStream == true</test>
			<error>
				<message>Entry SMask in XObjectImage has type %1 instead of type Stream</message>
				<arguments>
					<argument>SMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-SMask-Stream" testNumber="10"/>
			<description>Entry SMask with type Stream in XObjectImage shall be indirect</description>
			<test>SMaskHasTypeStream != true || isSMaskIndirect == true</test>
			<error>
				<message>Entry SMask with type Stream in XObjectImage is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-StructParent" testNumber="8"/>
			<description>Entry StructParent in XObjectImage shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage" deferred="true">
			<id specification="PDF_1_4" clause="XObjectImage-StructParent" testNumber="11"/>
			<description>Entry StructParent in XObjectImage is required, when fn:ImageIsStructContentItem()</description>
			<test>containsStructParent == true || (imageIsStructContentItem != true || SubtypeNameValue != "Image")</test>
			<error>
				<message>Entry StructParent in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectImage shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectImage is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectImage shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectImage has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Type" testNumber="8"/>
			<description>Entry Type in XObjectImage shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectImage has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectImage shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectImage has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Width" testNumber="8"/>
			<description>Entry Width in XObjectImage shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in XObjectImage has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImage">
			<id specification="PDF_1_4" clause="XObjectImage-Width" testNumber="7"/>
			<description>Entry Width in XObjectImage is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in XObjectImage is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask" testNumber="1"/>
			<description>XObjectImageMask shall not contain entries except Alternates, BitsPerComponent, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Height, ID, ImageMask, Intent, Interpolate, Length, Metadata, Name, OPI, SMask, StructParent, Subtype, Type, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectImageMask contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'Alternates' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ID' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Measure' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'OC' &amp;&amp; elem != 'OPI' &amp;&amp; elem != 'PtData' &amp;&amp; elem != 'SMask' &amp;&amp; elem != 'SMaskInData' &amp;&amp; elem != 'StructParent' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask" testNumber="22"/>
			<description>XObjectImageMask shall not contain entries AF, DL, Measure, OC, PtData, SMaskInData in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData' || elem == 'SMaskInData').length == 0</test>
			<error>
				<message>XObjectImageMask contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL' || elem == 'Measure' || elem == 'OC' || elem == 'PtData' || elem == 'SMaskInData').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Alternates" testNumber="8"/>
			<description>Entry Alternates in XObjectImageMask shall have type Array</description>
			<test>containsAlternates == false || AlternatesHasTypeArray == true</test>
			<error>
				<message>Entry Alternates in XObjectImageMask has type %1 instead of type Array</message>
				<arguments>
					<argument>AlternatesType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in XObjectImageMask shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImageMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in XObjectImageMask shall have value 1</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in XObjectImageMask has incorrect value %1 instead of 1</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Decode" testNumber="8"/>
			<description>Entry Decode in XObjectImageMask shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in XObjectImageMask has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="Decode" testNumber="20"/>
			<description>Entry Decode with type Array in XObjectImageMask shall have one of values: [1,0], [0,1]</description>
			<test>DecodeHasTypeArray != true || (DecodeArraySize == 2 &amp;&amp; Decode0IntegerValue == 0 &amp;&amp; Decode1IntegerValue == 1) || (DecodeArraySize == 2 &amp;&amp; Decode0IntegerValue == 1 &amp;&amp; Decode1IntegerValue == 0)</test>
			<error>
				<message>Entry Decode with type Array in XObjectImageMask has incorrect value instead of [1,0], [0,1]</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectImageMask shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectImageMask is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectImageMask shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectImageMask has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectImageMask shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectImageMask does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-F" testNumber="8"/>
			<description>Entry F in XObjectImageMask shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectImageMask has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectImageMask shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectImageMask is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectImageMask shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectImageMask has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectImageMask shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectImageMask does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectImageMask shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectImageMask has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectImageMask shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectImageMask does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectImageMask shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectImageMask has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectImageMask shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectImageMask has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectImageMask shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectImageMask does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectImageMask shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectImageMask has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Height" testNumber="8"/>
			<description>Entry Height in XObjectImageMask shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in XObjectImageMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Height" testNumber="7"/>
			<description>Entry Height in XObjectImageMask is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-ID" testNumber="8"/>
			<description>Entry ID in XObjectImageMask shall have type String</description>
			<test>containsID == false || entryIDHasTypeString == true</test>
			<error>
				<message>Entry ID in XObjectImageMask has type %1 instead of type String</message>
				<arguments>
					<argument>entryIDType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-ImageMask" testNumber="8"/>
			<description>Entry ImageMask in XObjectImageMask shall have type Boolean</description>
			<test>containsImageMask == false || ImageMaskHasTypeBoolean == true</test>
			<error>
				<message>Entry ImageMask in XObjectImageMask has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ImageMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-ImageMask" testNumber="7"/>
			<description>Entry ImageMask in XObjectImageMask is required</description>
			<test>containsImageMask == true</test>
			<error>
				<message>Entry ImageMask in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-ImageMask-Boolean" testNumber="9"/>
			<description>Entry ImageMask with type Boolean in XObjectImageMask shall satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1)) || (@ImageMask == false))</description>
			<test>ImageMaskHasTypeBoolean != true || (((ImageMaskBooleanValue == true) &amp;&amp; (BitsPerComponentHasTypeInteger == false || (BitsPerComponentIntegerValue == 1))) || (ImageMaskBooleanValue == false))</test>
			<error>
				<message>Entry ImageMask with type Boolean in XObjectImageMask does not satisfy special case: fn:Eval(((@ImageMask == true) &amp;&amp; (@BitsPerComponent == 1)) || (@ImageMask == false))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Intent" testNumber="8"/>
			<description>Entry Intent in XObjectImageMask shall have type Name</description>
			<test>containsIntent == false || IntentHasTypeName == true</test>
			<error>
				<message>Entry Intent in XObjectImageMask has type %1 instead of type Name</message>
				<arguments>
					<argument>IntentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Interpolate" testNumber="8"/>
			<description>Entry Interpolate in XObjectImageMask shall have type Boolean</description>
			<test>containsInterpolate == false || InterpolateHasTypeBoolean == true</test>
			<error>
				<message>Entry Interpolate in XObjectImageMask has type %1 instead of type Boolean</message>
				<arguments>
					<argument>InterpolateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Length" testNumber="8"/>
			<description>Entry Length in XObjectImageMask shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectImageMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Length" testNumber="7"/>
			<description>Entry Length in XObjectImageMask is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectImageMask shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectImageMask has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectImageMask shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectImageMask is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Name" testNumber="8"/>
			<description>Entry Name in XObjectImageMask shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectImageMask has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-OPI-Dictionary" testNumber="17"/>
			<description>Entry OPI with type Dictionary in XObjectImageMask shall be one of objects OPIVersion13, OPIVersion20</description>
			<test>OPIHasTypeDictionary != true || OPI_size == 1</test>
			<error>
				<message>Entry OPI with type Dictionary in XObjectImageMask is not one of objects OPIVersion13, OPIVersion20</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-OPI" testNumber="8"/>
			<description>Entry OPI in XObjectImageMask shall have type Dictionary</description>
			<test>containsOPI == false || OPIHasTypeDictionary == true</test>
			<error>
				<message>Entry OPI in XObjectImageMask has type %1 instead of type Dictionary</message>
				<arguments>
					<argument>OPIType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-SMask" testNumber="8"/>
			<description>Entry SMask in XObjectImageMask shall have type Stream</description>
			<test>containsSMask == false || SMaskHasTypeStream == true</test>
			<error>
				<message>Entry SMask in XObjectImageMask has type %1 instead of type Stream</message>
				<arguments>
					<argument>SMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-SMask-Stream" testNumber="10"/>
			<description>Entry SMask with type Stream in XObjectImageMask shall be indirect</description>
			<test>SMaskHasTypeStream != true || isSMaskIndirect == true</test>
			<error>
				<message>Entry SMask with type Stream in XObjectImageMask is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-StructParent" testNumber="8"/>
			<description>Entry StructParent in XObjectImageMask shall have type Integer</description>
			<test>containsStructParent == false || StructParentHasTypeInteger == true</test>
			<error>
				<message>Entry StructParent in XObjectImageMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>StructParentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask" deferred="true">
			<id specification="PDF_1_4" clause="XObjectImageMask-StructParent" testNumber="11"/>
			<description>Entry StructParent in XObjectImageMask is required, when fn:ImageIsStructContentItem()</description>
			<test>containsStructParent == true || (imageIsStructContentItem != true || SubtypeNameValue != "Image")</test>
			<error>
				<message>Entry StructParent in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectImageMask shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectImageMask has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectImageMask is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectImageMask shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectImageMask has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Type" testNumber="8"/>
			<description>Entry Type in XObjectImageMask shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectImageMask has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectImageMask shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectImageMask has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Width" testNumber="8"/>
			<description>Entry Width in XObjectImageMask shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in XObjectImageMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageMask">
			<id specification="PDF_1_4" clause="XObjectImageMask-Width" testNumber="7"/>
			<description>Entry Width in XObjectImageMask is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in XObjectImageMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask" testNumber="1"/>
			<description>XObjectImageSoftMask shall not contain entries except BitsPerComponent, ColorSpace, Decode, DecodeParms, F, FDecodeParms, FFilter, Filter, Height, ImageMask, Intent, Interpolate, Length, Matte, Metadata, Name, Subtype, Type, Width</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matte' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).length == 0</test>
			<error>
				<message>XObjectImageSoftMask contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem != 'AF' &amp;&amp; elem != 'BitsPerComponent' &amp;&amp; elem != 'ColorSpace' &amp;&amp; elem != 'DL' &amp;&amp; elem != 'Decode' &amp;&amp; elem != 'DecodeParms' &amp;&amp; elem != 'F' &amp;&amp; elem != 'FDecodeParms' &amp;&amp; elem != 'FFilter' &amp;&amp; elem != 'Filter' &amp;&amp; elem != 'Height' &amp;&amp; elem != 'ImageMask' &amp;&amp; elem != 'Intent' &amp;&amp; elem != 'Interpolate' &amp;&amp; elem != 'Length' &amp;&amp; elem != 'Matte' &amp;&amp; elem != 'Metadata' &amp;&amp; elem != 'Name' &amp;&amp; elem != 'Subtype' &amp;&amp; elem != 'Type' &amp;&amp; elem != 'Width' &amp;&amp; /^(XX|(.{4}[_:]))/.test(elem) == false).toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask" testNumber="22"/>
			<description>XObjectImageSoftMask shall not contain entries AF, DL in PDF 1.4. These entries appear in later pdf versions</description>
			<test>keysString == '' || keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL').length == 0</test>
			<error>
				<message>XObjectImageSoftMask contains entry(ies) %1</message>
				<arguments>
					<argument>keysString.split('&amp;').filter(elem =&gt; elem == 'AF' || elem == 'DL').toString()</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-BitsPerComponent" testNumber="8"/>
			<description>Entry BitsPerComponent in XObjectImageSoftMask shall have type Integer</description>
			<test>containsBitsPerComponent == false || BitsPerComponentHasTypeInteger == true</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImageSoftMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>BitsPerComponentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-BitsPerComponent" testNumber="11"/>
			<description>Entry BitsPerComponent in XObjectImageSoftMask is required, when fn:Not(fn:Contains(@Filter, JPXDecode) || (@ImageMask == true))</description>
			<test>containsBitsPerComponent == true || (((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JPXDecode").length &gt; 0) || (ImageMaskBooleanValue == true)) != true) == false</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-BitsPerComponent-Integer-1" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImageSoftMask shall have Integer value 1, if this object satisfies condition (fn:Contains(@Filter, CCITTFaxDecode) || fn:Contains(@Filter, JBIG2Decode))</description>
			<test>((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "CCITTFaxDecode").length &gt; 0) || (FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "JBIG2Decode").length &gt; 0)) == false || BitsPerComponentIntegerValue == 1</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImageSoftMask does not have value 1</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-BitsPerComponent-Integer-8" testNumber="15"/>
			<description>Entry BitsPerComponent in XObjectImageSoftMask shall have Integer value 8, if this object satisfies condition (fn:Contains(@Filter, RunLengthDecode) || fn:Contains(@Filter, DCTDecode))</description>
			<test>((FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "RunLengthDecode").length &gt; 0) || (FilterEntriesString != null &amp;&amp; FilterEntriesString.split('&amp;').filter(elem =&gt; elem == "DCTDecode").length &gt; 0)) == false || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent in XObjectImageSoftMask does not have value 8</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-BitsPerComponent-Integer" testNumber="6"/>
			<description>Entry BitsPerComponent with type Integer in XObjectImageSoftMask shall have one of values: 1, 2, 4, 8</description>
			<test>BitsPerComponentHasTypeInteger != true || BitsPerComponentIntegerValue == 1 || BitsPerComponentIntegerValue == 2 || BitsPerComponentIntegerValue == 4 || BitsPerComponentIntegerValue == 8</test>
			<error>
				<message>Entry BitsPerComponent with type Integer in XObjectImageSoftMask has incorrect value %1 instead of 1, 2, 4, 8</message>
				<arguments>
					<argument>BitsPerComponentIntegerValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-ColorSpace" testNumber="8"/>
			<description>Entry ColorSpace in XObjectImageSoftMask shall have type Name</description>
			<test>containsColorSpace == false || ColorSpaceHasTypeName == true</test>
			<error>
				<message>Entry ColorSpace in XObjectImageSoftMask has type %1 instead of type Name</message>
				<arguments>
					<argument>ColorSpaceType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-ColorSpace" testNumber="7"/>
			<description>Entry ColorSpace in XObjectImageSoftMask is required</description>
			<test>containsColorSpace == true</test>
			<error>
				<message>Entry ColorSpace in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-ColorSpace-Name" testNumber="6"/>
			<description>Entry ColorSpace with type Name in XObjectImageSoftMask shall have value DeviceGray</description>
			<test>ColorSpaceHasTypeName != true || ColorSpaceNameValue == "DeviceGray"</test>
			<error>
				<message>Entry ColorSpace with type Name in XObjectImageSoftMask has incorrect value %1 instead of DeviceGray</message>
				<arguments>
					<argument>ColorSpaceNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Decode" testNumber="8"/>
			<description>Entry Decode in XObjectImageSoftMask shall have type Array</description>
			<test>containsDecode == false || DecodeHasTypeArray == true</test>
			<error>
				<message>Entry Decode in XObjectImageSoftMask has type %1 instead of type Array</message>
				<arguments>
					<argument>DecodeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-DecodeParms-Dictionary" testNumber="17"/>
			<description>Entry DecodeParms with type Dictionary in XObjectImageSoftMask shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>DecodeParmsHasTypeDictionary != true || DecodeParms_size == 1</test>
			<error>
				<message>Entry DecodeParms with type Dictionary in XObjectImageSoftMask is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-DecodeParms" testNumber="8"/>
			<description>Entry DecodeParms in XObjectImageSoftMask shall have one of types: Array, Dictionary</description>
			<test>containsDecodeParms == false || DecodeParmsHasTypeArray == true || DecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry DecodeParms in XObjectImageSoftMask has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>DecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-DecodeParms-Array" testNumber="9"/>
			<description>Entry DecodeParms with type Array in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>DecodeParmsHasTypeArray != true || (FilterHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry DecodeParms with type Array in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-F" testNumber="8"/>
			<description>Entry F in XObjectImageSoftMask shall have one of types: Dictionary, String</description>
			<test>containsF == false || FHasTypeDictionary == true || FHasTypeString == true</test>
			<error>
				<message>Entry F in XObjectImageSoftMask has type %1 instead of one of types: Dictionary, String</message>
				<arguments>
					<argument>FType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FDecodeParms-Dictionary" testNumber="17"/>
			<description>Entry FDecodeParms with type Dictionary in XObjectImageSoftMask shall be one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</description>
			<test>FDecodeParmsHasTypeDictionary != true || FDecodeParms_size == 1</test>
			<error>
				<message>Entry FDecodeParms with type Dictionary in XObjectImageSoftMask is not one of objects FilterLZWDecode, FilterFlateDecode, FilterCCITTFaxDecode, FilterJBIG2Decode, FilterDCTDecode</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FDecodeParms" testNumber="8"/>
			<description>Entry FDecodeParms in XObjectImageSoftMask shall have one of types: Array, Dictionary</description>
			<test>containsFDecodeParms == false || FDecodeParmsHasTypeArray == true || FDecodeParmsHasTypeDictionary == true</test>
			<error>
				<message>Entry FDecodeParms in XObjectImageSoftMask has type %1 instead of one of types: Array, Dictionary</message>
				<arguments>
					<argument>FDecodeParmsType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FDecodeParms-Array" testNumber="9"/>
			<description>Entry FDecodeParms with type Array in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FDecodeParmsHasTypeArray != true || (FFilterHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FDecodeParms with type Array in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FFilter" testNumber="8"/>
			<description>Entry FFilter in XObjectImageSoftMask shall have one of types: Array, Name</description>
			<test>containsFFilter == false || FFilterHasTypeArray == true || FFilterHasTypeName == true</test>
			<error>
				<message>Entry FFilter in XObjectImageSoftMask has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FFilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FFilter-Array" testNumber="9"/>
			<description>Entry FFilter with type Array in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</description>
			<test>FFilterHasTypeArray != true || (FDecodeParmsHasTypeArray == false || FDecodeParmsArraySize == FFilterArraySize)</test>
			<error>
				<message>Entry FFilter with type Array in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:ArrayLength(FDecodeParms) == fn:ArrayLength(FFilter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-FFilter-Name" testNumber="6"/>
			<description>Entry FFilter with type Name in XObjectImageSoftMask shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FFilterHasTypeName != true || FFilterNameValue == "ASCIIHexDecode" || FFilterNameValue == "ASCII85Decode" || FFilterNameValue == "LZWDecode" || FFilterNameValue == "FlateDecode" || FFilterNameValue == "RunLengthDecode" || FFilterNameValue == "CCITTFaxDecode" || FFilterNameValue == "JBIG2Decode" || FFilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry FFilter with type Name in XObjectImageSoftMask has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FFilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Filter" testNumber="8"/>
			<description>Entry Filter in XObjectImageSoftMask shall have one of types: Array, Name</description>
			<test>containsFilter == false || FilterHasTypeArray == true || FilterHasTypeName == true</test>
			<error>
				<message>Entry Filter in XObjectImageSoftMask has type %1 instead of one of types: Array, Name</message>
				<arguments>
					<argument>FilterType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Filter-Array" testNumber="9"/>
			<description>Entry Filter with type Array in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</description>
			<test>FilterHasTypeArray != true || (DecodeParmsHasTypeArray == false || DecodeParmsArraySize == FilterArraySize)</test>
			<error>
				<message>Entry Filter with type Array in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:ArrayLength(DecodeParms) == fn:ArrayLength(Filter))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Filter-Name" testNumber="6"/>
			<description>Entry Filter with type Name in XObjectImageSoftMask shall have one of values: ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</description>
			<test>FilterHasTypeName != true || FilterNameValue == "ASCIIHexDecode" || FilterNameValue == "ASCII85Decode" || FilterNameValue == "LZWDecode" || FilterNameValue == "FlateDecode" || FilterNameValue == "RunLengthDecode" || FilterNameValue == "CCITTFaxDecode" || FilterNameValue == "JBIG2Decode" || FilterNameValue == "DCTDecode"</test>
			<error>
				<message>Entry Filter with type Name in XObjectImageSoftMask has incorrect value %1 instead of ASCIIHexDecode, LZWDecode, RunLengthDecode, JBIG2Decode, ASCII85Decode, CCITTFaxDecode, DCTDecode, FlateDecode</message>
				<arguments>
					<argument>FilterNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Height" testNumber="8"/>
			<description>Entry Height in XObjectImageSoftMask shall have type Integer</description>
			<test>containsHeight == false || HeightHasTypeInteger == true</test>
			<error>
				<message>Entry Height in XObjectImageSoftMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>HeightType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Height" testNumber="7"/>
			<description>Entry Height in XObjectImageSoftMask is required</description>
			<test>containsHeight == true</test>
			<error>
				<message>Entry Height in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Height-Integer" testNumber="9"/>
			<description>Entry Height with type Integer in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:IsPresent(Matte, (@Height == parent::@Height)))</description>
			<test>HeightHasTypeInteger != true || (parentHeightHasTypeInteger == false || ((containsMatte == false) || (HeightIntegerValue == parentHeightIntegerValue)))</test>
			<error>
				<message>Entry Height with type Integer in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:IsPresent(Matte, (@Height == parent::@Height)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-ImageMask" testNumber="8"/>
			<description>Entry ImageMask in XObjectImageSoftMask shall have type Boolean</description>
			<test>containsImageMask == false || ImageMaskHasTypeBoolean == true</test>
			<error>
				<message>Entry ImageMask in XObjectImageSoftMask has type %1 instead of type Boolean</message>
				<arguments>
					<argument>ImageMaskType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-ImageMask-Boolean" testNumber="9"/>
			<description>Entry ImageMask with type Boolean in XObjectImageSoftMask shall satisfy special case: fn:Eval(@ImageMask == false)</description>
			<test>ImageMaskHasTypeBoolean != true || (ImageMaskBooleanValue == false)</test>
			<error>
				<message>Entry ImageMask with type Boolean in XObjectImageSoftMask does not satisfy special case: fn:Eval(@ImageMask == false)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Intent" testNumber="8"/>
			<description>Entry Intent in XObjectImageSoftMask shall have type Name</description>
			<test>containsIntent == false || IntentHasTypeName == true</test>
			<error>
				<message>Entry Intent in XObjectImageSoftMask has type %1 instead of type Name</message>
				<arguments>
					<argument>IntentType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Interpolate" testNumber="8"/>
			<description>Entry Interpolate in XObjectImageSoftMask shall have type Boolean</description>
			<test>containsInterpolate == false || InterpolateHasTypeBoolean == true</test>
			<error>
				<message>Entry Interpolate in XObjectImageSoftMask has type %1 instead of type Boolean</message>
				<arguments>
					<argument>InterpolateType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Length" testNumber="8"/>
			<description>Entry Length in XObjectImageSoftMask shall have type Integer</description>
			<test>containsLength == false || LengthHasTypeInteger == true</test>
			<error>
				<message>Entry Length in XObjectImageSoftMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>LengthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Length" testNumber="7"/>
			<description>Entry Length in XObjectImageSoftMask is required</description>
			<test>containsLength == true</test>
			<error>
				<message>Entry Length in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Matte" testNumber="8"/>
			<description>Entry Matte in XObjectImageSoftMask shall have type Array</description>
			<test>containsMatte == false || MatteHasTypeArray == true</test>
			<error>
				<message>Entry Matte in XObjectImageSoftMask has type %1 instead of type Array</message>
				<arguments>
					<argument>MatteType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Matte-Array" testNumber="9"/>
			<description>Entry Matte with type Array in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:ArrayLength(Matte) &gt; 0)</description>
			<test>MatteHasTypeArray != true || (MatteArraySize &gt; 0)</test>
			<error>
				<message>Entry Matte with type Array in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:ArrayLength(Matte) &gt; 0)</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Metadata" testNumber="8"/>
			<description>Entry Metadata in XObjectImageSoftMask shall have type Stream</description>
			<test>containsMetadata == false || MetadataHasTypeStream == true</test>
			<error>
				<message>Entry Metadata in XObjectImageSoftMask has type %1 instead of type Stream</message>
				<arguments>
					<argument>MetadataType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Metadata-Stream" testNumber="10"/>
			<description>Entry Metadata with type Stream in XObjectImageSoftMask shall be indirect</description>
			<test>MetadataHasTypeStream != true || isMetadataIndirect == true</test>
			<error>
				<message>Entry Metadata with type Stream in XObjectImageSoftMask is direct</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Name" testNumber="8"/>
			<description>Entry Name in XObjectImageSoftMask shall have type Name</description>
			<test>containsName == false || NameHasTypeName == true</test>
			<error>
				<message>Entry Name in XObjectImageSoftMask has type %1 instead of type Name</message>
				<arguments>
					<argument>NameType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Subtype" testNumber="8"/>
			<description>Entry Subtype in XObjectImageSoftMask shall have type Name</description>
			<test>containsSubtype == false || SubtypeHasTypeName == true</test>
			<error>
				<message>Entry Subtype in XObjectImageSoftMask has type %1 instead of type Name</message>
				<arguments>
					<argument>SubtypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Subtype" testNumber="7"/>
			<description>Entry Subtype in XObjectImageSoftMask is required</description>
			<test>containsSubtype == true</test>
			<error>
				<message>Entry Subtype in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Subtype-Name" testNumber="6"/>
			<description>Entry Subtype with type Name in XObjectImageSoftMask shall have value Image</description>
			<test>SubtypeHasTypeName != true || SubtypeNameValue == "Image"</test>
			<error>
				<message>Entry Subtype with type Name in XObjectImageSoftMask has incorrect value %1 instead of Image</message>
				<arguments>
					<argument>SubtypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Type" testNumber="8"/>
			<description>Entry Type in XObjectImageSoftMask shall have type Name</description>
			<test>containsType == false || TypeHasTypeName == true</test>
			<error>
				<message>Entry Type in XObjectImageSoftMask has type %1 instead of type Name</message>
				<arguments>
					<argument>TypeType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Type-Name" testNumber="6"/>
			<description>Entry Type with type Name in XObjectImageSoftMask shall have value XObject</description>
			<test>TypeHasTypeName != true || TypeNameValue == "XObject"</test>
			<error>
				<message>Entry Type with type Name in XObjectImageSoftMask has incorrect value %1 instead of XObject</message>
				<arguments>
					<argument>TypeNameValue</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Width" testNumber="8"/>
			<description>Entry Width in XObjectImageSoftMask shall have type Integer</description>
			<test>containsWidth == false || WidthHasTypeInteger == true</test>
			<error>
				<message>Entry Width in XObjectImageSoftMask has type %1 instead of type Integer</message>
				<arguments>
					<argument>WidthType</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Width" testNumber="7"/>
			<description>Entry Width in XObjectImageSoftMask is required</description>
			<test>containsWidth == true</test>
			<error>
				<message>Entry Width in XObjectImageSoftMask is missing</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectImageSoftMask">
			<id specification="PDF_1_4" clause="XObjectImageSoftMask-Width-Integer" testNumber="9"/>
			<description>Entry Width with type Integer in XObjectImageSoftMask shall satisfy special case: fn:Eval(fn:IsPresent(Matte, (@Width == parent::@Width)))</description>
			<test>WidthHasTypeInteger != true || (parentWidthHasTypeInteger == false || ((containsMatte == false) || (WidthIntegerValue == parentWidthIntegerValue)))</test>
			<error>
				<message>Entry Width with type Integer in XObjectImageSoftMask does not satisfy special case: fn:Eval(fn:IsPresent(Matte, (@Width == parent::@Width)))</message>
				<arguments/>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_4" clause="XObjectMapEntry-Stream" testNumber="17"/>
			<description>Entry with type Stream in XObjectMap shall be one of objects XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough</description>
			<test>HasTypeStream != true || Entry_size == 1</test>
			<error>
				<message>Entry %keyName% with type Stream in XObjectMap is not one of objects XObjectFormType1, XObjectImage, XObjectFormPS, XObjectFormPSpassthrough</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_4" clause="XObjectMapEntry" testNumber="8"/>
			<description>Entry in XObjectMap shall have type Stream</description>
			<test>HasTypeStream == true</test>
			<error>
				<message>Entry %keyName% in XObjectMap has type %1 instead of type Stream</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="AXObjectMapEntry">
			<id specification="PDF_1_4" clause="XObjectMapEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in XObjectMap shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in XObjectMap is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalArrayEntry">
			<id specification="PDF_1_4" clause="_UniversalArrayEntry" testNumber="8"/>
			<description>Entry in _UniversalArray shall have one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</description>
			<test>HasTypeArray == true || HasTypeBoolean == true || HasTypeDictionary == true || HasTypeName == true || HasTypeNull == true || HasTypeNumber == true || HasTypeStream == true || HasTypeString == true</test>
			<error>
				<message>Entry %keyName% in _UniversalArray has type %1 instead of one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalArrayEntry">
			<id specification="PDF_1_4" clause="_UniversalArrayEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in _UniversalArray shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in _UniversalArray is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalDictionaryEntry">
			<id specification="PDF_1_4" clause="_UniversalDictionaryEntry" testNumber="8"/>
			<description>Entry in _UniversalDictionary shall have one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</description>
			<test>HasTypeArray == true || HasTypeBoolean == true || HasTypeDictionary == true || HasTypeName == true || HasTypeNull == true || HasTypeNumber == true || HasTypeStream == true || HasTypeString == true</test>
			<error>
				<message>Entry %keyName% in _UniversalDictionary has type %1 instead of one of types: Array, Boolean, Dictionary, Name, Null, Number, Stream, String</message>
				<arguments>
					<argument>Type</argument>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
		<rule object="A_UniversalDictionaryEntry">
			<id specification="PDF_1_4" clause="_UniversalDictionaryEntry-Stream" testNumber="10"/>
			<description>Entry with type Stream in _UniversalDictionary shall be indirect</description>
			<test>HasTypeStream != true || isIndirect == true</test>
			<error>
				<message>Entry %keyName% with type Stream in _UniversalDictionary is direct</message>
				<arguments>
					<argument name="keyName">keyName</argument>
				</arguments>
			</error>
			<references/>
		</rule>
	</rules>
	<variables/>
</profile>
